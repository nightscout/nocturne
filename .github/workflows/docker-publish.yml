name: Build and Publish with Aspire

on:
  push:
    branches: [master, main]
    tags: ["v*"]
  pull_request:
    branches: [master, main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_REPOSITORY: ${{ github.repository }}
  DOTNET_VERSION: "10.0.x"
  NODE_VERSION: "24"
  PNPM_VERSION: "9"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Aspire CLI
        run: dotnet tool install --global aspire.cli

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"
          cache-dependency-path: src/Web/pnpm-lock.yaml

      - name: Install web dependencies
        working-directory: src/Web
        run: pnpm install --frozen-lockfile

      - name: Build bridge package
        working-directory: src/Web/packages/bridge
        run: pnpm run build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version tag
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          elif [[ "${{ github.ref }}" == refs/heads/master ]] || [[ "${{ github.ref }}" == refs/heads/main ]]; then
            VERSION=latest
          else
            VERSION=${GITHUB_REF#refs/heads/}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Build oref.wasm
        working-directory: src/Core/oref
        run: cargo build --release --target wasm32-unknown-unknown

      - name: Restore .NET dependencies
        run: dotnet restore

      # Copy appsettings.example.json to appsettings.json for NSwag client generation
      # The actual values don't matter for NSwag - it just needs the file to exist
      # to satisfy the Program.cs configuration loading during OpenAPI schema extraction
      - name: Setup appsettings.json for NSwag
        run: cp appsettings.example.json appsettings.json

      # Build container images using .NET's built-in container support
      # Aspire projects are standard .NET projects that can be published as containers
      - name: Build and push Nocturne.API container
        if: github.event_name != 'pull_request'
        working-directory: src/API/Nocturne.API
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/nocturne-api \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      # Build connector containers using .NET's built-in container support
      - name: Build and push Dexcom connector
        if: github.event_name != 'pull_request'
        working-directory: src/Connectors/Nocturne.Connectors.Dexcom
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/dexcom-connector \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      - name: Build and push Glooko connector
        if: github.event_name != 'pull_request'
        working-directory: src/Connectors/Nocturne.Connectors.Glooko
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/glooko-connector \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      - name: Build and push FreeStyle connector
        if: github.event_name != 'pull_request'
        working-directory: src/Connectors/Nocturne.Connectors.FreeStyle
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/freestyle-connector \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      - name: Build and push MiniMed connector
        if: github.event_name != 'pull_request'
        working-directory: src/Connectors/Nocturne.Connectors.MiniMed
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/minimed-connector \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      - name: Build and push Nightscout connector
        if: github.event_name != 'pull_request'
        working-directory: src/Connectors/Nocturne.Connectors.Nightscout
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/nightscout-connector \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      - name: Build and push MyFitnessPal connector
        if: github.event_name != 'pull_request'
        working-directory: src/Connectors/Nocturne.Connectors.MyFitnessPal
        run: |
          dotnet publish \
            -c Release \
            -p:PublishProfile=DefaultContainer \
            -p:ContainerRegistry=${{ env.REGISTRY }} \
            -p:ContainerRepository=${{ env.IMAGE_REPOSITORY }}/myfitnespal-connector \
            -p:ContainerImageTag=${{ steps.version.outputs.version }}

      # Build web app using standard Docker build (Node.js/Vite apps don't use .NET container publishing)
      - name: Build and push Nocturne.Web container
        if: github.event_name != 'pull_request'
        run: |
          # Create optimized Dockerfile for SvelteKit production build
          cat > Dockerfile.web << 'EOF'
          FROM node:24-alpine AS builder
          WORKDIR /app
          RUN npm install -g pnpm@9

          # Copy workspace files
          COPY src/Web/package.json src/Web/pnpm-lock.yaml src/Web/pnpm-workspace.yaml ./
          COPY src/Web/packages ./packages

          # Install dependencies
          RUN pnpm install --frozen-lockfile

          # Build bridge package first (required by app)
          RUN pnpm --filter @nocturne/bridge run build

          # Set default build-time environment variables for SvelteKit
          ENV PUBLIC_API_URL=http://localhost:1612
          ENV PUBLIC_WEBSOCKET_RECONNECT_ATTEMPTS=5
          ENV PUBLIC_WEBSOCKET_RECONNECT_DELAY=1000
          ENV PUBLIC_WEBSOCKET_MAX_RECONNECT_DELAY=30000
          ENV PUBLIC_WEBSOCKET_PING_TIMEOUT=15000
          ENV PUBLIC_WEBSOCKET_PING_INTERVAL=20000

          # Build the app
          RUN pnpm --filter @nocturne/app run build

          FROM node:24-alpine
          WORKDIR /app

          # Copy built artifacts
          COPY --from=builder /app/packages/app/build ./build
          COPY --from=builder /app/packages/app/package.json ./

          ENV NODE_ENV=production
          ENV PORT=5173
          EXPOSE 5173

          CMD ["node", "build"]
          EOF

          docker buildx build \
            --platform linux/amd64 \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/nocturne-web:${{ steps.version.outputs.version }} \
            --file Dockerfile.web \
            --push \
            .

  publish-aspire-manifest:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Aspire CLI
        run: dotnet tool install --global aspire.cli

      - name: Restore .NET dependencies
        run: dotnet restore

      # Copy appsettings.example.json to appsettings.json for NSwag client generation
      - name: Setup appsettings.json for NSwag
        run: cp appsettings.example.json appsettings.json

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Build oref.wasm
        working-directory: src/Core/oref
        run: cargo build --release --target wasm32-unknown-unknown

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"
          cache-dependency-path: src/Web/pnpm-lock.yaml

      - name: Install web dependencies
        working-directory: src/Web
        run: pnpm install --frozen-lockfile

      - name: Build bridge package
        working-directory: src/Web/packages/bridge
        run: pnpm run build

      - name: Determine version tag
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          elif [[ "${{ github.ref }}" == refs/heads/master ]] || [[ "${{ github.ref }}" == refs/heads/main ]]; then
            VERSION=latest
          else
            VERSION=${GITHUB_REF#refs/heads/}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # Use Aspire's publish command to generate deployment manifests
      - name: Generate Aspire deployment artifacts
        working-directory: src/Aspire/Nocturne.Aspire.Host
        env:
          ContainerRegistry: ${{ env.REGISTRY }}
          ContainerRepository: ${{ env.IMAGE_REPOSITORY }}
          IMAGE_TAG: ${{ steps.version.outputs.version }}
        run: |
          mkdir -p ../../../release

          # Generate docker-compose artifacts using Aspire CLI
          # We output to the repo root so it's easy to find/use
          aspire publish \
            --project . \
            --publisher docker-compose \
            --output-path ../../../ \
            --no-build

          # Also generate the Aspire manifest for advanced deployments
          aspire publish \
            --project . \
            --publisher manifest \
            --output-path ../../../release

      - name: Create deployment documentation
        run: |
          cat > release/README.md << 'EOF'
          # Nocturne Aspire Deployment

          Version: ${{ github.ref_name }}
          Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}

          ## Quick Start

          1. Copy `.env.example` to `.env` and configure your environment variables
          2. Update image references in `docker-compose.yaml` to use version `${{ steps.version.outputs.version }}`
          3. Run: `docker compose up -d`

          ## Container Images

          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/api:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/web:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/dexcom-connector:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/glooko-connector:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/freestyle-connector:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/minimed-connector:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/nightscout-connector:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/myfitnespal-connector:${{ steps.version.outputs.version }}`

          ## Files in this release

          - `docker-compose.yaml` - Docker Compose orchestration (generated by Aspire)
          - `aspire-manifest.json` - Aspire deployment manifest (for advanced scenarios)
          - `.env.example` - Environment variables template

          ## Deployment Options

          ### Docker Compose (Recommended)
          ```bash
          docker compose up -d
          ```

          ### Aspire Deploy (Advanced)
          ```bash
          aspire deploy --manifest aspire-manifest.json
          ```
          EOF

          # Copy env example if it exists
          if [ -f .env.example ]; then
            cp .env.example release/
          fi

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nocturne-deployment-${{ steps.version.outputs.version }}
          path: release/
          retention-days: 90

  # security-scan:
  #   needs: build-and-push
  #   runs-on: ubuntu-latest
  #   if: github.event_name != 'pull_request'
  #   permissions:
  #     contents: read
  #     packages: read
  #     security-events: write
  #     actions: read
  #   strategy:
  #     matrix:
  #       image-name:
  #         - nocturne-api
  #         - nocturne-web
  #         - dexcom-connector
  #         - glooko-connector
  #         - freestyle-connector
  #         - minimed-connector
  #         - nightscout-connector
  #         - myfitnespal-connector

  #   steps:
  #     - name: Log in to GitHub Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ${{ env.REGISTRY }}
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Determine version tag
  #       id: version
  #       run: |
  #         if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
  #           VERSION=${GITHUB_REF#refs/tags/v}
  #         elif [[ "${{ github.ref }}" == refs/heads/master ]] || [[ "${{ github.ref }}" == refs/heads/main ]]; then
  #           VERSION=latest
  #         else
  #           VERSION=${GITHUB_REF#refs/heads/}
  #         fi
  #         echo "version=$VERSION" >> $GITHUB_OUTPUT

  #     - name: Run Trivy vulnerability scanner
  #       uses: aquasecurity/trivy-action@master
  #       with:
  #         image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/${{ matrix.image-name }}:${{ steps.version.outputs.version }}'
  #         format: 'sarif'
  #         output: 'trivy-results.sarif'
  #         severity: 'CRITICAL,HIGH'

  #     - name: Upload Trivy results to GitHub Security
  #       uses: github/codeql-action/upload-sarif@v4
  #       if: always()
  #       with:
  #         sarif_file: 'trivy-results.sarif'
  #         category: ${{ matrix.image-name }}
