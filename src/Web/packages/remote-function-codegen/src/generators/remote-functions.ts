// src/Web/packages/remote-function-codegen/src/generators/remote-functions.ts
import type { OperationInfo, ParsedSpec } from '../types.js';
import {
  operationIdToFunctionName,
  tagToFileName,
  resolveInvalidation,
} from '../utils/naming.js';
import { getClientPropertyName } from '../utils/client-mapping.js';

export function generateRemoteFunctions(parsed: ParsedSpec): Map<string, string> {
  const fileContents = new Map<string, string>();

  // Group operations by tag
  const byTag = new Map<string, OperationInfo[]>();
  for (const op of parsed.operations) {
    const existing = byTag.get(op.tag) ?? [];
    existing.push(op);
    byTag.set(op.tag, existing);
  }

  // Generate file for each tag
  for (const [tag, operations] of byTag) {
    const fileName = `${tagToFileName(tag)}.generated.remote.ts`;
    const content = generateTagFile(tag, operations);
    fileContents.set(fileName, content);
  }

  // Generate barrel export (pass operations to detect name collisions)
  const indexContent = generateIndexFile(byTag);
  fileContents.set('index.ts', indexContent);

  return fileContents;
}

function generateTagFile(tag: string, operations: OperationInfo[]): string {
  const schemaImports = new Set<string>();
  const typeImports = new Set<string>();
  const enumImports = new Set<string>();

  // Collect imports
  for (const op of operations) {
    if (op.requestBodySchema) {
      schemaImports.add(op.requestBodySchema);
      const typeName = op.requestBodySchema.replace(/Schema$/, '');
      typeImports.add(typeName);
    }
    for (const param of op.parameters) {
      if (param.enumName) {
        enumImports.add(param.enumName);
      }
    }
  }

  const schemaImportLine = schemaImports.size > 0
    ? `import { ${Array.from(schemaImports).join(', ')} } from '$lib/api/generated/schemas';\n`
    : '';

  // Build $api import line with both value imports (enums) and type imports (DTOs)
  let apiImportLine = '';
  const valueImports = Array.from(enumImports);
  const typeOnlyImports = Array.from(typeImports);
  if (valueImports.length > 0 || typeOnlyImports.length > 0) {
    const parts = [
      ...valueImports,
      ...typeOnlyImports.map(t => `type ${t}`),
    ];
    apiImportLine = `import { ${parts.join(', ')} } from '$api';\n`;
  }

  const functions = operations.map(op => generateFunction(op, tag, operations)).join('\n\n');

  // Only import query/command if actually used
  const hasQuery = operations.some(op => op.remoteType === 'query');
  const hasCommand = operations.some(op => op.remoteType === 'command');
  const serverImports = ['getRequestEvent', ...(hasQuery ? ['query'] : []), ...(hasCommand ? ['command'] : [])];

  // Only import z from zod if any function actually uses Zod schema constructors
  const usesZod = operations.some(op => {
    const hasPathParams = op.parameters.some(p => p.in === 'path');
    const hasQueryParams = op.parameters.some(p => p.in === 'query');
    const hasInlineBody = op.inlineRequestBody !== undefined;
    return hasPathParams || hasQueryParams || op.isArrayBody || hasInlineBody;
  });
  const zodImportLine = usesZod ? `import { z } from 'zod';\n` : '';

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { ${serverImports.join(', ')} } from '$app/server';
import { error, redirect } from '@sveltejs/kit';
${zodImportLine}${schemaImportLine}${apiImportLine}
${functions}
`;
}

function generateFunction(op: OperationInfo, tag: string, allOpsInTag: OperationInfo[]): string {
  const functionName = operationIdToFunctionName(op.operationId);
  const clientProperty = op.clientPropertyName ?? getClientPropertyName(tag);
  const methodName = getMethodName(op.operationId, tag);

  if (op.remoteType === 'query') {
    return generateQueryFunction(op, functionName, clientProperty, methodName);
  } else {
    return generateCommandFunction(op, functionName, clientProperty, methodName, tag, allOpsInTag);
  }
}

function generateQueryFunction(
  op: OperationInfo,
  functionName: string,
  clientProperty: string,
  methodName: string
): string {
  const { schemaArg, paramList, apiCallArgs } = buildParameterMapping(op);
  const comment = op.summary ? `/** ${op.summary} */\n` : '';

  if (schemaArg) {
    return `${comment}export const ${functionName} = query(${schemaArg}, async (${paramList}) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.${clientProperty}.${methodName}(${apiCallArgs});
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, \`/login?redirectTo=\${encodeURIComponent(url.pathname + url.search)}\`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
  }

  return `${comment}export const ${functionName} = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.${clientProperty}.${methodName}();
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, \`/login?redirectTo=\${encodeURIComponent(url.pathname + url.search)}\`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
}

function generateCommandFunction(
  op: OperationInfo,
  functionName: string,
  clientProperty: string,
  methodName: string,
  tag: string,
  allOpsInTag: OperationInfo[]
): string {
  const { schemaArg, paramList, apiCallArgs } = buildParameterMapping(op);

  // Build invalidation calls
  const invalidations = op.invalidates.map(inv => {
    const resolved = resolveInvalidation(inv, tag);
    return resolved.functionName;
  });

  // Filter to only include functions that exist in the same file (same tag)
  const localFunctionNames = new Set(allOpsInTag.map(o => operationIdToFunctionName(o.operationId)));
  const localInvalidations = invalidations.filter(fn => localFunctionNames.has(fn));

  // Build refresh calls
  const commandPathParams = op.parameters.filter(p => p.in === 'path');
  const commandPathParamNames = new Set(commandPathParams.map(p => p.name));

  const refreshCallsArr = localInvalidations.map(fn => {
    // Check if the target function actually takes a path parameter
    const targetOp = allOpsInTag.find(o => operationIdToFunctionName(o.operationId) === fn);
    const targetPathParams = targetOp?.parameters.filter(p => p.in === 'path') ?? [];

    if (targetPathParams.length > 0) {
      // Find matching path param names between the command and the target query
      const matchingParams = targetPathParams.filter(p => commandPathParamNames.has(p.name));

      if (matchingParams.length > 0) {
        // For single-param target queries, pass the matching param directly
        // For multi-param targets, pass as object (though this is uncommon for query invalidation)
        if (targetPathParams.length === 1) {
          return `${fn}(${matchingParams[0].name}).refresh()`;
        }
        // Multi-param target query - pass the first matching param
        return `${fn}(${matchingParams[0].name}).refresh()`;
      }
    }

    return `${fn}(undefined).refresh()`;
  });

  const refreshCalls = refreshCallsArr.length > 0
    ? `\n    await Promise.all([
      ${refreshCallsArr.join(',\n      ')}
    ]);`
    : '';

  const comment = op.summary ? `/** ${op.summary} */\n` : '';

  // Handle void responses (204 No Content)
  const apiCall = op.isVoidResponse
    ? `    await apiClient.${clientProperty}.${methodName}(${apiCallArgs});${refreshCalls}
    return { success: true };`
    : `    const result = await apiClient.${clientProperty}.${methodName}(${apiCallArgs});${refreshCalls}
    return result;`;

  if (schemaArg) {
    return `${comment}export const ${functionName} = command(${schemaArg}, async (${paramList}) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
${apiCall}
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, \`/login?redirectTo=\${encodeURIComponent(url.pathname + url.search)}\`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
  }

  return `${comment}export const ${functionName} = command(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
${apiCall}
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, \`/login?redirectTo=\${encodeURIComponent(url.pathname + url.search)}\`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
}

function buildParameterMapping(op: OperationInfo): {
  schemaArg: string;
  paramList: string;
  apiCallArgs: string;
} {
  const pathParams = op.parameters.filter(p => p.in === 'path');
  const queryParams = op.parameters.filter(p => p.in === 'query');
  const hasNamedBody = !!op.requestBodySchema;
  const hasInlineBody = !!op.inlineRequestBody;
  const hasBody = hasNamedBody || hasInlineBody;

  // Single path param only (e.g., GET /trackers/{id})
  if (pathParams.length === 1 && queryParams.length === 0 && !hasBody) {
    const param = pathParams[0];
    const zodType = param.enumName ? `z.enum(${param.enumName})` : 'z.string()';
    return {
      schemaArg: zodType,
      paramList: param.name,
      apiCallArgs: param.name,
    };
  }

  // Multiple path params, no request body (e.g., POST /notifications/{id}/actions/{actionId})
  if (pathParams.length > 1 && queryParams.length === 0 && !hasBody) {
    const fields = pathParams.map(p => {
      const zodType = p.enumName ? `z.enum(${p.enumName})` : 'z.string()';
      return `${p.name}: ${zodType}`;
    });
    const paramNames = pathParams.map(p => p.name);
    return {
      schemaArg: `z.object({ ${fields.join(', ')} })`,
      paramList: `{ ${paramNames.join(', ')} }`,
      apiCallArgs: paramNames.join(', '),
    };
  }

  // Request body only (named schema, e.g., POST /trackers or POST /treatments/bulk)
  if (pathParams.length === 0 && queryParams.length === 0 && hasNamedBody) {
    const typeName = op.requestBodySchema!.replace(/Schema$/, '');
    const bodyOptional = !op.requestBodyRequired;
    if (op.isArrayBody) {
      return {
        schemaArg: `z.array(${op.requestBodySchema})`,
        paramList: 'request',
        apiCallArgs: `request as ${typeName}[]`,
      };
    }
    if (bodyOptional) {
      return {
        schemaArg: `${op.requestBodySchema}.optional()`,
        paramList: 'request',
        apiCallArgs: `(request ?? {}) as ${typeName}`,
      };
    }
    return {
      schemaArg: op.requestBodySchema!,
      paramList: 'request',
      apiCallArgs: `request as ${typeName}`,
    };
  }

  // Inline request body only (e.g., POST with Dictionary<string, string>)
  if (pathParams.length === 0 && queryParams.length === 0 && hasInlineBody) {
    const inline = op.inlineRequestBody!;
    const bodyOptional = !op.requestBodyRequired;
    const schemaArg = bodyOptional ? `${inline.zodSchema}.optional()` : inline.zodSchema;
    const requestArg = bodyOptional
      ? `(request ?? {}) as ${inline.tsType}`
      : `request as ${inline.tsType}`;
    return {
      schemaArg,
      paramList: 'request',
      apiCallArgs: requestArg,
    };
  }

  // Path param(s) + named request body (e.g., PUT /trackers/{id} or PUT /nutrition/carbs/{id}/foods/{foodEntryId})
  // Uses nested pattern: { id, request: RequestSchema } or { id, foodEntryId, request: RequestSchema }
  if (pathParams.length >= 1 && hasNamedBody) {
    const typeName = op.requestBodySchema!.replace(/Schema$/, '');
    const bodyOptional = !op.requestBodyRequired;
    const pathFields = pathParams.map(p => {
      const zodType = p.enumName ? `z.enum(${p.enumName})` : 'z.string()';
      return `${p.name}: ${zodType}`;
    });
    const requestField = bodyOptional
      ? `request: ${op.requestBodySchema}.optional()`
      : `request: ${op.requestBodySchema}`;
    const requestArg = bodyOptional
      ? `(request ?? {}) as ${typeName}`
      : `request as ${typeName}`;
    const paramNames = pathParams.map(p => p.name);
    return {
      schemaArg: `z.object({ ${pathFields.join(', ')}, ${requestField} })`,
      paramList: `{ ${paramNames.join(', ')}, request }`,
      apiCallArgs: `${paramNames.join(', ')}, ${requestArg}`,
    };
  }

  // Path param(s) + inline request body (e.g., PUT /config/{connectorName}/secrets with Dictionary<string, string>)
  if (pathParams.length >= 1 && hasInlineBody) {
    const inline = op.inlineRequestBody!;
    const bodyOptional = !op.requestBodyRequired;
    const pathFields = pathParams.map(p => {
      const zodType = p.enumName ? `z.enum(${p.enumName})` : 'z.string()';
      return `${p.name}: ${zodType}`;
    });
    const requestField = bodyOptional
      ? `request: ${inline.zodSchema}.optional()`
      : `request: ${inline.zodSchema}`;
    const requestArg = bodyOptional
      ? `(request ?? {}) as ${inline.tsType}`
      : `request as ${inline.tsType}`;
    const paramNames = pathParams.map(p => p.name);
    return {
      schemaArg: `z.object({ ${pathFields.join(', ')}, ${requestField} })`,
      paramList: `{ ${paramNames.join(', ')}, request }`,
      apiCallArgs: `${paramNames.join(', ')}, ${requestArg}`,
    };
  }

  // Query params only (e.g., GET /trackers?category=X)
  if (queryParams.length > 0 && !hasBody) {
    const fields = queryParams.map(p => {
      const zodType = p.enumName ? `z.enum(${p.enumName})` : getZodType(p.type);
      return `${p.name}: ${zodType}${p.required ? '' : '.optional()'}`;
    });

    const schemaArg = `z.object({ ${fields.join(', ')} }).optional()`;
    const paramList = 'params';
    const apiCallArgs = queryParams.map(p => `params?.${p.name}`).join(', ');

    return { schemaArg, paramList, apiCallArgs };
  }

  // No params
  return {
    schemaArg: '',
    paramList: '',
    apiCallArgs: '',
  };
}

function getZodType(type: string): string {
  switch (type) {
    case 'boolean': return 'z.boolean()';
    case 'number': return 'z.number()';
    case 'integer': return 'z.number().int()';
    case 'Date': return 'z.coerce.date()';
    default: return 'z.string()';
  }
}

/**
 * Get the method name from operationId.
 * NSwag generates method names by removing the tag prefix.
 * "Trackers_GetDefinitions" -> "getDefinitions"
 */
function getMethodName(operationId: string, tag: string): string {
  const parts = operationId.split('_');
  const name = parts.length > 1 ? parts.slice(1).join('_') : parts[0];
  return name.charAt(0).toLowerCase() + name.slice(1);
}

function generateIndexFile(byTag: Map<string, OperationInfo[]>): string {
  // Build map of function name -> list of tags that export it
  const nameToTags = new Map<string, string[]>();
  for (const [tag, operations] of byTag) {
    for (const op of operations) {
      const fnName = operationIdToFunctionName(op.operationId);
      const existing = nameToTags.get(fnName) ?? [];
      existing.push(tag);
      nameToTags.set(fnName, existing);
    }
  }

  // Find names that appear in multiple tags (collisions)
  const collidingNames = new Set<string>();
  for (const [name, tags] of nameToTags) {
    if (tags.length > 1) collidingNames.add(name);
  }

  // Find tags that have at least one colliding export
  const tagsWithCollisions = new Set<string>();
  for (const [name, tags] of nameToTags) {
    if (tags.length > 1) {
      for (const tag of tags) tagsWithCollisions.add(tag);
    }
  }

  const lines: string[] = [];
  for (const [tag, operations] of byTag) {
    const fileName = tagToFileName(tag);
    if (!tagsWithCollisions.has(tag)) {
      // No collisions - safe to export *
      lines.push(`export * from './${fileName}.generated.remote';`);
    } else {
      // Has collisions - use explicit named exports, skipping colliding names
      const safeNames = operations
        .map(op => operationIdToFunctionName(op.operationId))
        .filter(name => !collidingNames.has(name));
      if (safeNames.length > 0) {
        lines.push(`export { ${safeNames.join(', ')} } from './${fileName}.generated.remote';`);
      } else {
        lines.push(`// './${fileName}.generated.remote' - all exports collide, import directly`);
      }
    }
  }

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen

${lines.join('\n')}
`;
}
