// src/Web/packages/remote-function-codegen/src/generators/remote-functions.ts
import type { OperationInfo, ParsedSpec } from '../types.js';
import {
  operationIdToFunctionName,
  tagToFileName,
  resolveInvalidation,
} from '../utils/naming.js';
import { getClientPropertyName } from '../utils/client-mapping.js';

export function generateRemoteFunctions(parsed: ParsedSpec): Map<string, string> {
  const fileContents = new Map<string, string>();

  // Group operations by tag
  const byTag = new Map<string, OperationInfo[]>();
  for (const op of parsed.operations) {
    const existing = byTag.get(op.tag) ?? [];
    existing.push(op);
    byTag.set(op.tag, existing);
  }

  // Generate file for each tag
  for (const [tag, operations] of byTag) {
    const fileName = `${tagToFileName(tag)}.generated.remote.ts`;
    const content = generateTagFile(tag, operations);
    fileContents.set(fileName, content);
  }

  // Generate barrel export
  const indexContent = generateIndexFile(Array.from(byTag.keys()));
  fileContents.set('index.ts', indexContent);

  return fileContents;
}

function generateTagFile(tag: string, operations: OperationInfo[]): string {
  const schemaImports = new Set<string>();
  const typeImports = new Set<string>();
  const enumImports = new Set<string>();

  // Collect imports
  for (const op of operations) {
    if (op.requestBodySchema) {
      schemaImports.add(op.requestBodySchema);
      const typeName = op.requestBodySchema.replace(/Schema$/, '');
      typeImports.add(typeName);
    }
    for (const param of op.parameters) {
      if (param.enumName) {
        enumImports.add(param.enumName);
      }
    }
  }

  const schemaImportLine = schemaImports.size > 0
    ? `import { ${Array.from(schemaImports).join(', ')} } from '$lib/api/generated/schemas';\n`
    : '';

  // Build $api import line with both value imports (enums) and type imports (DTOs)
  let apiImportLine = '';
  const valueImports = Array.from(enumImports);
  const typeOnlyImports = Array.from(typeImports);
  if (valueImports.length > 0 || typeOnlyImports.length > 0) {
    const parts = [
      ...valueImports,
      ...typeOnlyImports.map(t => `type ${t}`),
    ];
    apiImportLine = `import { ${parts.join(', ')} } from '$api';\n`;
  }

  const functions = operations.map(op => generateFunction(op, tag, operations)).join('\n\n');

  // Only import query/command if actually used
  const hasQuery = operations.some(op => op.remoteType === 'query');
  const hasCommand = operations.some(op => op.remoteType === 'command');
  const serverImports = ['getRequestEvent', ...(hasQuery ? ['query'] : []), ...(hasCommand ? ['command'] : [])];

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { ${serverImports.join(', ')} } from '$app/server';
import { error } from '@sveltejs/kit';
import { z } from 'zod';
${schemaImportLine}${apiImportLine}
${functions}
`;
}

function generateFunction(op: OperationInfo, tag: string, allOpsInTag: OperationInfo[]): string {
  const functionName = operationIdToFunctionName(op.operationId);
  const clientProperty = op.clientPropertyName ?? getClientPropertyName(tag);
  const methodName = getMethodName(op.operationId, tag);

  if (op.remoteType === 'query') {
    return generateQueryFunction(op, functionName, clientProperty, methodName);
  } else {
    return generateCommandFunction(op, functionName, clientProperty, methodName, tag, allOpsInTag);
  }
}

function generateQueryFunction(
  op: OperationInfo,
  functionName: string,
  clientProperty: string,
  methodName: string
): string {
  const { schemaArg, paramList, apiCallArgs } = buildParameterMapping(op);
  const comment = op.summary ? `/** ${op.summary} */\n` : '';

  if (schemaArg) {
    return `${comment}export const ${functionName} = query(${schemaArg}, async (${paramList}) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.${clientProperty}.${methodName}(${apiCallArgs});
  } catch (err) {
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
  }

  return `${comment}export const ${functionName} = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.${clientProperty}.${methodName}();
  } catch (err) {
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
}

function generateCommandFunction(
  op: OperationInfo,
  functionName: string,
  clientProperty: string,
  methodName: string,
  tag: string,
  allOpsInTag: OperationInfo[]
): string {
  const { schemaArg, paramList, apiCallArgs, hasPathId } = buildParameterMapping(op);

  // Build invalidation calls
  const invalidations = op.invalidates.map(inv => {
    const resolved = resolveInvalidation(inv, tag);
    return resolved.functionName;
  });

  // Filter to only include functions that exist in the same file (same tag)
  const localFunctionNames = new Set(allOpsInTag.map(o => operationIdToFunctionName(o.operationId)));
  const localInvalidations = invalidations.filter(fn => localFunctionNames.has(fn));

  // Build refresh calls
  const refreshCallsArr = localInvalidations.map(fn => {
    // Check if the target function actually takes a path parameter
    const targetOp = allOpsInTag.find(o => operationIdToFunctionName(o.operationId) === fn);
    const targetHasPathParam = targetOp?.parameters.some(p => p.in === 'path') ?? false;
    if (targetHasPathParam && hasPathId) {
      return `${fn}(id).refresh()`;
    }
    return `${fn}(undefined).refresh()`;
  });

  const refreshCalls = refreshCallsArr.length > 0
    ? `\n    await Promise.all([
      ${refreshCallsArr.join(',\n      ')}
    ]);`
    : '';

  const comment = op.summary ? `/** ${op.summary} */\n` : '';

  // Handle void responses (204 No Content)
  const apiCall = op.isVoidResponse
    ? `    await apiClient.${clientProperty}.${methodName}(${apiCallArgs});${refreshCalls}
    return { success: true };`
    : `    const result = await apiClient.${clientProperty}.${methodName}(${apiCallArgs});${refreshCalls}
    return result;`;

  if (schemaArg) {
    return `${comment}export const ${functionName} = command(${schemaArg}, async (${paramList}) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
${apiCall}
  } catch (err) {
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
  }

  return `${comment}export const ${functionName} = command(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
${apiCall}
  } catch (err) {
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
}

function buildParameterMapping(op: OperationInfo): {
  schemaArg: string;
  paramList: string;
  apiCallArgs: string;
  hasPathId: boolean;
} {
  const pathParams = op.parameters.filter(p => p.in === 'path');
  const queryParams = op.parameters.filter(p => p.in === 'query');
  const hasPathId = pathParams.some(p => p.name === 'id');

  // Single path param only (e.g., GET /trackers/{id})
  if (pathParams.length === 1 && queryParams.length === 0 && !op.requestBodySchema) {
    const param = pathParams[0];
    const zodType = param.enumName ? `z.enum(${param.enumName})` : 'z.string()';
    return {
      schemaArg: zodType,
      paramList: param.name,
      apiCallArgs: param.name,
      hasPathId,
    };
  }

  // Request body only (e.g., POST /trackers or POST /treatments/bulk)
  if (pathParams.length === 0 && queryParams.length === 0 && op.requestBodySchema) {
    const typeName = op.requestBodySchema.replace(/Schema$/, '');
    const bodyOptional = !op.requestBodyRequired;
    if (op.isArrayBody) {
      return {
        schemaArg: `z.array(${op.requestBodySchema})`,
        paramList: 'request',
        apiCallArgs: `request as ${typeName}[]`,
        hasPathId,
      };
    }
    if (bodyOptional) {
      return {
        schemaArg: `${op.requestBodySchema}.optional()`,
        paramList: 'request',
        apiCallArgs: `(request ?? {}) as ${typeName}`,
        hasPathId,
      };
    }
    return {
      schemaArg: op.requestBodySchema,
      paramList: 'request',
      apiCallArgs: `request as ${typeName}`,
      hasPathId,
    };
  }

  // Path param + request body (e.g., PUT /trackers/{id})
  // Uses nested pattern: { id, request: RequestSchema }
  if (pathParams.length === 1 && op.requestBodySchema) {
    const param = pathParams[0];
    const typeName = op.requestBodySchema.replace(/Schema$/, '');
    const bodyOptional = !op.requestBodyRequired;
    const requestField = bodyOptional
      ? `request: ${op.requestBodySchema}.optional()`
      : `request: ${op.requestBodySchema}`;
    const requestArg = bodyOptional
      ? `(request ?? {}) as ${typeName}`
      : `request as ${typeName}`;
    return {
      schemaArg: `z.object({ ${param.name}: z.string(), ${requestField} })`,
      paramList: `{ ${param.name}, request }`,
      apiCallArgs: `${param.name}, ${requestArg}`,
      hasPathId,
    };
  }

  // Query params only (e.g., GET /trackers?category=X)
  if (queryParams.length > 0 && !op.requestBodySchema) {
    const fields = queryParams.map(p => {
      const zodType = p.enumName ? `z.enum(${p.enumName})` : getZodType(p.type);
      return `${p.name}: ${zodType}${p.required ? '' : '.optional()'}`;
    });

    const schemaArg = `z.object({ ${fields.join(', ')} }).optional()`;
    const paramList = 'params';
    const apiCallArgs = queryParams.map(p => `params?.${p.name}`).join(', ');

    return { schemaArg, paramList, apiCallArgs, hasPathId };
  }

  // No params
  return {
    schemaArg: '',
    paramList: '',
    apiCallArgs: '',
    hasPathId,
  };
}

function getZodType(type: string): string {
  switch (type) {
    case 'boolean': return 'z.boolean()';
    case 'number': return 'z.number()';
    case 'integer': return 'z.number().int()';
    case 'Date': return 'z.coerce.date()';
    default: return 'z.string()';
  }
}

/**
 * Get the method name from operationId.
 * NSwag generates method names by removing the tag prefix.
 * "Trackers_GetDefinitions" -> "getDefinitions"
 */
function getMethodName(operationId: string, tag: string): string {
  const parts = operationId.split('_');
  const name = parts.length > 1 ? parts.slice(1).join('_') : parts[0];
  return name.charAt(0).toLowerCase() + name.slice(1);
}

function generateIndexFile(tags: string[]): string {
  const exports = tags.map(tag => {
    const fileName = tagToFileName(tag);
    return `export * from './${fileName}.generated.remote';`;
  });

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen

${exports.join('\n')}
`;
}
