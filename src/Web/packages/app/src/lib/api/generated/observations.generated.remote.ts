// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error, redirect } from '@sveltejs/kit';
import { z } from 'zod';
import { BGCheckSchema, NoteSchema, DeviceEventSchema } from '$lib/api/generated/schemas';
import { type BGCheck, type Note, type DeviceEvent } from '$api';

/** Get blood glucose checks with optional filtering */
export const getBGChecks = query(z.object({ from: z.number().optional(), to: z.number().optional(), limit: z.number().optional(), offset: z.number().optional(), sort: z.string().optional(), device: z.string().optional(), source: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.observations.getBGChecks(params?.from, params?.to, params?.limit, params?.offset, params?.sort, params?.device, params?.source);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.getBGChecks:', err);
    throw error(500, 'Failed to get b g checks');
  }
});

/** Create a new blood glucose check */
export const createBGCheck = command(BGCheckSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.observations.createBGCheck(request as BGCheck);
    await Promise.all([
      getBGChecks(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.createBGCheck:', err);
    throw error(500, 'Failed to create b g check');
  }
});

/** Get a blood glucose check by ID */
export const getBGCheckById = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.observations.getBGCheckById(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.getBGCheckById:', err);
    throw error(500, 'Failed to get b g check by id');
  }
});

/** Update an existing blood glucose check */
export const updateBGCheck = command(z.object({ id: z.string(), request: BGCheckSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.observations.updateBGCheck(id, request as BGCheck);
    await Promise.all([
      getBGChecks(undefined).refresh(),
      getBGCheckById(id).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.updateBGCheck:', err);
    throw error(500, 'Failed to update b g check');
  }
});

/** Delete a blood glucose check */
export const deleteBGCheck = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.observations.deleteBGCheck(id);
    await Promise.all([
      getBGChecks(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.deleteBGCheck:', err);
    throw error(500, 'Failed to delete b g check');
  }
});

/** Get notes with optional filtering */
export const getNotes = query(z.object({ from: z.number().optional(), to: z.number().optional(), limit: z.number().optional(), offset: z.number().optional(), sort: z.string().optional(), device: z.string().optional(), source: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.observations.getNotes(params?.from, params?.to, params?.limit, params?.offset, params?.sort, params?.device, params?.source);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.getNotes:', err);
    throw error(500, 'Failed to get notes');
  }
});

/** Create a new note */
export const createNote = command(NoteSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.observations.createNote(request as Note);
    await Promise.all([
      getNotes(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.createNote:', err);
    throw error(500, 'Failed to create note');
  }
});

/** Get a note by ID */
export const getNoteById = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.observations.getNoteById(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.getNoteById:', err);
    throw error(500, 'Failed to get note by id');
  }
});

/** Update an existing note */
export const updateNote = command(z.object({ id: z.string(), request: NoteSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.observations.updateNote(id, request as Note);
    await Promise.all([
      getNotes(undefined).refresh(),
      getNoteById(id).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.updateNote:', err);
    throw error(500, 'Failed to update note');
  }
});

/** Delete a note */
export const deleteNote = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.observations.deleteNote(id);
    await Promise.all([
      getNotes(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.deleteNote:', err);
    throw error(500, 'Failed to delete note');
  }
});

/** Get device events with optional filtering */
export const getDeviceEvents = query(z.object({ from: z.number().optional(), to: z.number().optional(), limit: z.number().optional(), offset: z.number().optional(), sort: z.string().optional(), device: z.string().optional(), source: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.observations.getDeviceEvents(params?.from, params?.to, params?.limit, params?.offset, params?.sort, params?.device, params?.source);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.getDeviceEvents:', err);
    throw error(500, 'Failed to get device events');
  }
});

/** Create a new device event */
export const createDeviceEvent = command(DeviceEventSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.observations.createDeviceEvent(request as DeviceEvent);
    await Promise.all([
      getDeviceEvents(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.createDeviceEvent:', err);
    throw error(500, 'Failed to create device event');
  }
});

/** Get a device event by ID */
export const getDeviceEventById = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.observations.getDeviceEventById(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.getDeviceEventById:', err);
    throw error(500, 'Failed to get device event by id');
  }
});

/** Update an existing device event */
export const updateDeviceEvent = command(z.object({ id: z.string(), request: DeviceEventSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.observations.updateDeviceEvent(id, request as DeviceEvent);
    await Promise.all([
      getDeviceEvents(undefined).refresh(),
      getDeviceEventById(id).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.updateDeviceEvent:', err);
    throw error(500, 'Failed to update device event');
  }
});

/** Delete a device event */
export const deleteDeviceEvent = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.observations.deleteDeviceEvent(id);
    await Promise.all([
      getDeviceEvents(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in observations.deleteDeviceEvent:', err);
    throw error(500, 'Failed to delete device event');
  }
});
