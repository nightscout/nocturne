// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error } from '@sveltejs/kit';
import { z } from 'zod';
import { SyncRequestSchema } from '$lib/api/generated/schemas';
import { type SyncRequest } from '$api';

/** Get a complete overview of services, data sources, and available integrations. */
export const getServicesOverview = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getServicesOverview();
  } catch (err) {
    console.error('Error in services.getServicesOverview:', err);
    throw error(500, 'Failed to get services overview');
  }
});

/** Get all active data sources that have been sending data to this Nocturne instance.
This includes CGM apps, AID systems, and any other uploaders. */
export const getActiveDataSources = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getActiveDataSources();
  } catch (err) {
    console.error('Error in services.getActiveDataSources:', err);
    throw error(500, 'Failed to get active data sources');
  }
});

/** Get detailed information about a specific data source. */
export const getDataSource = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getDataSource(id);
  } catch (err) {
    console.error('Error in services.getDataSource:', err);
    throw error(500, 'Failed to get data source');
  }
});

/** Delete all data from a specific data source.
WARNING: This is a destructive operation that cannot be undone. */
export const deleteDataSourceData = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.services.deleteDataSourceData(id);
    await Promise.all([
      getServicesOverview(undefined).refresh(),
      getActiveDataSources(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    console.error('Error in services.deleteDataSourceData:', err);
    throw error(500, 'Failed to delete data source data');
  }
});

/** Get available connectors that can be configured to pull data into Nocturne. */
export const getAvailableConnectors = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getAvailableConnectors();
  } catch (err) {
    console.error('Error in services.getAvailableConnectors:', err);
    throw error(500, 'Failed to get available connectors');
  }
});

/** Get capabilities for a specific connector. */
export const getConnectorCapabilities = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getConnectorCapabilities(id);
  } catch (err) {
    console.error('Error in services.getConnectorCapabilities:', err);
    throw error(500, 'Failed to get connector capabilities');
  }
});

/** Get uploader apps that can push data to Nocturne with setup instructions. */
export const getUploaderApps = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getUploaderApps();
  } catch (err) {
    console.error('Error in services.getUploaderApps:', err);
    throw error(500, 'Failed to get uploader apps');
  }
});

/** Get API endpoint information for configuring external apps.
This provides all the information needed to configure xDrip+, Loop, AAPS, etc. */
export const getApiInfo = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getApiInfo();
  } catch (err) {
    console.error('Error in services.getApiInfo:', err);
    throw error(500, 'Failed to get api info');
  }
});

/** Get setup instructions for a specific uploader app. */
export const getUploaderSetup = query(z.string(), async (appId) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getUploaderSetup(appId);
  } catch (err) {
    console.error('Error in services.getUploaderSetup:', err);
    throw error(500, 'Failed to get uploader setup');
  }
});

/** Delete all demo data. This operation is safe as demo data can be easily regenerated. */
export const deleteDemoData = command(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.services.deleteDemoData();
    await Promise.all([
      getServicesOverview(undefined).refresh(),
      getActiveDataSources(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    console.error('Error in services.deleteDemoData:', err);
    throw error(500, 'Failed to delete demo data');
  }
});

/** Get a summary of data counts for a specific connector.
Returns the number of entries, treatments, and device statuses synced by this connector. */
export const getConnectorDataSummary = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getConnectorDataSummary(id);
  } catch (err) {
    console.error('Error in services.getConnectorDataSummary:', err);
    throw error(500, 'Failed to get connector data summary');
  }
});

/** Delete all data from a specific connector.
WARNING: This is a destructive operation that cannot be undone. */
export const deleteConnectorData = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.services.deleteConnectorData(id);
    await Promise.all([
      getServicesOverview(undefined).refresh(),
      getActiveDataSources(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    console.error('Error in services.deleteConnectorData:', err);
    throw error(500, 'Failed to delete connector data');
  }
});

/** Trigger a manual sync for a specific connector. */
export const triggerConnectorSync = command(z.object({ id: z.string(), request: SyncRequestSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.services.triggerConnectorSync(id, request as SyncRequest);
    return result;
  } catch (err) {
    console.error('Error in services.triggerConnectorSync:', err);
    throw error(500, 'Failed to trigger connector sync');
  }
});

/** Get sync status for a specific connector, including latest timestamps and connector state.
Used by connectors on startup to determine where to resume syncing from. */
export const getConnectorSyncStatus = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.services.getConnectorSyncStatus(id);
  } catch (err) {
    console.error('Error in services.getConnectorSyncStatus:', err);
    throw error(500, 'Failed to get connector sync status');
  }
});
