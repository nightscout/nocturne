//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AnalyticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current analytics configuration and status
     * @return Analytics configuration and collection status
     */
    getAnalyticsStatus(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnalyticsStatus(_response);
        });
    }

    protected processGetAnalyticsStatus(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get current performance metrics
     * @return System performance metrics
     */
    getPerformanceMetrics(signal?: AbortSignal): Promise<PerformanceMetrics> {
        let url_ = this.baseUrl + "/api/Analytics/metrics/performance";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPerformanceMetrics(_response);
        });
    }

    protected processGetPerformanceMetrics(response: Response): Promise<PerformanceMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PerformanceMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PerformanceMetrics>(null as any);
    }

    /**
     * Get current usage statistics
     * @return Usage statistics
     */
    getUsageStatistics(signal?: AbortSignal): Promise<UsageStatistics> {
        let url_ = this.baseUrl + "/api/Analytics/metrics/usage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsageStatistics(_response);
        });
    }

    protected processGetUsageStatistics(response: Response): Promise<UsageStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsageStatistics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsageStatistics>(null as any);
    }

    /**
     * Get pending analytics data that would be transmitted (for transparency)
     * @return Pending analytics data or null if none
     */
    getPendingAnalyticsData(signal?: AbortSignal): Promise<AnalyticsBatch> {
        let url_ = this.baseUrl + "/api/Analytics/data/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPendingAnalyticsData(_response);
        });
    }

    protected processGetPendingAnalyticsData(response: Response): Promise<AnalyticsBatch> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticsBatch;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticsBatch>(null as any);
    }

    /**
     * Update analytics collection configuration
     * @param config New analytics configuration
     * @return Updated configuration
     */
    updateAnalyticsConfig(config: AnalyticsCollectionConfig, signal?: AbortSignal): Promise<AnalyticsCollectionConfig> {
        let url_ = this.baseUrl + "/api/Analytics/config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAnalyticsConfig(_response);
        });
    }

    protected processUpdateAnalyticsConfig(response: Response): Promise<AnalyticsCollectionConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticsCollectionConfig;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticsCollectionConfig>(null as any);
    }

    /**
     * Clear all stored analytics data
     * @return Confirmation message
     */
    clearAnalyticsData(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearAnalyticsData(_response);
        });
    }

    protected processClearAnalyticsData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get information about what data is collected and privacy policy
     * @return Privacy and data collection information
     */
    getPrivacyInformation(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/privacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPrivacyInformation(_response);
        });
    }

    protected processGetPrivacyInformation(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Track a custom analytics event (for testing or manual tracking)
     * @param eventData Custom event data
     * @return Confirmation message
     */
    trackCustomEvent(eventData: AnalyticsEvent, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrackCustomEvent(_response);
        });
    }

    protected processTrackCustomEvent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Verify authentication status and permissions for the current request
    This endpoint provides 1:1 compatibility with Nightscout's /api/v1/verifyauth endpoint
     * @return Authentication status and permission information
     */
    verifyAuthentication(signal?: AbortSignal): Promise<VerifyAuthResponse> {
        let url_ = this.baseUrl + "/api/v1/verifyauth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerifyAuthentication(_response);
        });
    }

    protected processVerifyAuthentication(response: Response): Promise<VerifyAuthResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VerifyAuthResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerifyAuthResponse>(null as any);
    }
}

export class AuthorizationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Generate JWT token from access token
     * @param accessToken Access token to exchange for JWT
     * @return JWT token response
     */
    generateJwtFromAccessToken(accessToken: string, signal?: AbortSignal): Promise<AuthorizationResponse> {
        let url_ = this.baseUrl + "/api/v2/authorization/request/{accessToken}";
        if (accessToken === undefined || accessToken === null)
            throw new Error("The parameter 'accessToken' must be defined.");
        url_ = url_.replace("{accessToken}", encodeURIComponent("" + accessToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateJwtFromAccessToken(_response);
        });
    }

    protected processGenerateJwtFromAccessToken(response: Response): Promise<AuthorizationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorizationResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorizationResponse>(null as any);
    }

    /**
     * Get all permissions that have been seen by the system
     * @return List of permissions with usage statistics
     */
    getAllPermissions(signal?: AbortSignal): Promise<PermissionsResponse> {
        let url_ = this.baseUrl + "/api/v2/authorization/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: Response): Promise<PermissionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionsResponse>(null as any);
    }

    /**
     * Get permission hierarchy structure as a trie
     * @return Permission trie structure
     */
    getPermissionTrie(signal?: AbortSignal): Promise<PermissionTrieResponse> {
        let url_ = this.baseUrl + "/api/v2/authorization/permissions/trie";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissionTrie(_response);
        });
    }

    protected processGetPermissionTrie(response: Response): Promise<PermissionTrieResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionTrieResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionTrieResponse>(null as any);
    }

    /**
     * Get all subjects (users/devices)
     * @return List of all subjects
     */
    getAllSubjects(signal?: AbortSignal): Promise<Subject[]> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSubjects(_response);
        });
    }

    protected processGetAllSubjects(response: Response): Promise<Subject[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subject[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subject[]>(null as any);
    }

    /**
     * Create a new subject
     * @param subject Subject to create
     * @return Created subject
     */
    createSubject(subject: Subject, signal?: AbortSignal): Promise<Subject> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subject);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSubject(_response);
        });
    }

    protected processCreateSubject(response: Response): Promise<Subject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subject;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subject>(null as any);
    }

    /**
     * Update an existing subject
     * @param subject Subject to update
     * @return Updated subject
     */
    updateSubject(subject: Subject, signal?: AbortSignal): Promise<Subject> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subject);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSubject(_response);
        });
    }

    protected processUpdateSubject(response: Response): Promise<Subject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subject>(null as any);
    }

    /**
     * Delete a subject by ID
     * @param id Subject ID to delete
     * @return Success response
     */
    deleteSubject(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSubject(_response);
        });
    }

    protected processDeleteSubject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all roles
     * @return List of all roles
     */
    getAllRoles(signal?: AbortSignal): Promise<Role[]> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[]>(null as any);
    }

    /**
     * Create a new role
     * @param role Role to create
     * @return Created role
     */
    createRole(role: Role, signal?: AbortSignal): Promise<Role> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * Update an existing role
     * @param role Role to update
     * @return Updated role
     */
    updateRole(role: Role, signal?: AbortSignal): Promise<Role> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * Delete a role by ID
     * @param id Role ID to delete
     * @return Success response
     */
    deleteRole(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MetadataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get WebSocket event types metadata
    This endpoint exists primarily to ensure NSwag generates TypeScript types for WebSocket events
     * @return WebSocket events metadata
     */
    getWebSocketEvents(signal?: AbortSignal): Promise<WebSocketEventsMetadata> {
        let url_ = this.baseUrl + "/api/Metadata/websocket-events";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWebSocketEvents(_response);
        });
    }

    protected processGetWebSocketEvents(response: Response): Promise<WebSocketEventsMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WebSocketEventsMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebSocketEventsMetadata>(null as any);
    }
}

export class StatisticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Calculate basic glucose statistics from provided glucose values
     * @param values Array of glucose values in mg/dL
     * @return Basic glucose statistics including mean, median, percentiles, etc.
     */
    calculateBasicStats(values: number[], signal?: AbortSignal): Promise<BasicGlucoseStats> {
        let url_ = this.baseUrl + "/api/v1/Statistics/basic-stats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(values);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateBasicStats(_response);
        });
    }

    protected processCalculateBasicStats(response: Response): Promise<BasicGlucoseStats> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasicGlucoseStats;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BasicGlucoseStats>(null as any);
    }

    /**
     * Calculate comprehensive glycemic variability metrics
     * @param request Request containing glucose values and entries
     * @return Comprehensive glycemic variability metrics
     */
    calculateGlycemicVariability(request: GlycemicVariabilityRequest, signal?: AbortSignal): Promise<GlycemicVariability> {
        let url_ = this.baseUrl + "/api/v1/Statistics/glycemic-variability";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGlycemicVariability(_response);
        });
    }

    protected processCalculateGlycemicVariability(response: Response): Promise<GlycemicVariability> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlycemicVariability;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlycemicVariability>(null as any);
    }

    /**
     * Calculate time in range metrics
     * @param request Request containing entries and optional thresholds
     * @return Time in range metrics including percentages, durations, and episodes
     */
    calculateTimeInRange(request: TimeInRangeRequest, signal?: AbortSignal): Promise<TimeInRangeMetrics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/time-in-range";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateTimeInRange(_response);
        });
    }

    protected processCalculateTimeInRange(response: Response): Promise<TimeInRangeMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeInRangeMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeInRangeMetrics>(null as any);
    }

    /**
     * Calculate glucose distribution across configurable bins
     * @param request Request containing entries and optional bins
     * @return Collection of distribution data points
     */
    calculateGlucoseDistribution(request: GlucoseDistributionRequest, signal?: AbortSignal): Promise<DistributionDataPoint[]> {
        let url_ = this.baseUrl + "/api/v1/Statistics/glucose-distribution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGlucoseDistribution(_response);
        });
    }

    protected processCalculateGlucoseDistribution(response: Response): Promise<DistributionDataPoint[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DistributionDataPoint[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DistributionDataPoint[]>(null as any);
    }

    /**
     * Calculate averaged statistics for each hour of the day (0-23)
     * @param entries Array of glucose entries
     * @return Collection of averaged statistics for each hour
     */
    calculateAveragedStats(entries: Entry[], signal?: AbortSignal): Promise<AveragedStats[]> {
        let url_ = this.baseUrl + "/api/v1/Statistics/averaged-stats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateAveragedStats(_response);
        });
    }

    protected processCalculateAveragedStats(response: Response): Promise<AveragedStats[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AveragedStats[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AveragedStats[]>(null as any);
    }

    /**
     * Calculate treatment summary for a collection of treatments
     * @param treatments Array of treatments
     * @return Treatment summary with totals and counts
     */
    calculateTreatmentSummary(treatments: Treatment[], signal?: AbortSignal): Promise<TreatmentSummary> {
        let url_ = this.baseUrl + "/api/v1/Statistics/treatment-summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateTreatmentSummary(_response);
        });
    }

    protected processCalculateTreatmentSummary(response: Response): Promise<TreatmentSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentSummary>(null as any);
    }

    /**
     * Calculate overall averages across multiple days
     * @param dailyDataPoints Array of daily data points
     * @return Overall averages or null if no data
     */
    calculateOverallAverages(dailyDataPoints: DayData[], signal?: AbortSignal): Promise<OverallAverages> {
        let url_ = this.baseUrl + "/api/v1/Statistics/overall-averages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dailyDataPoints);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateOverallAverages(_response);
        });
    }

    protected processCalculateOverallAverages(response: Response): Promise<OverallAverages> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OverallAverages;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OverallAverages>(null as any);
    }

    /**
     * Master glucose analytics function that calculates comprehensive metrics
     * @param request Request containing entries, treatments, and configuration
     * @return Comprehensive glucose analytics
     */
    analyzeGlucoseData(request: GlucoseAnalyticsRequest, signal?: AbortSignal): Promise<GlucoseAnalytics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/comprehensive-analytics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnalyzeGlucoseData(_response);
        });
    }

    protected processAnalyzeGlucoseData(response: Response): Promise<GlucoseAnalytics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlucoseAnalytics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlucoseAnalytics>(null as any);
    }

    /**
     * Extended glucose analytics including GMI, GRI, and clinical target assessment
     * @param request Request containing entries, treatments, population type, and configuration
     * @return Extended glucose analytics with modern clinical metrics
     */
    analyzeGlucoseDataExtended(request: ExtendedGlucoseAnalyticsRequest, signal?: AbortSignal): Promise<ExtendedGlucoseAnalytics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/extended-analytics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnalyzeGlucoseDataExtended(_response);
        });
    }

    protected processAnalyzeGlucoseDataExtended(response: Response): Promise<ExtendedGlucoseAnalytics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExtendedGlucoseAnalytics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtendedGlucoseAnalytics>(null as any);
    }

    /**
     * Calculate Glucose Management Indicator (GMI)
     * @param meanGlucose Mean glucose in mg/dL
     * @return GMI with value and interpretation
     */
    calculateGMI(meanGlucose: number, signal?: AbortSignal): Promise<GlucoseManagementIndicator> {
        let url_ = this.baseUrl + "/api/v1/Statistics/gmi/{meanGlucose}";
        if (meanGlucose === undefined || meanGlucose === null)
            throw new Error("The parameter 'meanGlucose' must be defined.");
        url_ = url_.replace("{meanGlucose}", encodeURIComponent("" + meanGlucose));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGMI(_response);
        });
    }

    protected processCalculateGMI(response: Response): Promise<GlucoseManagementIndicator> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlucoseManagementIndicator;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlucoseManagementIndicator>(null as any);
    }

    /**
     * Calculate Glycemic Risk Index (GRI) from time in range metrics
     * @param timeInRange Time in range metrics
     * @return GRI with score, zone, and interpretation
     */
    calculateGRI(timeInRange: TimeInRangeMetrics, signal?: AbortSignal): Promise<GlycemicRiskIndex> {
        let url_ = this.baseUrl + "/api/v1/Statistics/gri";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(timeInRange);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGRI(_response);
        });
    }

    protected processCalculateGRI(response: Response): Promise<GlycemicRiskIndex> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlycemicRiskIndex;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlycemicRiskIndex>(null as any);
    }

    /**
     * Assess glucose data against clinical targets for a specific population
     * @param request Request containing analytics and population type
     * @return Clinical target assessment with actionable insights
     */
    assessAgainstTargets(request: ClinicalAssessmentRequest, signal?: AbortSignal): Promise<ClinicalTargetAssessment> {
        let url_ = this.baseUrl + "/api/v1/Statistics/clinical-assessment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssessAgainstTargets(_response);
        });
    }

    protected processAssessAgainstTargets(response: Response): Promise<ClinicalTargetAssessment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClinicalTargetAssessment;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClinicalTargetAssessment>(null as any);
    }

    /**
     * Assess data sufficiency for a valid clinical report
     * @param request Request containing entries and optional period settings
     * @return Data sufficiency assessment
     */
    assessDataSufficiency(request: DataSufficiencyRequest, signal?: AbortSignal): Promise<DataSufficiencyAssessment> {
        let url_ = this.baseUrl + "/api/v1/Statistics/data-sufficiency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssessDataSufficiency(_response);
        });
    }

    protected processAssessDataSufficiency(response: Response): Promise<DataSufficiencyAssessment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSufficiencyAssessment;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSufficiencyAssessment>(null as any);
    }

    /**
     * Get clinical targets for a specific diabetes population
     * @param population Population type (Type1Adult, Type2Adult, Elderly, Pregnancy, etc.)
     * @return Clinical targets for the specified population
     */
    getClinicalTargets(population: DiabetesPopulation, signal?: AbortSignal): Promise<ClinicalTargets> {
        let url_ = this.baseUrl + "/api/v1/Statistics/clinical-targets/{population}";
        if (population === undefined || population === null)
            throw new Error("The parameter 'population' must be defined.");
        url_ = url_.replace("{population}", encodeURIComponent("" + population));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClinicalTargets(_response);
        });
    }

    protected processGetClinicalTargets(response: Response): Promise<ClinicalTargets> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClinicalTargets;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClinicalTargets>(null as any);
    }

    /**
     * Calculate estimated A1C from average glucose
     * @param averageGlucose Average glucose in mg/dL
     * @return Estimated A1C percentage
     */
    calculateEstimatedA1C(averageGlucose: number, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/Statistics/estimated-a1c/{averageGlucose}";
        if (averageGlucose === undefined || averageGlucose === null)
            throw new Error("The parameter 'averageGlucose' must be defined.");
        url_ = url_.replace("{averageGlucose}", encodeURIComponent("" + averageGlucose));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateEstimatedA1C(_response);
        });
    }

    protected processCalculateEstimatedA1C(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Convert mg/dL to mmol/L
     * @param mgdl Glucose value in mg/dL
     * @return Glucose value in mmol/L
     */
    mgdlToMMOL(mgdl: number, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/Statistics/convert/mgdl-to-mmol/{mgdl}";
        if (mgdl === undefined || mgdl === null)
            throw new Error("The parameter 'mgdl' must be defined.");
        url_ = url_.replace("{mgdl}", encodeURIComponent("" + mgdl));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMgdlToMMOL(_response);
        });
    }

    protected processMgdlToMMOL(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Convert mmol/L to mg/dL
     * @param mmol Glucose value in mmol/L
     * @return Glucose value in mg/dL
     */
    mmolToMGDL(mmol: number, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/Statistics/convert/mmol-to-mgdl/{mmol}";
        if (mmol === undefined || mmol === null)
            throw new Error("The parameter 'mmol' must be defined.");
        url_ = url_.replace("{mmol}", encodeURIComponent("" + mmol));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMmolToMGDL(_response);
        });
    }

    protected processMmolToMGDL(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Format insulin value for display
     * @param value Insulin value
     * @return Formatted insulin string
     */
    formatInsulinDisplay(value: number, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/Statistics/format/insulin/{value}";
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{value}", encodeURIComponent("" + value));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormatInsulinDisplay(_response);
        });
    }

    protected processFormatInsulinDisplay(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Format carb value for display
     * @param value Carb value
     * @return Formatted carb string
     */
    formatCarbDisplay(value: number, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/Statistics/format/carb/{value}";
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{value}", encodeURIComponent("" + value));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormatCarbDisplay(_response);
        });
    }

    protected processFormatCarbDisplay(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Validate treatment data for completeness and consistency
     * @param treatment Treatment to validate
     * @return True if treatment data is valid
     */
    validateTreatmentData(treatment: Treatment, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/Statistics/validate/treatment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateTreatmentData(_response);
        });
    }

    protected processValidateTreatmentData(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Clean and filter treatment data
     * @param treatments Array of treatments to clean
     * @return Cleaned collection of treatments
     */
    cleanTreatmentData(treatments: Treatment[], signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v1/Statistics/clean/treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCleanTreatmentData(_response);
        });
    }

    protected processCleanTreatmentData(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Get comprehensive statistics for multiple time periods (1, 3, 7, 30, 90 days)
    Uses in-memory cache for performance with daily expiration
     * @return Multi-period statistics with comprehensive analytics for each time period
     */
    getMultiPeriodStatistics(signal?: AbortSignal): Promise<MultiPeriodStatistics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/periods";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMultiPeriodStatistics(_response);
        });
    }

    protected processGetMultiPeriodStatistics(response: Response): Promise<MultiPeriodStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MultiPeriodStatistics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MultiPeriodStatistics>(null as any);
    }
}

export class VersionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the list of supported API versions
     * @return List of supported API versions
     */
    getVersions(signal?: AbortSignal): Promise<VersionsResponse> {
        let url_ = this.baseUrl + "/api/Versions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersions(_response);
        });
    }

    protected processGetVersions(response: Response): Promise<VersionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionsResponse>(null as any);
    }
}

export class CompatibilityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get current proxy configuration
     */
    getConfiguration(signal?: AbortSignal): Promise<ProxyConfigurationDto> {
        let url_ = this.baseUrl + "/api/v4/compatibility/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: Response): Promise<ProxyConfigurationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProxyConfigurationDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProxyConfigurationDto>(null as any);
    }

    /**
     * Get overall compatibility metrics
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<CompatibilityMetrics> {
        let url_ = this.baseUrl + "/api/v4/compatibility/metrics?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMetrics(_response);
        });
    }

    protected processGetMetrics(response: Response): Promise<CompatibilityMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompatibilityMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompatibilityMetrics>(null as any);
    }

    /**
     * Get per-endpoint compatibility metrics
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getEndpointMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<EndpointMetrics[]> {
        let url_ = this.baseUrl + "/api/v4/compatibility/endpoints?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEndpointMetrics(_response);
        });
    }

    protected processGetEndpointMetrics(response: Response): Promise<EndpointMetrics[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EndpointMetrics[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointMetrics[]>(null as any);
    }

    /**
     * Get list of analyses with filtering and pagination
     * @param requestPath (optional) 
     * @param overallMatch (optional) 
     * @param requestMethod (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param count (optional) 
     * @param skip (optional) 
     */
    getAnalyses(requestPath?: string | null | undefined, overallMatch?: ResponseMatchType | null | undefined, requestMethod?: string | null | undefined, fromDate?: Date | null | undefined, toDate?: Date | null | undefined, count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<AnalysesListResponse> {
        let url_ = this.baseUrl + "/api/v4/compatibility/analyses?";
        if (requestPath !== undefined && requestPath !== null)
            url_ += "requestPath=" + encodeURIComponent("" + requestPath) + "&";
        if (overallMatch !== undefined && overallMatch !== null)
            url_ += "overallMatch=" + encodeURIComponent("" + overallMatch) + "&";
        if (requestMethod !== undefined && requestMethod !== null)
            url_ += "requestMethod=" + encodeURIComponent("" + requestMethod) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnalyses(_response);
        });
    }

    protected processGetAnalyses(response: Response): Promise<AnalysesListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalysesListResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalysesListResponse>(null as any);
    }

    /**
     * Get detailed analysis by ID
     */
    getAnalysisDetail(id: string, signal?: AbortSignal): Promise<AnalysisDetailDto> {
        let url_ = this.baseUrl + "/api/v4/compatibility/analyses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnalysisDetail(_response);
        });
    }

    protected processGetAnalysisDetail(response: Response): Promise<AnalysisDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalysisDetailDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalysisDetailDto>(null as any);
    }

    /**
     * Get migration readiness assessment
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getMigrationAssessment(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<MigrationReadinessReport> {
        let url_ = this.baseUrl + "/api/v4/compatibility/migration-assessment?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMigrationAssessment(_response);
        });
    }

    protected processGetMigrationAssessment(response: Response): Promise<MigrationReadinessReport> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MigrationReadinessReport;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MigrationReadinessReport>(null as any);
    }

    /**
     * Get text report
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getTextReport(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v4/compatibility/report?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTextReport(_response);
        });
    }

    protected processGetTextReport(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class DeviceStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get device status records with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 device status collection response
     */
    getDeviceStatus(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatus(_response);
        });
    }

    protected processGetDeviceStatus(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new device status records with V3 format and deduplication support
     * @param deviceStatusData Device status data to create (single object or array)
     * @return Created device status records
     */
    createDeviceStatus(deviceStatusData: any, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceStatusData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDeviceStatus(_response);
        });
    }

    protected processCreateDeviceStatus(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }

    /**
     * Get a specific device status record by ID with V3 format
     * @param id Device status ID
     * @return Single device status record in V3 format
     */
    getDeviceStatusById(id: string, signal?: AbortSignal): Promise<DeviceStatus> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatusById(_response);
        });
    }

    protected processGetDeviceStatusById(response: Response): Promise<DeviceStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus>(null as any);
    }

    /**
     * Update a device status record by ID with V3 format
     * @param id Device status ID to update
     * @param deviceStatus Updated device status data
     * @return Updated device status record
     */
    updateDeviceStatus(id: string, deviceStatus: DeviceStatus, signal?: AbortSignal): Promise<DeviceStatus> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceStatus);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceStatus(_response);
        });
    }

    protected processUpdateDeviceStatus(response: Response): Promise<DeviceStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus>(null as any);
    }

    /**
     * Delete a device status record by ID
     * @param id Device status ID to delete
     * @return No content on success
     */
    deleteDeviceStatus(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDeviceStatus(_response);
        });
    }

    protected processDeleteDeviceStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get device status entries with optional filtering and pagination
     * @param count (optional) Maximum number of device status entries to return (default: 10)
     * @param skip (optional) Number of device status entries to skip for pagination (default: 0)
     * @param format (optional) Output format: json (default), csv, tsv, or txt
     * @return Array of device status entries ordered by most recent first
     */
    getDeviceStatus2(count?: number | undefined, skip?: number | undefined, format?: string | undefined, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatus2(_response);
        });
    }

    protected processGetDeviceStatus2(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }

    /**
     * Create new device status entries
     * @param deviceStatusEntries Device status entries to create
     * @return Created device status entries with assigned IDs
     */
    createDeviceStatus2(deviceStatusEntries: DeviceStatus[], signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceStatusEntries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDeviceStatus2(_response);
        });
    }

    protected processCreateDeviceStatus2(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }

    /**
     * Bulk delete device status entries using query filters
     * @return Number of deleted entries
     */
    bulkDeleteDeviceStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteDeviceStatus(_response);
        });
    }

    protected processBulkDeleteDeviceStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Delete a device status entry by ID
     * @param id Device status ID to delete
     * @return Success status
     */
    deleteDeviceStatus2(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDeviceStatus2(_response);
        });
    }

    protected processDeleteDeviceStatus2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Alternative endpoint for device status - supports .json extension
     * @param count (optional) Maximum number of device status entries to return (default: 10)
     * @param skip (optional) Number of device status entries to skip for pagination (default: 0)
     * @return Array of device status entries ordered by most recent first
     */
    getDeviceStatusJson(count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v1/devicestatus.json?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatusJson(_response);
        });
    }

    protected processGetDeviceStatusJson(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }
}

export class DiscrepancyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get overall compatibility metrics for dashboard overview
     * @param fromDate (optional) Start date for metrics (optional)
     * @param toDate (optional) End date for metrics (optional)
     * @return Compatibility metrics including success rate and response times
     */
    getCompatibilityMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<CompatibilityMetrics> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/metrics?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompatibilityMetrics(_response);
        });
    }

    protected processGetCompatibilityMetrics(response: Response): Promise<CompatibilityMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompatibilityMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompatibilityMetrics>(null as any);
    }

    /**
     * Get per-endpoint compatibility metrics
     * @param fromDate (optional) Start date for metrics (optional)
     * @param toDate (optional) End date for metrics (optional)
     * @return List of endpoint-specific compatibility metrics
     */
    getEndpointMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<EndpointMetrics[]> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/endpoints?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEndpointMetrics(_response);
        });
    }

    protected processGetEndpointMetrics(response: Response): Promise<EndpointMetrics[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EndpointMetrics[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointMetrics[]>(null as any);
    }

    /**
     * Get detailed discrepancy analyses with filtering and pagination
     * @param requestPath (optional) Filter by request path (optional)
     * @param overallMatch (optional) Filter by overall match type (optional)
     * @param fromDate (optional) Start date for filter (optional)
     * @param toDate (optional) End date for filter (optional)
     * @param count (optional) Number of results to return (default: 100, max: 1000)
     * @param skip (optional) Number of results to skip for pagination (default: 0)
     * @return List of detailed discrepancy analyses
     */
    getDiscrepancyAnalyses(requestPath?: string | null | undefined, overallMatch?: number | null | undefined, fromDate?: Date | null | undefined, toDate?: Date | null | undefined, count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<DiscrepancyAnalysisDto[]> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/analyses?";
        if (requestPath !== undefined && requestPath !== null)
            url_ += "requestPath=" + encodeURIComponent("" + requestPath) + "&";
        if (overallMatch !== undefined && overallMatch !== null)
            url_ += "overallMatch=" + encodeURIComponent("" + overallMatch) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDiscrepancyAnalyses(_response);
        });
    }

    protected processGetDiscrepancyAnalyses(response: Response): Promise<DiscrepancyAnalysisDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DiscrepancyAnalysisDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiscrepancyAnalysisDto[]>(null as any);
    }

    /**
     * Get a specific discrepancy analysis by ID
     * @param id Analysis ID
     * @return Detailed discrepancy analysis
     */
    getDiscrepancyAnalysis(id: string, signal?: AbortSignal): Promise<DiscrepancyAnalysisDto> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/analyses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDiscrepancyAnalysis(_response);
        });
    }

    protected processGetDiscrepancyAnalysis(response: Response): Promise<DiscrepancyAnalysisDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DiscrepancyAnalysisDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiscrepancyAnalysisDto>(null as any);
    }

    /**
     * Get real-time compatibility status summary
     * @return Current compatibility status
     */
    getCompatibilityStatus(signal?: AbortSignal): Promise<CompatibilityStatus> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompatibilityStatus(_response);
        });
    }

    protected processGetCompatibilityStatus(response: Response): Promise<CompatibilityStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompatibilityStatus;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompatibilityStatus>(null as any);
    }

    /**
     * Generate a text-based compatibility report
     * @param fromDate (optional) Start date for report (optional)
     * @param toDate (optional) End date for report (optional)
     * @return Text-based compatibility report
     */
    getTextReport(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/reports/text?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTextReport(_response);
        });
    }

    protected processGetTextReport(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Generate a migration readiness assessment
     * @param fromDate (optional) Start date for assessment (optional)
     * @param toDate (optional) End date for assessment (optional)
     * @return Migration readiness assessment
     */
    getMigrationAssessment(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<MigrationReadinessReport> {
        let url_ = this.baseUrl + "/api/v3/Discrepancy/reports/migration-assessment?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMigrationAssessment(_response);
        });
    }

    protected processGetMigrationAssessment(response: Response): Promise<MigrationReadinessReport> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MigrationReadinessReport;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MigrationReadinessReport>(null as any);
    }
}

export class EntriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get entries with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 entries collection response
     */
    getEntries(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Entries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntries(_response);
        });
    }

    protected processGetEntries(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create a new entry via V3 API
     * @param entry Entry to create
     * @return Created entry
     */
    createEntry(entry: Entry, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v3/Entries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entry);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntry(_response);
        });
    }

    protected processCreateEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Get a specific entry by ID with V3 format
     * @param id Entry ID
     * @return Single entry in V3 format
     */
    getEntry(id: string, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v3/Entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry(_response);
        });
    }

    protected processGetEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Update an entry via V3 API
     * @param id Entry ID
     * @param entry Updated entry data
     * @return Updated entry
     */
    updateEntry(id: string, entry: Entry, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v3/Entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entry);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntry(_response);
        });
    }

    protected processUpdateEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Delete an entry via V3 API
     * @param id Entry ID
     * @return No content on success
     */
    deleteEntry(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntry(_response);
        });
    }

    protected processDeleteEntry(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create multiple entries via V3 API (bulk operation)
     * @param entries Entries to create
     * @return Created entries
     */
    createEntries(entries: Entry[], signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v3/Entries/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntries(_response);
        });
    }

    protected processCreateEntries(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Get the most recent glucose entry
    This endpoint assumes SGV (sensor glucose value) type and returns the single most recent entry
     * @return The most recent glucose entry, or empty array if no entries exist
     */
    getCurrentEntry(signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentEntry(_response);
        });
    }

    protected processGetCurrentEntry(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Get a specific entry by ID or get entries by type
     * @param spec Either an entry ID (24-character hex string) or entry type (e.g., "sgv", "mbg", "cal")
     * @return Entry or entries matching the specification
     */
    getEntry2(spec: string, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries/{spec}";
        if (spec === undefined || spec === null)
            throw new Error("The parameter 'spec' must be defined.");
        url_ = url_.replace("{spec}", encodeURIComponent("" + spec));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry2(_response);
        });
    }

    protected processGetEntry2(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Get entries with optional query parameters
    Supports advanced query features including find filters, date ranges, and pagination
     * @param find (optional) MongoDB-style find query filters (JSON format) - for unit tests
     * @param count (optional) Maximum number of entries to return (if not specified, returns all matching entries)
     * @param dateString (optional) ISO date string for date filtering
     * @param type (optional) Entry type filter (default: "sgv")
     * @param rr (optional) Reverse results (latest first)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Array of entries matching the criteria
     */
    getEntries2(find?: string | null | undefined, count?: number | null | undefined, dateString?: string | null | undefined, type?: string | null | undefined, rr?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (count !== undefined && count !== null)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (dateString !== undefined && dateString !== null)
            url_ += "dateString=" + encodeURIComponent("" + dateString) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (rr === null)
            throw new Error("The parameter 'rr' cannot be null.");
        else if (rr !== undefined)
            url_ += "rr=" + encodeURIComponent("" + rr) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntries2(_response);
        });
    }

    protected processGetEntries2(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Create new entries
    Accepts both single entries and arrays of entries
     * @param entryData Entry data to create (can be single entry or array)
     * @return Created entries with assigned IDs
     */
    createEntries2All(entryData: any, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entryData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntries2All(_response);
        });
    }

    protected processCreateEntries2All(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Bulk delete entries with query filter
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Confirmation of bulk deletion
     */
    bulkDeleteEntries(find?: string | null | undefined, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Entries?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteEntries(_response);
        });
    }

    protected processBulkDeleteEntries(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Update an existing entry by ID
     * @param id The entry ID to update
     * @param entryData Updated entry data
     * @return Updated entry
     */
    updateEntry2(id: string, entryData: Entry, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v1/Entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entryData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntry2(_response);
        });
    }

    protected processUpdateEntry2(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Delete an entry by ID
     * @param id The entry ID to delete
     * @return Confirmation of deletion
     */
    deleteEntry2(id: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntry2(_response);
        });
    }

    protected processDeleteEntry2(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Create new entries asynchronously
    Accepts both single entries and arrays of entries, returns immediately with tracking information
     * @param entryData Entry data to create (can be single entry or array)
     * @return Async processing response with correlation ID and status URL
     */
    createEntries2(entryData: any, signal?: AbortSignal): Promise<AsyncProcessingResponse> {
        let url_ = this.baseUrl + "/api/v1/Entries/async";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entryData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntries2(_response);
        });
    }

    protected processCreateEntries2(response: Response): Promise<AsyncProcessingResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AsyncProcessingResponse;
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AsyncProcessingResponse>(null as any);
    }
}

export class FoodClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get food records with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 food collection response
     */
    getFood(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Food";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFood(_response);
        });
    }

    protected processGetFood(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new food records with V3 format and deduplication support
     * @param foodData Food data to create (single object or array)
     * @return Created food records
     */
    createFood(foodData: any, signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v3/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foodData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFood(_response);
        });
    }

    protected processCreateFood(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get a specific food record by ID with V3 format
     * @param id Food ID
     * @return Single food record in V3 format
     */
    getFoodById(id: string, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v3/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodById(_response);
        });
    }

    protected processGetFoodById(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Update a food record by ID with V3 format
     * @param id Food ID to update
     * @param food Updated food data
     * @return Updated food record
     */
    updateFood(id: string, food: Food, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v3/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(food);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFood(_response);
        });
    }

    protected processUpdateFood(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Delete a food record by ID
     * @param id Food ID to delete
     * @return No content on success
     */
    deleteFood(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFood(_response);
        });
    }

    protected processDeleteFood(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all food records (both food and quickpick types)
     * @return Array of food records ordered by name/position
     */
    getFood2(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFood2(_response);
        });
    }

    protected processGetFood2(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Create new food records
     * @param foods Food records to create (can be single object or array)
     * @return Created food records with assigned IDs
     */
    createFood2(foods: any, signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foods);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFood2(_response);
        });
    }

    protected processCreateFood2(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Alternative update endpoint compatible with legacy PUT without ID in URL
     * @param food Food data with ID
     * @return Updated food record
     */
    updateFoodLegacy(food: Food, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(food);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFoodLegacy(_response);
        });
    }

    protected processUpdateFoodLegacy(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Alternative endpoint with .json extension for compatibility
     * @return Array of food records
     */
    getFoodJson(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/food.json";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodJson(_response);
        });
    }

    protected processGetFoodJson(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get regular food records only (type="food")
     * @return Array of regular food records
     */
    getRegularFood(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food/regular";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegularFood(_response);
        });
    }

    protected processGetRegularFood(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get quickpick food records only (type="quickpick")
     * @return Array of quickpick food records ordered by position
     */
    getQuickPickFood(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food/quickpicks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuickPickFood(_response);
        });
    }

    protected processGetQuickPickFood(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get a specific food record by ID
     * @param id Food record ID
     * @return The food record with the specified ID
     */
    getFoodById2(id: string, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v1/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodById2(_response);
        });
    }

    protected processGetFoodById2(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Update an existing food record by ID
     * @param id Food record ID to update
     * @param food Updated food data
     * @return Updated food record
     */
    updateFood2(id: string, food: Food, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v1/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(food);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFood2(_response);
        });
    }

    protected processUpdateFood2(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Delete a food record by ID
     * @param id Food record ID to delete
     * @return No content if successful
     */
    deleteFood2(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFood2(_response);
        });
    }

    protected processDeleteFood2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LastModifiedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get last modified timestamps for all collections
     * @return Last modified timestamps for each collection
     */
    getLastModified(signal?: AbortSignal): Promise<LastModifiedResponse> {
        let url_ = this.baseUrl + "/api/v3/LastModified";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastModified(_response);
        });
    }

    protected processGetLastModified(response: Response): Promise<LastModifiedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LastModifiedResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LastModifiedResponse>(null as any);
    }
}

export class ProfileClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get profiles with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 profiles collection response
     */
    getProfiles(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfiles(_response);
        });
    }

    protected processGetProfiles(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new profiles with V3 format and deduplication support
     * @param profileData Profile data to create (single object or array)
     * @return Created profiles
     */
    createProfile(profileData: any, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v3/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profileData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProfile(_response);
        });
    }

    protected processCreateProfile(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Get a specific profile by ID with V3 format
     * @param id Profile ID
     * @return Single profile in V3 format
     */
    getProfileById(id: string, signal?: AbortSignal): Promise<Profile> {
        let url_ = this.baseUrl + "/api/v3/Profile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfileById(_response);
        });
    }

    protected processGetProfileById(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * Update a profile by ID with V3 format
     * @param id Profile ID to update
     * @param profile Updated profile data
     * @return Updated profile
     */
    updateProfile(id: string, profile: Profile, signal?: AbortSignal): Promise<Profile> {
        let url_ = this.baseUrl + "/api/v3/Profile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * Delete a profile by ID
     * @param id Profile ID to delete
     * @return No content on success
     */
    deleteProfile(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Profile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProfile(_response);
        });
    }

    protected processDeleteProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get profiles with optional pagination
     * @param count (optional) Maximum number of profiles to return (default: 10)
     * @return List of profiles
     */
    getProfiles2(count?: number | undefined, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfiles2(_response);
        });
    }

    protected processGetProfiles2(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Get the current active profile
     * @return The current active profile, or empty array if no profiles exist
     */
    getCurrentProfile(signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentProfile(_response);
        });
    }

    protected processGetCurrentProfile(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Get a specific profile by ID or treat the spec as a profile ID
     * @param spec The profile ID (24-character hex string for MongoDB ObjectId)
     * @return The profile with the specified ID, or empty array if not found
     */
    getProfile(spec: string, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile/{spec}";
        if (spec === undefined || spec === null)
            throw new Error("The parameter 'spec' must be defined.");
        url_ = url_.replace("{spec}", encodeURIComponent("" + spec));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }
}

export class SettingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get settings with V3 API features including pagination, field selection, and advanced filtering
    Requires admin permissions as per legacy API v3 behavior
     * @return V3 settings collection response
     */
    getSettings(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new settings records with V3 format and deduplication support
    Requires admin permissions as per legacy API v3 behavior
     * @param settingsData Settings data to create (single object or array)
     * @return Created settings records
     */
    createSettings(settingsData: any, signal?: AbortSignal): Promise<Settings[]> {
        let url_ = this.baseUrl + "/api/v3/Settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settingsData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSettings(_response);
        });
    }

    protected processCreateSettings(response: Response): Promise<Settings[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Settings[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings[]>(null as any);
    }

    /**
     * Get a specific settings record by ID with V3 format
    Requires admin permissions as per legacy API v3 behavior
     * @param id Settings ID
     * @return Single settings record in V3 format
     */
    getSettingsById(id: string, signal?: AbortSignal): Promise<Settings> {
        let url_ = this.baseUrl + "/api/v3/Settings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettingsById(_response);
        });
    }

    protected processGetSettingsById(response: Response): Promise<Settings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Settings;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings>(null as any);
    }

    /**
     * Update a settings record by ID with V3 format
    Requires admin permissions as per legacy API v3 behavior
     * @param id Settings ID to update
     * @param settings Updated settings data
     * @return Updated settings record
     */
    updateSettings(id: string, settings: Settings, signal?: AbortSignal): Promise<Settings> {
        let url_ = this.baseUrl + "/api/v3/Settings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSettings(_response);
        });
    }

    protected processUpdateSettings(response: Response): Promise<Settings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Settings;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings>(null as any);
    }

    /**
     * Delete a settings record by ID
    Requires admin permissions as per legacy API v3 behavior
     * @param id Settings ID to delete
     * @return No content on success
     */
    deleteSettings(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Settings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSettings(_response);
        });
    }

    protected processDeleteSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class StatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current system status with extended V3 information
     * @return Extended system status information with permissions and authorization details
     */
    getStatus(signal?: AbortSignal): Promise<V3StatusResponse> {
        let url_ = this.baseUrl + "/api/v3/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<V3StatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3StatusResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3StatusResponse>(null as any);
    }

    /**
     * Get the current system status
     * @return System status information
     */
    getStatus2(signal?: AbortSignal): Promise<StatusResponse> {
        let url_ = this.baseUrl + "/api/v1/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus2(_response);
        });
    }

    protected processGetStatus2(response: Response): Promise<StatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusResponse>(null as any);
    }
}

export class TreatmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get treatments with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 treatments collection response
     */
    getTreatments(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatments(_response);
        });
    }

    protected processGetTreatments(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create a new treatment via V3 API
     * @param treatment Treatment to create
     * @return Created treatment
     */
    createTreatment(treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v3/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatment(_response);
        });
    }

    protected processCreateTreatment(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Get a specific treatment by ID with V3 format
     * @param id Treatment ID
     * @return Single treatment in V3 format
     */
    getTreatment(id: string, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v3/Treatments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatment(_response);
        });
    }

    protected processGetTreatment(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Update a treatment via V3 API
     * @param id Treatment ID
     * @param treatment Updated treatment data
     * @return Updated treatment
     */
    updateTreatment(id: string, treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v3/Treatments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTreatment(_response);
        });
    }

    protected processUpdateTreatment(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Delete a treatment via V3 API
     * @param id Treatment ID
     * @return No content on success
     */
    deleteTreatment(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Treatments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTreatment(_response);
        });
    }

    protected processDeleteTreatment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create multiple treatments via V3 API (bulk operation)
     * @param treatments Treatments to create
     * @return Created treatments
     */
    createTreatments(treatments: Treatment[], signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v3/Treatments/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatments(_response);
        });
    }

    protected processCreateTreatments(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Get treatments with optional filtering and pagination
     * @param find (optional) MongoDB-style query filter for date range filtering
     * @param count (optional) Maximum number of treatments to return (default: 10)
     * @param skip (optional) Number of treatments to skip for pagination (default: 0)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Array of treatments ordered by most recent first
     */
    getTreatments2(find?: string | null | undefined, count?: number | undefined, skip?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v1/Treatments?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatments2(_response);
        });
    }

    protected processGetTreatments2(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Create new treatments
     * @param treatments Treatments to create (can be single object or array)
     * @return Created treatments with assigned IDs
     */
    createTreatments2(treatments: any, signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v1/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatments2(_response);
        });
    }

    protected processCreateTreatments2(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Bulk delete treatments using query parameters
     * @return Number of treatments deleted
     */
    bulkDeleteTreatments(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteTreatments(_response);
        });
    }

    protected processBulkDeleteTreatments(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get a specific treatment by ID
     * @param id Treatment ID
     * @return The treatment with the specified ID
     */
    getTreatmentById(id: string, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v1/Treatments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatmentById(_response);
        });
    }

    protected processGetTreatmentById(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Update an existing treatment by ID
     * @param id Treatment ID to update
     * @param treatment Updated treatment data
     * @return Updated treatment
     */
    updateTreatment2(id: string, treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v1/Treatments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTreatment2(_response);
        });
    }

    protected processUpdateTreatment2(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Delete a treatment by ID
     * @param id Treatment ID to delete
     * @return Success status
     */
    deleteTreatment2(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Treatments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTreatment2(_response);
        });
    }

    protected processDeleteTreatment2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VersionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current system version information
     * @return Version information
     */
    getVersion(signal?: AbortSignal): Promise<VersionResponse> {
        let url_ = this.baseUrl + "/api/v3/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<VersionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionResponse>(null as any);
    }
}

export class DDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get current DData structure
    Returns comprehensive data structure containing SGVs, treatments, profiles, and device status
     * @return Returns the DData structure
     */
    getDData(signal?: AbortSignal): Promise<DDataResponse> {
        let url_ = this.baseUrl + "/api/v2/ddata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDData(_response);
        });
    }

    protected processGetDData(response: Response): Promise<DDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DDataResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DDataResponse>(null as any);
    }

    /**
     * Get DData structure for a specific timestamp
    Returns data relevant to the specified timestamp
     * @param timestamp Unix timestamp in milliseconds or ISO date string
     * @return Returns the DData structure
     */
    getDDataAt(timestamp: string, signal?: AbortSignal): Promise<DDataResponse> {
        let url_ = this.baseUrl + "/api/v2/ddata/at/{timestamp}";
        if (timestamp === undefined || timestamp === null)
            throw new Error("The parameter 'timestamp' must be defined.");
        url_ = url_.replace("{timestamp}", encodeURIComponent("" + timestamp));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDDataAt(_response);
        });
    }

    protected processGetDDataAt(response: Response): Promise<DDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DDataResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the timestamp parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DDataResponse>(null as any);
    }

    /**
     * Get raw DData structure (without recent status filtering)
    Returns the complete DData structure without filtering recent device statuses
     * @param timestamp (optional) Optional Unix timestamp in milliseconds or ISO date string
     * @return Returns the raw DData structure
     */
    getRawDData(timestamp?: string | null | undefined, signal?: AbortSignal): Promise<DData> {
        let url_ = this.baseUrl + "/api/v2/ddata/raw?";
        if (timestamp !== undefined && timestamp !== null)
            url_ += "timestamp=" + encodeURIComponent("" + timestamp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRawDData(_response);
        });
    }

    protected processGetRawDData(response: Response): Promise<DData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DData;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the timestamp parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DData>(null as any);
    }
}

export class LoopClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Send Loop notification directly to iOS Loop app via APNS
    Implements the legacy ctx.loop.sendNotification() functionality with 1:1 compatibility
    This endpoint expects the exact data structure used by the legacy loop.js implementation
     * @param request Loop notification data and settings
     * @return Loop notification sent successfully
     */
    sendLoopNotification(request: LoopSendRequest, signal?: AbortSignal): Promise<LoopNotificationResponse> {
        let url_ = this.baseUrl + "/api/v2/loop/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendLoopNotification(_response);
        });
    }

    protected processSendLoopNotification(response: Response): Promise<LoopNotificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoopNotificationResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoopNotificationResponse;
            return throwException("Invalid Loop notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoopNotificationResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoopNotificationResponse>(null as any);
    }

    /**
     * Get Loop service configuration status
    Provides debugging information about Loop/APNS configuration
     * @return Configuration status retrieved successfully
     */
    getLoopStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v2/loop/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoopStatus(_response);
        });
    }

    protected processGetLoopStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class NotificationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Send Loop notification for iOS Loop app integration
    Implements the /api/v2/notifications/loop endpoint from legacy notifications-v2.js
     * @param request Loop notification request data
     * @return Notification processed successfully
     */
    sendLoopNotification(request: LoopNotificationRequest, signal?: AbortSignal): Promise<NotificationV2Response> {
        let url_ = this.baseUrl + "/api/v2/notifications/loop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendLoopNotification(_response);
        });
    }

    protected processSendLoopNotification(response: Response): Promise<NotificationV2Response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationV2Response>(null as any);
    }

    /**
     * Process a generic V2 notification
    Provides a generic endpoint for processing various notification types
     * @param notification Notification data to process
     * @return Notification processed successfully
     */
    processNotification(notification: NotificationBase, signal?: AbortSignal): Promise<NotificationV2Response> {
        let url_ = this.baseUrl + "/api/v2/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notification);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcessNotification(_response);
        });
    }

    protected processProcessNotification(response: Response): Promise<NotificationV2Response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationV2Response>(null as any);
    }

    /**
     * Get current notification system status and configuration
    Provides information about the notification system capabilities and status
     * @return Notification status retrieved successfully
     */
    getNotificationStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v2/notifications/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotificationStatus(_response);
        });
    }

    protected processGetNotificationStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Acknowledge a notification alarm to silence it
    Implements the /notifications/ack endpoint from legacy notifications.js
     * @param request Acknowledgment request containing level, group, and silence time
     * @return Notification acknowledged successfully
     */
    ackNotification(request: NotificationAckRequest, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/notifications/ack";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAckNotification(_response);
        });
    }

    protected processAckNotification(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid acknowledgment request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Handle Pushover webhook callbacks for notification acknowledgments
    Implements the /notifications/pushovercallback endpoint for Pushover integration
     * @param request Pushover callback request data from webhook
     * @return Pushover callback processed successfully
     */
    pushoverCallback(request: PushoverCallbackRequest, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/notifications/pushovercallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPushoverCallback(_response);
        });
    }

    protected processPushoverCallback(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid callback request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Get all admin notifications with their counts and timestamps
    Implements the /adminnotifies endpoint from legacy adminnotifies.js
     * @return Admin notifications retrieved successfully
     */
    getAdminNotifies(signal?: AbortSignal): Promise<AdminNotifiesResponse> {
        let url_ = this.baseUrl + "/api/v1/adminnotifies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdminNotifies(_response);
        });
    }

    protected processGetAdminNotifies(response: Response): Promise<AdminNotifiesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminNotifiesResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminNotifiesResponse>(null as any);
    }

    /**
     * Add a new admin notification or increment count if it already exists
    Provides an endpoint for creating admin notifications (typically used internally)
     * @param notification Admin notification to add
     * @return Admin notification added successfully
     */
    addAdminNotification(notification: AdminNotification, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/adminnotifies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notification);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAdminNotification(_response);
        });
    }

    protected processAddAdminNotification(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Clear all admin notifications
    Provides an endpoint for clearing all admin notifications (typically used for maintenance)
     * @return Admin notifications cleared successfully
     */
    clearAllAdminNotifications(signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/adminnotifies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearAllAdminNotifications(_response);
        });
    }

    protected processClearAllAdminNotifications(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Send a Pushover notification for testing or manual triggering
    Provides an endpoint for sending Pushover notifications directly
     * @param request Pushover notification request
     * @return Pushover notification sent successfully
     */
    sendPushoverNotification(request: PushoverNotificationRequest, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/notifications/pushover";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendPushoverNotification(_response);
        });
    }

    protected processSendPushoverNotification(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }
}

export class PropertiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all client properties and settings
    Returns comprehensive properties structure containing plugin data, settings, and computed values
     * @param pretty (optional) Format JSON with indentation for readability
     * @return Returns the properties structure
     */
    getAllProperties(pretty?: boolean | undefined, signal?: AbortSignal): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/v2/properties?";
        if (pretty === null)
            throw new Error("The parameter 'pretty' cannot be null.");
        else if (pretty !== undefined)
            url_ += "pretty=" + encodeURIComponent("" + pretty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProperties(_response);
        });
    }

    protected processGetAllProperties(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: any; };
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }

    /**
     * Get specific properties by names (comma-separated)
    Supports paths like /prop1 or /prop1,prop3 to get only specific properties
     * @param propertyPath Comma-separated list of property names to retrieve
     * @param pretty (optional) Format JSON with indentation for readability
     * @return Returns the selected properties
     */
    getSpecificProperties(propertyPath: string, pretty?: boolean | undefined, signal?: AbortSignal): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/v2/properties/{propertyPath}?";
        if (propertyPath === undefined || propertyPath === null)
            throw new Error("The parameter 'propertyPath' must be defined.");
        url_ = url_.replace("{propertyPath}", encodeURIComponent("" + propertyPath));
        if (pretty === null)
            throw new Error("The parameter 'pretty' cannot be null.");
        else if (pretty !== undefined)
            url_ += "pretty=" + encodeURIComponent("" + pretty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpecificProperties(_response);
        });
    }

    protected processGetSpecificProperties(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: any; };
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If property names are invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }
}

export class SummaryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get summary data for the specified time window
    Returns processed SGVs, treatments, profile, and state information
     * @param hours (optional) Number of hours to include in summary (default 6)
     * @return Returns the summary data
     */
    getSummary(hours?: number | null | undefined, signal?: AbortSignal): Promise<SummaryResponse> {
        let url_ = this.baseUrl + "/api/v2/summary?";
        if (hours !== undefined && hours !== null)
            url_ += "hours=" + encodeURIComponent("" + hours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: Response): Promise<SummaryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SummaryResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the hours parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SummaryResponse>(null as any);
    }
}

export class ActivityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all activities with optional filtering and pagination
     * @param count (optional) Maximum number of activities to return (default: 10)
     * @param skip (optional) Number of activities to skip for pagination (default: 0)
     * @return Activities retrieved successfully
     */
    getActivities(count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/v1/Activity?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivities(_response);
        });
    }

    protected processGetActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * Create one or more new activities
     * @param activities Activity data (single object or array)
     * @return Activities created successfully
     */
    createActivities(activities: any, signal?: AbortSignal): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/v1/Activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activities);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateActivities(_response);
        });
    }

    protected processCreateActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid activity data", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * Get a specific activity by ID
     * @param id Activity ID
     * @return Activity found and returned
     */
    getActivity(id: string, signal?: AbortSignal): Promise<Activity> {
        let url_ = this.baseUrl + "/api/v1/Activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivity(_response);
        });
    }

    protected processGetActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Activity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * Update an existing activity
     * @param id Activity ID to update
     * @param activity Updated activity data
     * @return Activity updated successfully
     */
    updateActivity(id: string, activity: Activity, signal?: AbortSignal): Promise<Activity> {
        let url_ = this.baseUrl + "/api/v1/Activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity(_response);
        });
    }

    protected processUpdateActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid activity data", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Activity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * Delete an activity by ID
     * @param id Activity ID to delete
     * @return Activity deleted successfully
     */
    deleteActivity(id: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity(_response);
        });
    }

    protected processDeleteActivity(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Activity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class AlexaClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Handle Alexa Skills Kit requests for voice assistant integration
    Processes LaunchRequest, IntentRequest, and SessionEndedRequest types
    Maintains complete compatibility with legacy /api/alexa endpoint
     * @param request Alexa Skills Kit request from Amazon
     * @return Alexa response with speech output and session handling
     */
    handleAlexaRequest(request: AlexaRequest, signal?: AbortSignal): Promise<AlexaResponse> {
        let url_ = this.baseUrl + "/api/Alexa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleAlexaRequest(_response);
        });
    }

    protected processHandleAlexaRequest(response: Response): Promise<AlexaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlexaResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlexaResponse>(null as any);
    }
}

export class CountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Count entries matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @param type (optional) Entry type filter (sgv, mbg, cal)
     * @return Count of entries matching the criteria
     */
    countEntries(find?: string | null | undefined, type?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/entries/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountEntries(_response);
        });
    }

    protected processCountEntries(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Count treatments matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Count of treatments matching the criteria
     */
    countTreatments(find?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/treatments/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountTreatments(_response);
        });
    }

    protected processCountTreatments(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Count device status entries matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Count of device status entries matching the criteria
     */
    countDeviceStatus(find?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/devicestatus/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountDeviceStatus(_response);
        });
    }

    protected processCountDeviceStatus(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Count activity entries matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Count of activity entries matching the criteria
     */
    countActivity(find?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/activity/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountActivity(_response);
        });
    }

    protected processCountActivity(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Generic count endpoint for any storage type
     * @param storage Storage type (entries, treatments, devicestatus, profile, food, activity)
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @param type (optional) Additional type filter (for entries: sgv, mbg, cal)
     * @return Count of records matching the criteria
     */
    countGeneric(storage: string, find?: string | null | undefined, type?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/{storage}/where?";
        if (storage === undefined || storage === null)
            throw new Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountGeneric(_response);
        });
    }

    protected processCountGeneric(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }
}

export class DebugClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    testPostgreSqlConnection(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/Debug/postgresql-test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestPostgreSqlConnection(_response);
        });
    }

    protected processTestPostgreSqlConnection(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getEntriesDirect(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/Debug/entries-direct";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntriesDirect(_response);
        });
    }

    protected processGetEntriesDirect(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class DeviceAgeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get cannula age information based on site change treatments
     * @param info (optional) Info threshold in hours (default: 44)
     * @param warn (optional) Warning threshold in hours (default: 48)
     * @param urgent (optional) Urgent threshold in hours (default: 72)
     * @param display (optional) Display format: hours or days (default: hours)
     * @param enableAlerts (optional) Enable alert notifications (default: false)
     * @return Cannula age information
     */
    getCannulaAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<DeviceAgeInfo> {
        let url_ = this.baseUrl + "/api/v1/DeviceAge/cannula?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCannulaAge(_response);
        });
    }

    protected processGetCannulaAge(response: Response): Promise<DeviceAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAgeInfo>(null as any);
    }

    /**
     * Get sensor age information based on sensor start and sensor change treatments
     * @param info (optional) Info threshold in hours (default: 144)
     * @param warn (optional) Warning threshold in hours (default: 164)
     * @param urgent (optional) Urgent threshold in hours (default: 166)
     * @param display (optional) Display format: hours or days (default: days)
     * @param enableAlerts (optional) Enable alert notifications (default: false)
     * @return Sensor age information
     */
    getSensorAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<SensorAgeInfo> {
        let url_ = this.baseUrl + "/api/v1/DeviceAge/sensor?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSensorAge(_response);
        });
    }

    protected processGetSensorAge(response: Response): Promise<SensorAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SensorAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorAgeInfo>(null as any);
    }

    /**
     * Get battery age information based on battery change treatments
     * @param info (optional) Info threshold in hours (default: 312)
     * @param warn (optional) Warning threshold in hours (default: 336)
     * @param urgent (optional) Urgent threshold in hours (default: 360)
     * @param display (optional) Display format: hours or days (default: days)
     * @param enableAlerts (optional) Enable alert notifications (default: false)
     * @return Battery age information
     */
    getBatteryAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<DeviceAgeInfo> {
        let url_ = this.baseUrl + "/api/v1/DeviceAge/battery?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBatteryAge(_response);
        });
    }

    protected processGetBatteryAge(response: Response): Promise<DeviceAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAgeInfo>(null as any);
    }

    /**
     * Get calibration age information based on BG Check and Calibration treatments
     * @param info (optional) Info threshold in hours (default: 24)
     * @param warn (optional) Warning threshold in hours (default: 48)
     * @param urgent (optional) Urgent threshold in hours (default: 72)
     * @param display (optional) Display format: hours or days (default: hours)
     * @param enableAlerts (optional) Enable alert notifications (default: false)
     * @return Calibration age information
     */
    getCalibrationAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<DeviceAgeInfo> {
        let url_ = this.baseUrl + "/api/v1/DeviceAge/calibration?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCalibrationAge(_response);
        });
    }

    protected processGetCalibrationAge(response: Response): Promise<DeviceAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAgeInfo>(null as any);
    }

    /**
     * Get all device ages in a single request
     * @return Combined device age information
     */
    getAllDeviceAges(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/DeviceAge/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDeviceAges(_response);
        });
    }

    protected processGetAllDeviceAges(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class DeviceAlertsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get active device alerts for the current user
     * @param deviceId (optional) Optional device ID filter
     * @return List of active device alerts
     */
    getActiveDeviceAlerts(deviceId?: string | null | undefined, signal?: AbortSignal): Promise<DeviceAlert[]> {
        let url_ = this.baseUrl + "/api/v1/devices/alerts?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActiveDeviceAlerts(_response);
        });
    }

    protected processGetActiveDeviceAlerts(response: Response): Promise<DeviceAlert[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlert[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlert[]>(null as any);
    }

    /**
     * Get device alerts summary by type
     * @return Alert summary
     */
    getDeviceAlertSummary(signal?: AbortSignal): Promise<DeviceAlertSummary> {
        let url_ = this.baseUrl + "/api/v1/devices/alerts/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceAlertSummary(_response);
        });
    }

    protected processGetDeviceAlertSummary(response: Response): Promise<DeviceAlertSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlertSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlertSummary>(null as any);
    }

    /**
     * Acknowledge a device alert
     * @param alertId Alert identifier
     * @return Success response
     */
    acknowledgeDeviceAlert(alertId: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/devices/alerts/{alertId}/acknowledge";
        if (alertId === undefined || alertId === null)
            throw new Error("The parameter 'alertId' must be defined.");
        url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcknowledgeDeviceAlert(_response);
        });
    }

    protected processAcknowledgeDeviceAlert(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Test device alert generation for a specific device
     * @param deviceId Device identifier
     * @return List of generated alerts
     */
    testDeviceAlerts(deviceId: string, signal?: AbortSignal): Promise<DeviceAlert[]> {
        let url_ = this.baseUrl + "/api/v1/devices/alerts/test/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestDeviceAlerts(_response);
        });
    }

    protected processTestDeviceAlerts(response: Response): Promise<DeviceAlert[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlert[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlert[]>(null as any);
    }

    /**
     * Get alert settings/preferences for device alerts
     * @return Alert settings
     */
    getAlertSettings(signal?: AbortSignal): Promise<DeviceAlertSettings> {
        let url_ = this.baseUrl + "/api/v1/devices/alerts/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAlertSettings(_response);
        });
    }

    protected processGetAlertSettings(response: Response): Promise<DeviceAlertSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlertSettings;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlertSettings>(null as any);
    }

    /**
     * Update alert settings/preferences for device alerts
     * @param settings Alert settings
     * @return Success response
     */
    updateAlertSettings(settings: DeviceAlertSettings, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/devices/alerts/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAlertSettings(_response);
        });
    }

    protected processUpdateAlertSettings(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class DeviceHealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all devices for the current user
     * @return List of user's devices
     */
    getUserDevices(signal?: AbortSignal): Promise<DeviceHealth[]> {
        let url_ = this.baseUrl + "/api/v1/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserDevices(_response);
        });
    }

    protected processGetUserDevices(response: Response): Promise<DeviceHealth[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealth[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth[]>(null as any);
    }

    /**
     * Register a new device
     * @param request Device registration request
     * @return Registered device information
     */
    registerDevice(request: DeviceRegistrationRequest, signal?: AbortSignal): Promise<DeviceHealth> {
        let url_ = this.baseUrl + "/api/v1/devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterDevice(_response);
        });
    }

    protected processRegisterDevice(response: Response): Promise<DeviceHealth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealth;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth>(null as any);
    }

    /**
     * Get device health information
     * @param id Device identifier
     * @return Device health information
     */
    getDeviceHealth(id: string, signal?: AbortSignal): Promise<DeviceHealthAnalysis> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}/health";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceHealth(_response);
        });
    }

    protected processGetDeviceHealth(response: Response): Promise<DeviceHealthAnalysis> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealthAnalysis;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealthAnalysis>(null as any);
    }

    /**
     * Update device health metrics
     * @param id Device identifier
     * @param update Device health update
     * @return Success response
     */
    updateDeviceHealth(id: string, update: DeviceHealthUpdate, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}/health";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceHealth(_response);
        });
    }

    protected processUpdateDeviceHealth(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get device information
     * @param id Device identifier
     * @return Device information
     */
    getDevice(id: string, signal?: AbortSignal): Promise<DeviceHealth> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDevice(_response);
        });
    }

    protected processGetDevice(response: Response): Promise<DeviceHealth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealth;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth>(null as any);
    }

    /**
     * Remove a device from the registry
     * @param id Device identifier
     * @return Success response
     */
    removeDevice(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveDevice(_response);
        });
    }

    protected processRemoveDevice(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Update device settings
     * @param id Device identifier
     * @param settings Device settings update
     * @return Success response
     */
    updateDeviceSettings(id: string, settings: DeviceSettingsUpdate, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}/settings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceSettings(_response);
        });
    }

    protected processUpdateDeviceSettings(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get device health report
     * @param id Device identifier
     * @param period (optional) Report period in days (default: 30)
     * @return Device health report
     */
    getDeviceHealthReport(id: string, period?: number | undefined, signal?: AbortSignal): Promise<DeviceHealthReport> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}/report?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "period=" + encodeURIComponent("" + period) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceHealthReport(_response);
        });
    }

    protected processGetDeviceHealthReport(response: Response): Promise<DeviceHealthReport> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealthReport;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealthReport>(null as any);
    }

    /**
     * Get maintenance predictions for a device
     * @param id Device identifier
     * @return Maintenance prediction
     */
    getMaintenancePrediction(id: string, signal?: AbortSignal): Promise<MaintenancePrediction> {
        let url_ = this.baseUrl + "/api/v1/devices/{id}/maintenance/prediction";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMaintenancePrediction(_response);
        });
    }

    protected processGetMaintenancePrediction(response: Response): Promise<MaintenancePrediction> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MaintenancePrediction;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MaintenancePrediction>(null as any);
    }
}

export class EchoClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Echo endpoint for debugging MongoDB queries
    Returns information about how REST API parameters translate into MongoDB queries
     * @param echo Storage type to query (entries, treatments, devicestatus, activity)
     * @return Query information returned successfully
     */
    echoQuery(echo: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/echo/{echo}";
        if (echo === undefined || echo === null)
            throw new Error("The parameter 'echo' must be defined.");
        url_ = url_.replace("{echo}", encodeURIComponent("" + echo));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoQuery(_response);
        });
    }

    protected processEchoQuery(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Echo endpoint for debugging MongoDB queries with model
    Returns information about how REST API parameters translate into MongoDB queries
     * @param echo Storage type to query (entries, treatments, devicestatus, activity)
     * @param model Model specification
     * @return Query information returned successfully
     */
    echoQueryWithModel(echo: string, model: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/echo/{echo}/{model}";
        if (echo === undefined || echo === null)
            throw new Error("The parameter 'echo' must be defined.");
        url_ = url_.replace("{echo}", encodeURIComponent("" + echo));
        if (model === undefined || model === null)
            throw new Error("The parameter 'model' must be defined.");
        url_ = url_.replace("{model}", encodeURIComponent("" + model));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoQueryWithModel(_response);
        });
    }

    protected processEchoQueryWithModel(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Echo endpoint for debugging MongoDB queries with model and spec
    Returns information about how REST API parameters translate into MongoDB queries
     * @param echo Storage type to query (entries, treatments, devicestatus, activity)
     * @param model Model specification
     * @param spec Specification parameter
     * @return Query information returned successfully
     */
    echoQueryWithModelAndSpec(echo: string, model: string, spec: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/echo/{echo}/{model}/{spec}";
        if (echo === undefined || echo === null)
            throw new Error("The parameter 'echo' must be defined.");
        url_ = url_.replace("{echo}", encodeURIComponent("" + echo));
        if (model === undefined || model === null)
            throw new Error("The parameter 'model' must be defined.");
        url_ = url_.replace("{model}", encodeURIComponent("" + model));
        if (spec === undefined || spec === null)
            throw new Error("The parameter 'spec' must be defined.");
        url_ = url_.replace("{spec}", encodeURIComponent("" + spec));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoQueryWithModelAndSpec(_response);
        });
    }

    protected processEchoQueryWithModelAndSpec(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Preview endpoint for entry creation without persistence
    Allows previewing entry data without actually storing it in the database
     * @param entries Entry data to preview (single object or array)
     * @return Entry data previewed successfully
     */
    previewEntries(entries: any, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/entries/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreviewEntries(_response);
        });
    }

    protected processPreviewEntries(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid entry data", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class IobClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Calculate current IOB from treatments and device status
     * @param time (optional) Optional timestamp for calculation (default: current time)
     * @return Returns the current IOB calculation
     */
    getCurrentIob(time?: number | null | undefined, signal?: AbortSignal): Promise<IobResult> {
        let url_ = this.baseUrl + "/api/v1/Iob?";
        if (time !== undefined && time !== null)
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentIob(_response);
        });
    }

    protected processGetCurrentIob(response: Response): Promise<IobResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IobResult;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IobResult>(null as any);
    }

    /**
     * Calculate IOB from treatments only (excluding device status)
     * @param time (optional) Optional timestamp for calculation (default: current time)
     * @return Returns the IOB calculation from treatments
     */
    getIobFromTreatments(time?: number | null | undefined, signal?: AbortSignal): Promise<IobResult> {
        let url_ = this.baseUrl + "/api/v1/Iob/treatments?";
        if (time !== undefined && time !== null)
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIobFromTreatments(_response);
        });
    }

    protected processGetIobFromTreatments(response: Response): Promise<IobResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IobResult;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IobResult>(null as any);
    }

    /**
     * Calculate hourly IOB breakdown for charts and analysis
     * @param intervalMinutes (optional) Time interval in minutes for calculations (default: 5)
     * @param hours (optional) Number of hours to calculate (default: 24)
     * @param startTime (optional) Start time for calculation (default: 24 hours ago)
     * @return Returns the hourly IOB breakdown
     */
    getHourlyIob(intervalMinutes?: number | undefined, hours?: number | undefined, startTime?: number | null | undefined, signal?: AbortSignal): Promise<HourlyIobResponse> {
        let url_ = this.baseUrl + "/api/v1/Iob/hourly?";
        if (intervalMinutes === null)
            throw new Error("The parameter 'intervalMinutes' cannot be null.");
        else if (intervalMinutes !== undefined)
            url_ += "intervalMinutes=" + encodeURIComponent("" + intervalMinutes) + "&";
        if (hours === null)
            throw new Error("The parameter 'hours' cannot be null.");
        else if (hours !== undefined)
            url_ += "hours=" + encodeURIComponent("" + hours) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "startTime=" + encodeURIComponent("" + startTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHourlyIob(_response);
        });
    }

    protected processGetHourlyIob(response: Response): Promise<HourlyIobResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HourlyIobResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If parameters are invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HourlyIobResponse>(null as any);
    }
}

export class ProcessingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the processing status for a correlation ID
     * @param correlationId The correlation ID to check
     * @return Processing status or 404 if not found
     */
    getProcessingStatus(correlationId: string, signal?: AbortSignal): Promise<ProcessingStatusResponse> {
        let url_ = this.baseUrl + "/api/v1/processing/status/{correlationId}";
        if (correlationId === undefined || correlationId === null)
            throw new Error("The parameter 'correlationId' must be defined.");
        url_ = url_.replace("{correlationId}", encodeURIComponent("" + correlationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessingStatus(_response);
        });
    }

    protected processGetProcessingStatus(response: Response): Promise<ProcessingStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProcessingStatusResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessingStatusResponse>(null as any);
    }

    /**
     * Wait for processing to complete with long polling
     * @param correlationId The correlation ID to wait for
     * @param timeoutSeconds (optional) Maximum time to wait in seconds (default: 30)
     * @return Processing status when completed or timeout response
     */
    waitForCompletion(correlationId: string, timeoutSeconds?: number | undefined, signal?: AbortSignal): Promise<ProcessingStatusResponse> {
        let url_ = this.baseUrl + "/api/v1/processing/status/{correlationId}/wait?";
        if (correlationId === undefined || correlationId === null)
            throw new Error("The parameter 'correlationId' must be defined.");
        url_ = url_.replace("{correlationId}", encodeURIComponent("" + correlationId));
        if (timeoutSeconds === null)
            throw new Error("The parameter 'timeoutSeconds' cannot be null.");
        else if (timeoutSeconds !== undefined)
            url_ += "timeoutSeconds=" + encodeURIComponent("" + timeoutSeconds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWaitForCompletion(_response);
        });
    }

    protected processWaitForCompletion(response: Response): Promise<ProcessingStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProcessingStatusResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 408) {
            return response.text().then((_responseText) => {
            let result408: any = null;
            result408 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result408);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessingStatusResponse>(null as any);
    }
}

export class TimeQueryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Complex time pattern matching with bash-style brace expansion
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the time patterns
     */
    getTimeBasedEntries(count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/times?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeBasedEntries(_response);
        });
    }

    protected processGetTimeBasedEntries(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Complex time pattern matching with bash-style brace expansion
     * @param prefix Time prefix pattern (e.g., "2015-04", "20{14..15}")
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the time patterns
     */
    getTimeBasedEntriesWithPrefix(prefix: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/times/{prefix}?";
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeBasedEntriesWithPrefix(_response);
        });
    }

    protected processGetTimeBasedEntriesWithPrefix(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Complex time pattern matching with bash-style brace expansion
     * @param prefix Time prefix pattern (e.g., "2015-04", "20{14..15}")
     * @param regex Time regex pattern (e.g., "T{13..18}:{00..15}")
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the time patterns
     */
    getTimeBasedEntriesWithPrefixAndRegex(prefix: string, regex: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/times/{prefix}/{regex}?";
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (regex === undefined || regex === null)
            throw new Error("The parameter 'regex' must be defined.");
        url_ = url_.replace("{regex}", encodeURIComponent("" + regex));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeBasedEntriesWithPrefixAndRegex(_response);
        });
    }

    protected processGetTimeBasedEntriesWithPrefixAndRegex(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Time query debugging and pattern inspection
    Shows how the time patterns are expanded and what MongoDB query would be generated
     * @param storage (optional) Storage type (entries, treatments, devicestatus)
     * @param field (optional) Field name to match patterns against
     * @return Debug information about the generated patterns and query
     */
    getTimeQueryEcho(storage?: string | undefined, field?: string | undefined, signal?: AbortSignal): Promise<TimeQueryEcho> {
        let url_ = this.baseUrl + "/api/v1/times/echo?";
        if (storage === null)
            throw new Error("The parameter 'storage' cannot be null.");
        else if (storage !== undefined)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        if (field === null)
            throw new Error("The parameter 'field' cannot be null.");
        else if (field !== undefined)
            url_ += "field=" + encodeURIComponent("" + field) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeQueryEcho(_response);
        });
    }

    protected processGetTimeQueryEcho(response: Response): Promise<TimeQueryEcho> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeQueryEcho;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeQueryEcho>(null as any);
    }

    /**
     * Time query debugging and pattern inspection with prefix
    Shows how the time patterns are expanded and what MongoDB query would be generated
     * @param prefix Time prefix pattern
     * @param storage (optional) Storage type (entries, treatments, devicestatus)
     * @param field (optional) Field name to match patterns against
     * @return Debug information about the generated patterns and query
     */
    getTimeQueryEchoWithPrefix(prefix: string, storage?: string | undefined, field?: string | undefined, signal?: AbortSignal): Promise<TimeQueryEcho> {
        let url_ = this.baseUrl + "/api/v1/times/echo/{prefix}?";
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (storage === null)
            throw new Error("The parameter 'storage' cannot be null.");
        else if (storage !== undefined)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        if (field === null)
            throw new Error("The parameter 'field' cannot be null.");
        else if (field !== undefined)
            url_ += "field=" + encodeURIComponent("" + field) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeQueryEchoWithPrefix(_response);
        });
    }

    protected processGetTimeQueryEchoWithPrefix(response: Response): Promise<TimeQueryEcho> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeQueryEcho;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeQueryEcho>(null as any);
    }

    /**
     * Time query debugging and pattern inspection with prefix and regex
    Shows how the time patterns are expanded and what MongoDB query would be generated
     * @param prefix Time prefix pattern
     * @param regex Time regex pattern
     * @param storage (optional) Storage type (entries, treatments, devicestatus)
     * @param field (optional) Field name to match patterns against
     * @return Debug information about the generated patterns and query
     */
    getTimeQueryEchoWithPrefixAndRegex(prefix: string, regex: string, storage?: string | undefined, field?: string | undefined, signal?: AbortSignal): Promise<TimeQueryEcho> {
        let url_ = this.baseUrl + "/api/v1/times/echo/{prefix}/{regex}?";
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (regex === undefined || regex === null)
            throw new Error("The parameter 'regex' must be defined.");
        url_ = url_.replace("{regex}", encodeURIComponent("" + regex));
        if (storage === null)
            throw new Error("The parameter 'storage' cannot be null.");
        else if (storage !== undefined)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        if (field === null)
            throw new Error("The parameter 'field' cannot be null.");
        else if (field !== undefined)
            url_ += "field=" + encodeURIComponent("" + field) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeQueryEchoWithPrefixAndRegex(_response);
        });
    }

    protected processGetTimeQueryEchoWithPrefixAndRegex(response: Response): Promise<TimeQueryEcho> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeQueryEcho;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeQueryEcho>(null as any);
    }

    /**
     * Advanced data slicing with regex patterns and field filtering
    Allows specifying storage layer, field to match, entry type, and pattern matching
    - /api/v1/slice/entries/dateString - All entries matching dateString field
    - /api/v1/slice/entries/dateString/mbg/2015 - All MBG entries from 2015
    - /api/v1/slice/treatments/created_at/bolus/2015-04 - All bolus treatments from April 2015
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedData(storage: string, field: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}?";
        if (storage === undefined || storage === null)
            throw new Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedData(_response);
        });
    }

    protected processGetSlicedData(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Advanced data slicing with type filter
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param type Entry/record type filter
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedDataWithType(storage: string, field: string, type: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}/{type}?";
        if (storage === undefined || storage === null)
            throw new Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedDataWithType(_response);
        });
    }

    protected processGetSlicedDataWithType(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Advanced data slicing with type and prefix filter
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param type Entry/record type filter
     * @param prefix Pattern prefix
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedDataWithTypeAndPrefix(storage: string, field: string, type: string, prefix: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}/{type}/{prefix}?";
        if (storage === undefined || storage === null)
            throw new Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedDataWithTypeAndPrefix(_response);
        });
    }

    protected processGetSlicedDataWithTypeAndPrefix(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Advanced data slicing with all parameters
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param type Entry/record type filter
     * @param prefix Pattern prefix
     * @param regex Pattern regex
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedDataWithAll(storage: string, field: string, type: string, prefix: string, regex: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}/{type}/{prefix}/{regex}?";
        if (storage === undefined || storage === null)
            throw new Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (regex === undefined || regex === null)
            throw new Error("The parameter 'regex' must be defined.");
        url_ = url_.replace("{regex}", encodeURIComponent("" + regex));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedDataWithAll(_response);
        });
    }

    protected processGetSlicedDataWithAll(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }
}

export interface PerformanceMetrics {
    averageResponseTime?: number;
    totalRequests?: number;
    errorCount?: number;
    memoryUsageMB?: number;
    uptimeHours?: number;
    topEndpoints?: { [key: string]: number; };
}

export interface UsageStatistics {
    uniqueSessions?: number;
    popularFeatures?: { [key: string]: number; };
    averageSessionDuration?: number;
    deviceTypes?: { [key: string]: number; };
}

export interface AnalyticsBatch {
    installationId?: string;
    events?: AnalyticsEvent[];
    systemInfo?: SystemInfo | undefined;
    batchTimestamp?: number;
    schemaVersion?: string;
}

export interface AnalyticsEvent {
    sessionId?: string;
    eventType?: string;
    category?: string;
    action?: string;
    label?: string;
    value?: number | undefined;
    timestamp?: number;
    metadata?: { [key: string]: any; };
}

export interface SystemInfo {
    platform?: string;
    runtimeVersion?: string;
    nocturneVersion?: string;
    deploymentType?: string;
    demoModeEnabled?: boolean;
    enabledConnectors?: string[];
    enabledFeatures?: string[];
    databaseType?: string;
    cacheEnabled?: boolean;
}

export interface AnalyticsCollectionConfig {
    collectApiUsage?: boolean;
    collectUiUsage?: boolean;
    collectPerformanceMetrics?: boolean;
    collectHealthMetrics?: boolean;
    collectFeatureUsage?: boolean;
    excludedEndpoints?: string[];
    maxLocalEvents?: number;
}

/** Response for the /api/v1/verifyauth endpoint */
export interface VerifyAuthResponse {
    /** Authentication message - can be either a string or an object */
    message?: any;
}

export interface AuthorizationResponse {
    token?: string;
    exp?: number;
    sub?: string;
    iat?: number;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface PermissionsResponse {
    permissions?: Permission[];
}

export interface Permission {
    name?: string;
    count?: number;
    firstSeen?: Date;
    lastSeen?: Date;
}

export interface PermissionTrieResponse {
    root?: PermissionTrieNode;
    count?: number;
}

export interface PermissionTrieNode {
    name?: string;
    isLeaf?: boolean;
    children?: { [key: string]: PermissionTrieNode; };
}

export interface Subject {
    id?: string | undefined;
    _id?: string | undefined;
    name: string;
    roles?: string[];
    accessToken?: string;
    notes?: string | undefined;
    created?: Date;
    modified?: Date;
}

export interface Role {
    id?: string | undefined;
    _id?: string | undefined;
    name: string;
    permissions?: string[];
    notes?: string | undefined;
    autoGenerated?: boolean;
    created?: Date;
    modified?: Date;
}

/** Metadata about available WebSocket events */
export interface WebSocketEventsMetadata {
    /** Array of all available WebSocket event types */
    availableEvents?: WebSocketEvents[];
    /** Description of the WebSocket events */
    description?: string;
}

export type WebSocketEvents = "connect" | "disconnect" | "connect_error" | "reconnect" | "reconnect_failed" | "connect_ack" | "dataUpdate" | "treatmentUpdate" | "create" | "update" | "delete" | "announcement" | "alarm" | "urgent_alarm" | "clear_alarm" | "notification" | "statusUpdate" | "status" | "authenticate" | "authenticated" | "join" | "leave";

export interface BasicGlucoseStats {
    count?: number;
    mean?: number;
    median?: number;
    min?: number;
    max?: number;
    standardDeviation?: number;
    percentiles?: GlucosePercentiles;
}

export interface GlucosePercentiles {
    p5?: number;
    p10?: number;
    p25?: number;
    p50?: number;
    p75?: number;
    p90?: number;
    p95?: number;
}

export interface GlycemicVariability {
    coefficientOfVariation?: number;
    standardDeviation?: number;
    meanAmplitudeGlycemicExcursions?: number;
    continuousOverlappingNetGlycemicAction?: number;
    averageDailyRiskRange?: number;
    labilityIndex?: number;
    jIndex?: number;
    highBloodGlucoseIndex?: number;
    lowBloodGlucoseIndex?: number;
    glycemicVariabilityIndex?: number;
    patientGlycemicStatus?: number;
    estimatedA1c?: number;
}

/** Request model for glycemic variability calculation */
export interface GlycemicVariabilityRequest {
    /** Collection of glucose values in mg/dL */
    values?: number[];
    /** Collection of glucose entries with timestamps */
    entries?: Entry[];
}

export interface ProcessableDocumentBase {
    id?: string | undefined;
    createdAt?: string | undefined;
    mills?: number;
    utcOffset?: number | undefined;
}

export interface Entry extends ProcessableDocumentBase {
    _id?: string | undefined;
    mills?: number;
    dateString?: string | undefined;
    mgdl?: number;
    mbg?: number | undefined;
    mmol?: number | undefined;
    sgv?: number | undefined;
    direction?: string | undefined;
    type?: string;
    device?: string | undefined;
    notes?: string | undefined;
    delta?: number | undefined;
    scaled?: any | undefined;
    sysTime?: string | undefined;
    utcOffset?: number | undefined;
    noise?: number | undefined;
    filtered?: number | undefined;
    unfiltered?: number | undefined;
    rssi?: number | undefined;
    slope?: number | undefined;
    intercept?: number | undefined;
    scale?: number | undefined;
    created_at?: string | undefined;
    modified_at?: Date | undefined;
    is_demo?: boolean | undefined;
    meta?: { [key: string]: any; } | undefined;
}

export function isEntry(object: any): object is Entry {
    return object && object[''] === 'Entry';
}

export interface TimeInRangeMetrics {
    percentages?: TimeInRangePercentages;
    durations?: TimeInRangeDurations;
    episodes?: TimeInRangeEpisodes;
}

export interface TimeInRangePercentages {
    severeLow?: number;
    low?: number;
    target?: number;
    tightTarget?: number;
    high?: number;
    severeHigh?: number;
}

export interface TimeInRangeDurations {
    severeLow?: number;
    low?: number;
    target?: number;
    tightTarget?: number;
    high?: number;
    severeHigh?: number;
}

export interface TimeInRangeEpisodes {
    severeLow?: number;
    low?: number;
    high?: number;
    severeHigh?: number;
}

/** Request model for time in range calculation */
export interface TimeInRangeRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional glycemic thresholds */
    thresholds?: GlycemicThresholds | undefined;
}

export interface GlycemicThresholds {
    severeLow?: number;
    low?: number;
    targetBottom?: number;
    targetTop?: number;
    tightTargetBottom?: number;
    tightTargetTop?: number;
    high?: number;
    severeHigh?: number;
}

export interface DistributionDataPoint {
    range?: string;
    count?: number;
    percent?: number;
}

/** Request model for glucose distribution calculation */
export interface GlucoseDistributionRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional distribution bins */
    bins?: DistributionBin[] | undefined;
}

export interface DistributionBin {
    range?: string;
    min?: number;
    max?: number;
}

export interface AveragedStats extends BasicGlucoseStats {
    hour?: number;
}

export function isAveragedStats(object: any): object is AveragedStats {
    return object && object[''] === 'AveragedStats';
}

export interface TreatmentSummary {
    totals?: TreatmentTotals;
    treatmentCount?: number;
}

export interface TreatmentTotals {
    food?: FoodTotals;
    insulin?: InsulinTotals;
}

export interface FoodTotals {
    carbs?: number;
    protein?: number;
    fat?: number;
}

export interface InsulinTotals {
    bolus?: number;
    basal?: number;
}

export interface Treatment extends ProcessableDocumentBase {
    _id?: string | undefined;
    eventType?: string | undefined;
    reason?: string | undefined;
    glucose?: number | undefined;
    glucoseType?: string | undefined;
    carbs?: number | undefined;
    insulin?: number | undefined;
    protein?: number | undefined;
    fat?: number | undefined;
    foodType?: string | undefined;
    units?: string | undefined;
    mills?: number;
    created_at?: string | undefined;
    duration?: number | undefined;
    percent?: number | undefined;
    absolute?: number | undefined;
    notes?: string | undefined;
    enteredBy?: string | undefined;
    targetTop?: number | undefined;
    targetBottom?: number | undefined;
    profile?: string | undefined;
    split?: string | undefined;
    date?: number | undefined;
    carbTime?: number | undefined;
    boluscalc?: { [key: string]: any; } | undefined;
    utcOffset?: number | undefined;
    timestamp?: number | undefined;
    cuttedby?: string | undefined;
    cutting?: string | undefined;
    source?: string | undefined;
    eventTime?: string | undefined;
    preBolus?: number | undefined;
    rate?: number | undefined;
    mgdl?: number | undefined;
    mmol?: number | undefined;
    endmills?: number | undefined;
    durationType?: string | undefined;
    isAnnouncement?: boolean | undefined;
    profileJson?: string | undefined;
    endprofile?: string | undefined;
    insulinNeedsScaleFactor?: number | undefined;
    absorptionTime?: number | undefined;
    enteredinsulin?: number | undefined;
    splitNow?: number | undefined;
    splitExt?: number | undefined;
    status?: string | undefined;
    relative?: number | undefined;
    CR?: number | undefined;
    NSCLIENT_ID?: string | undefined;
    first?: boolean | undefined;
    end?: boolean | undefined;
    CircadianPercentageProfile?: boolean | undefined;
    percentage?: number | undefined;
    timeshift?: number | undefined;
    transmitterId?: string | undefined;
    additional_properties?: { [key: string]: any; } | undefined;
}

export function isTreatment(object: any): object is Treatment {
    return object && object[''] === 'Treatment';
}

export interface OverallAverages {
    avgTotalDaily?: number;
    avgBolus?: number;
    avgBasal?: number;
    bolusPercentage?: number;
    basalPercentage?: number;
    avgCarbs?: number;
    avgProtein?: number;
    avgFat?: number;
    avgTimeInRange?: number;
    avgTightTimeInRange?: number;
}

export interface DayData {
    date?: string;
    treatments?: Treatment[];
    treatmentSummary?: TreatmentSummary;
    timeInRanges?: TimeInRangeMetrics;
}

export interface GlucoseAnalytics {
    basicStats?: BasicGlucoseStats;
    timeInRange?: TimeInRangeMetrics;
    glycemicVariability?: GlycemicVariability;
    dataQuality?: DataQuality;
    time?: AnalysisTime;
}

export interface DataQuality {
    totalReadings?: number;
    missingReadings?: number;
    dataCompleteness?: number;
    cgmActivePercent?: number;
    gapAnalysis?: GapAnalysis;
    noiseLevel?: number;
    calibrationEvents?: number;
    sensorWarmups?: number;
}

export interface GapAnalysis {
    gaps?: DataGap[];
    longestGap?: number;
    averageGap?: number;
}

export interface DataGap {
    start?: number;
    end?: number;
    duration?: number;
}

export interface AnalysisTime {
    start?: number;
    end?: number;
    timeOfAnalysis?: number;
}

/** Request model for comprehensive glucose analytics */
export interface GlucoseAnalyticsRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional collection of treatments */
    treatments?: Treatment[] | undefined;
    /** Optional extended analysis configuration */
    config?: ExtendedAnalysisConfig | undefined;
}

export interface ExtendedAnalysisConfig {
    thresholds?: GlycemicThresholds;
    sensorType?: string;
    includeLoopingMetrics?: boolean;
    units?: string;
}

export interface ExtendedGlucoseAnalytics extends GlucoseAnalytics {
    gmi?: GlucoseManagementIndicator;
    gri?: GlycemicRiskIndex;
    timeOfDayPatterns?: TimeOfDayAnalysis;
    dayOfWeekPatterns?: DayOfWeekAnalysis;
    hypoglycemiaAnalysis?: HypoglycemiaAnalysis;
    hyperglycemiaAnalysis?: HyperglycemiaAnalysis;
    clinicalAssessment?: ClinicalTargetAssessment;
    dataSufficiency?: DataSufficiencyAssessment;
    treatmentSummary?: TreatmentSummary | undefined;
}

export function isExtendedGlucoseAnalytics(object: any): object is ExtendedGlucoseAnalytics {
    return object && object[''] === 'ExtendedGlucoseAnalytics';
}

export interface GlucoseManagementIndicator {
    value?: number;
    meanGlucose?: number;
    interpretation?: string;
}

export interface GlycemicRiskIndex {
    score?: number;
    hypoglycemiaComponent?: number;
    hyperglycemiaComponent?: number;
    zone?: GRIZone;
    interpretation?: string;
}

export type GRIZone = 0 | 1 | 2 | 3 | 4;

export interface TimeOfDayAnalysis {
    overnight?: PeriodMetrics;
    morning?: PeriodMetrics;
    afternoon?: PeriodMetrics;
    evening?: PeriodMetrics;
    dawnPhenomenonDetected?: boolean;
    dawnPhenomenonMagnitude?: number;
    highestVariabilityPeriod?: string;
    lowestTIRPeriod?: string;
    mostHypoglycemiaPeriod?: string;
}

export interface PeriodMetrics {
    periodName?: string;
    startHour?: number;
    endHour?: number;
    readingCount?: number;
    mean?: number;
    median?: number;
    standardDeviation?: number;
    coefficientOfVariation?: number;
    timeInRange?: number;
    timeBelowRange?: number;
    timeVeryLow?: number;
    timeAboveRange?: number;
    timeVeryHigh?: number;
    hypoglycemiaEvents?: number;
    hyperglycemiaEvents?: number;
    min?: number;
    max?: number;
}

export interface DayOfWeekAnalysis {
    dayMetrics?: { [key in DayOfWeek]?: DayMetrics; };
    weekdayAverage?: PeriodMetrics;
    weekendAverage?: PeriodMetrics;
    highestVariabilityDay?: DayOfWeek | undefined;
    lowestTIRDay?: DayOfWeek | undefined;
    weekdayWeekendDifference?: boolean;
    patternDescription?: string;
}

export type DayOfWeek = 0 | 1 | 2 | 3 | 4 | 5 | 6;

export interface DayMetrics extends PeriodMetrics {
    dayOfWeek?: DayOfWeek;
}

export function isDayMetrics(object: any): object is DayMetrics {
    return object && object[''] === 'DayMetrics';
}

export interface HypoglycemiaAnalysis {
    totalEpisodes?: number;
    severeEpisodes?: number;
    episodesPerDay?: number;
    averageDurationMinutes?: number;
    averageNadir?: number;
    lowestGlucose?: number;
    averageRecoveryTimeMinutes?: number;
    hourlyDistribution?: { [key: string]: number; };
    dayOfWeekDistribution?: { [key in DayOfWeek]?: number; };
    peakHour?: number | undefined;
    peakDay?: DayOfWeek | undefined;
    hasRecurringPattern?: boolean;
    patternDescription?: string;
    episodes?: HypoglycemiaEpisode[];
    nocturnalEpisodes?: number;
    nocturnalPercentage?: number;
    riskAssessment?: string;
}

export interface HypoglycemiaEpisode {
    startTime?: number;
    endTime?: number;
    durationMinutes?: number;
    nadirValue?: number;
    nadirTime?: number;
    isSevere?: boolean;
    hourOfDay?: number;
    dayOfWeek?: DayOfWeek;
    recoveryTimeMinutes?: number;
    preEpisodeGlucose?: number | undefined;
}

export interface HyperglycemiaAnalysis {
    totalEpisodes?: number;
    severeEpisodes?: number;
    prolongedEpisodes?: number;
    episodesPerDay?: number;
    averageDurationMinutes?: number;
    averagePeak?: number;
    highestGlucose?: number;
    averageTimeToTargetMinutes?: number;
    hourlyDistribution?: { [key: string]: number; };
    dayOfWeekDistribution?: { [key in DayOfWeek]?: number; };
    peakHour?: number | undefined;
    peakDay?: DayOfWeek | undefined;
    hasPostMealPattern?: boolean;
    patternDescription?: string;
    episodes?: HyperglycemiaEpisode[];
    nocturnalEpisodes?: number;
    nocturnalPercentage?: number;
}

export interface HyperglycemiaEpisode {
    startTime?: number;
    endTime?: number;
    durationMinutes?: number;
    peakValue?: number;
    peakTime?: number;
    isSevere?: boolean;
    isProlonged?: boolean;
    hourOfDay?: number;
    dayOfWeek?: DayOfWeek;
    timeToTargetMinutes?: number;
    averageGlucose?: number;
}

export interface ClinicalTargetAssessment {
    population?: DiabetesPopulation;
    targets?: ClinicalTargets;
    tirAssessment?: TargetAssessment;
    tbrAssessment?: TargetAssessment;
    veryLowAssessment?: TargetAssessment;
    tarAssessment?: TargetAssessment;
    veryHighAssessment?: TargetAssessment;
    cvAssessment?: TargetAssessment;
    targetsMet?: number;
    totalTargets?: number;
    overallAssessment?: string;
    actionableInsights?: string[];
    priorityAreas?: string[];
    strengths?: string[];
}

export type DiabetesPopulation = 0 | 1 | 2 | 3 | 4 | 5;

export interface ClinicalTargets {
    targetTIR?: number;
    maxTBR?: number;
    maxTBRVeryLow?: number;
    maxTAR?: number;
    maxTARVeryHigh?: number;
    targetCV?: number;
    targetLow?: number;
    targetHigh?: number;
}

export interface TargetAssessment {
    metricName?: string;
    currentValue?: number;
    targetValue?: number;
    isMaximumTarget?: boolean;
    status?: TargetStatus;
    differenceFromTarget?: number;
    progressPercentage?: number;
}

export type TargetStatus = 0 | 1 | 2;

export interface DataSufficiencyAssessment {
    isSufficient?: boolean;
    totalDays?: number;
    daysWithData?: number;
    expectedReadings?: number;
    actualReadings?: number;
    completenessPercentage?: number;
    minimumRequiredCompleteness?: number;
    averageReadingsPerDay?: number;
    longestGapHours?: number;
    warningMessage?: string;
    recommendation?: string;
}

/** Request model for extended glucose analytics with GMI, GRI, and clinical assessment */
export interface ExtendedGlucoseAnalyticsRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional collection of treatments */
    treatments?: Treatment[] | undefined;
    /** Diabetes population type for clinical target assessment */
    population?: DiabetesPopulation;
    /** Optional extended analysis configuration */
    config?: ExtendedAnalysisConfig | undefined;
}

/** Request model for clinical assessment */
export interface ClinicalAssessmentRequest {
    /** Glucose analytics to assess */
    analytics?: GlucoseAnalytics;
    /** Diabetes population type for clinical target assessment */
    population?: DiabetesPopulation;
}

/** Request model for data sufficiency assessment */
export interface DataSufficiencyRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Number of days to assess (default: 14) */
    days?: number;
    /** Expected readings per day based on sensor type (default: 288 for 5-minute intervals) */
    expectedReadingsPerDay?: number;
}

export interface MultiPeriodStatistics {
    lastDay?: PeriodStatistics;
    last3Days?: PeriodStatistics;
    lastWeek?: PeriodStatistics;
    lastMonth?: PeriodStatistics;
    last90Days?: PeriodStatistics;
    lastUpdated?: Date;
}

export interface PeriodStatistics {
    periodDays?: number;
    startDate?: Date;
    endDate?: Date;
    analytics?: GlucoseAnalytics | undefined;
    treatmentSummary?: TreatmentSummary | undefined;
    hasSufficientData?: boolean;
    entryCount?: number;
    treatmentCount?: number;
}

export interface VersionsResponse {
    versions?: string[];
}

/** Proxy configuration DTO */
export interface ProxyConfigurationDto {
    nightscoutUrl?: string;
    defaultStrategy?: string;
    enableDetailedLogging?: boolean;
}

export interface CompatibilityMetrics {
    totalRequests?: number;
    perfectMatches?: number;
    minorDifferences?: number;
    majorDifferences?: number;
    criticalDifferences?: number;
    compatibilityScore?: number;
    averageNightscoutResponseTime?: number;
    averageNocturneResponseTime?: number;
}

export interface EndpointMetrics {
    endpoint?: string;
    totalRequests?: number;
    perfectMatches?: number;
    minorDifferences?: number;
    majorDifferences?: number;
    criticalDifferences?: number;
    compatibilityScore?: number;
    averageNightscoutResponseTime?: number;
    averageNocturneResponseTime?: number;
}

/** Analyses list response */
export interface AnalysesListResponse {
    analyses?: AnalysisListItemDto[];
    total?: number;
}

/** Analysis list item DTO */
export interface AnalysisListItemDto {
    id?: string;
    correlationId?: string;
    analysisTimestamp?: Date;
    requestMethod?: string;
    requestPath?: string;
    overallMatch?: ResponseMatchType;
    statusCodeMatch?: boolean;
    bodyMatch?: boolean;
    nightscoutStatusCode?: number | undefined;
    nocturneStatusCode?: number | undefined;
    nightscoutResponseTimeMs?: number | undefined;
    nocturneResponseTimeMs?: number | undefined;
    totalProcessingTimeMs?: number;
    summary?: string;
    criticalDiscrepancyCount?: number;
    majorDiscrepancyCount?: number;
    minorDiscrepancyCount?: number;
    nightscoutMissing?: boolean;
    nocturneMissing?: boolean;
}

export type ResponseMatchType = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;

/** Analysis detail DTO */
export interface AnalysisDetailDto {
    id?: string;
    correlationId?: string;
    analysisTimestamp?: Date;
    requestMethod?: string;
    requestPath?: string;
    overallMatch?: ResponseMatchType;
    statusCodeMatch?: boolean;
    bodyMatch?: boolean;
    nightscoutStatusCode?: number | undefined;
    nocturneStatusCode?: number | undefined;
    nightscoutResponseTimeMs?: number | undefined;
    nocturneResponseTimeMs?: number | undefined;
    totalProcessingTimeMs?: number;
    summary?: string;
    selectedResponseTarget?: string | undefined;
    selectionReason?: string | undefined;
    criticalDiscrepancyCount?: number;
    majorDiscrepancyCount?: number;
    minorDiscrepancyCount?: number;
    nightscoutMissing?: boolean;
    nocturneMissing?: boolean;
    errorMessage?: string | undefined;
    discrepancies?: DiscrepancyDetailDto[];
}

export interface DiscrepancyDetailDto {
    id?: string;
    discrepancyType?: number;
    severity?: number;
    field?: string;
    nightscoutValue?: string;
    nocturneValue?: string;
    description?: string;
    recordedAt?: Date;
}

export interface MigrationReadinessReport {
    generatedAt?: Date;
    periodStart?: Date | undefined;
    periodEnd?: Date | undefined;
    overallCompatibilityScore?: number;
    totalRequestsAnalyzed?: number;
    criticalIssues?: number;
    majorIssues?: number;
    minorIssues?: number;
    readinessLevel?: MigrationReadinessLevel;
    recommendation?: string;
    riskAreas?: string[];
    performanceRatio?: number | undefined;
    performanceWarning?: string | undefined;
    performanceNote?: string | undefined;
}

export type MigrationReadinessLevel = 0 | 1 | 2 | 3;

export interface V3CollectionResponseOfObject {
    status?: string;
    data?: any[];
    total?: number | undefined;
    skip?: number | undefined;
    limit?: number | undefined;
    meta?: V3ResponseMetadata;
}

export interface V3ResponseMetadata {
    timestamp?: Date;
    version?: string;
    executionTime?: number | undefined;
    requestId?: string | undefined;
    eTag?: string | undefined;
    lastModified?: Date | undefined;
    totalCount?: number;
    limit?: number;
    offset?: number;
}

export interface V3ErrorResponse {
    status?: string;
    message?: string;
    code?: string | undefined;
    timestamp?: Date | undefined;
    path?: string | undefined;
    details?: { [key: string]: any; } | undefined;
}

export interface DeviceStatus extends ProcessableDocumentBase {
    _id?: string | undefined;
    mills?: number;
    created_at?: string | undefined;
    utcOffset?: number | undefined;
    device?: string;
    isCharging?: boolean | undefined;
    uploader?: UploaderStatus | undefined;
    pump?: PumpStatus | undefined;
    openaps?: OpenApsStatus | undefined;
    loop?: LoopStatus | undefined;
    xdripjs?: XDripJsStatus | undefined;
    radioAdapter?: RadioAdapterStatus | undefined;
    connect?: any | undefined;
    override?: OverrideStatus | undefined;
    cgm?: CgmStatus | undefined;
    meter?: MeterStatus | undefined;
    insulinPen?: InsulinPenStatus | undefined;
}

export function isDeviceStatus(object: any): object is DeviceStatus {
    return object && object[''] === 'DeviceStatus';
}

export interface UploaderStatus {
    battery?: number | undefined;
    batteryVoltage?: number | undefined;
    temperature?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
}

export interface PumpStatus {
    battery?: PumpBattery | undefined;
    reservoir?: number | undefined;
    clock?: string | undefined;
    status?: PumpStatusDetails | undefined;
    iob?: PumpIob | undefined;
}

export interface PumpBattery {
    percent?: number | undefined;
    voltage?: number | undefined;
}

export interface PumpStatusDetails {
    status?: string | undefined;
    bolusing?: boolean | undefined;
    suspended?: boolean | undefined;
}

export interface PumpIob {
    timestamp?: string | undefined;
    bolusiob?: number | undefined;
    basaliob?: number | undefined;
    iob?: number | undefined;
}

export interface OpenApsStatus {
    suggested?: any | undefined;
    enacted?: any | undefined;
    iob?: any | undefined;
    cob?: number | undefined;
}

export interface LoopStatus {
    iob?: LoopIob | undefined;
    cob?: number | undefined;
    predicted?: any | undefined;
    recommended?: any | undefined;
    enacted?: any | undefined;
}

export interface LoopIob {
    timestamp?: string | undefined;
    iob?: number | undefined;
}

export interface XDripJsStatus {
    state?: number | undefined;
    stateString?: string | undefined;
    voltagea?: number | undefined;
    voltageb?: number | undefined;
}

export interface RadioAdapterStatus {
    pumpRSSI?: number | undefined;
    RSSI?: number | undefined;
}

export interface OverrideStatus {
    timestamp?: number | undefined;
    duration?: number | undefined;
    active?: boolean | undefined;
    multiplier?: number | undefined;
    currentCorrectionRange?: CorrectionRange | undefined;
}

export interface CorrectionRange {
    maxValue?: number | undefined;
    minValue?: number | undefined;
}

export interface CgmStatus {
    sensorAge?: string | undefined;
    transmitterAge?: string | undefined;
    signalStrength?: number | undefined;
    calibrationStatus?: string | undefined;
    lastReading?: Date | undefined;
    sensorState?: string | undefined;
    sessionTimeRemaining?: number | undefined;
    transmitterBattery?: number | undefined;
}

export interface MeterStatus {
    batteryLevel?: number | undefined;
    testStripsRemaining?: number | undefined;
    lastReading?: Date | undefined;
    clockStatus?: string | undefined;
    meterModel?: string | undefined;
    memoryUsage?: number | undefined;
}

export interface InsulinPenStatus {
    batteryLevel?: number | undefined;
    cartridgeRemaining?: number | undefined;
    lastInjection?: Date | undefined;
    penModel?: string | undefined;
    insulinType?: string | undefined;
    needleAttached?: boolean | undefined;
    cartridgeExpiration?: Date | undefined;
}

export interface DiscrepancyAnalysisDto {
    id?: string;
    correlationId?: string;
    analysisTimestamp?: Date;
    requestMethod?: string;
    requestPath?: string;
    overallMatch?: number;
    statusCodeMatch?: boolean;
    bodyMatch?: boolean;
    nightscoutStatusCode?: number | undefined;
    nocturneStatusCode?: number | undefined;
    nightscoutResponseTimeMs?: number | undefined;
    nocturneResponseTimeMs?: number | undefined;
    totalProcessingTimeMs?: number;
    summary?: string;
    selectedResponseTarget?: string | undefined;
    selectionReason?: string | undefined;
    criticalDiscrepancyCount?: number;
    majorDiscrepancyCount?: number;
    minorDiscrepancyCount?: number;
    nightscoutMissing?: boolean;
    nocturneMissing?: boolean;
    errorMessage?: string | undefined;
    discrepancies?: DiscrepancyDetailDto[];
}

export interface CompatibilityStatus {
    overallScore?: number;
    totalRequests?: number;
    healthStatus?: string;
    lastUpdated?: Date;
    criticalIssues?: number;
    majorIssues?: number;
    minorIssues?: number;
}

export interface Food {
    _id?: string | undefined;
    type?: string;
    category?: string;
    subcategory?: string;
    name?: string;
    portion?: number;
    carbs?: number;
    fat?: number;
    protein?: number;
    energy?: number;
    gi?: number;
    unit?: string;
    foods?: QuickPickFood[] | undefined;
    hideafteruse?: boolean;
    hidden?: boolean;
    position?: number;
}

export interface QuickPickFood {
    name?: string;
    portion?: number;
    carbs?: number;
    unit?: string;
    portions?: number;
}

export interface LastModifiedResponse {
    entries?: Date | undefined;
    treatments?: Date | undefined;
    profile?: Date | undefined;
    deviceStatus?: Date | undefined;
    food?: Date | undefined;
    settings?: Date | undefined;
    activity?: Date | undefined;
    serverTime?: Date;
    additional?: { [key: string]: Date; };
}

export interface Profile {
    _id?: string | undefined;
    defaultProfile?: string;
    startDate?: string;
    mills?: number;
    created_at?: string | undefined;
    units?: string;
    store?: { [key: string]: ProfileData; };
}

export interface ProfileData {
    dia?: number;
    carbs_hr?: number;
    delay?: number;
    timezone?: string | undefined;
    units?: string | undefined;
    perGIvalues?: boolean | undefined;
    carbs_hr_high?: number | undefined;
    carbs_hr_medium?: number | undefined;
    carbs_hr_low?: number | undefined;
    delay_high?: number | undefined;
    delay_medium?: number | undefined;
    delay_low?: number | undefined;
    basal?: TimeValue[];
    carbratio?: TimeValue[];
    sens?: TimeValue[];
    target_low?: TimeValue[];
    target_high?: TimeValue[];
}

export interface TimeValue {
    time?: string;
    value?: number;
}

export interface Settings extends ProcessableDocumentBase {
    _id?: string | undefined;
    key: string;
    value?: any | undefined;
    created_at?: string | undefined;
    mills?: number;
    utcOffset?: number | undefined;
    srvCreated?: Date | undefined;
    srvModified?: Date | undefined;
    app?: string | undefined;
    device?: string | undefined;
    enteredBy?: string | undefined;
    version?: number | undefined;
    isActive?: boolean;
    notes?: string | undefined;
}

export function isSettings(object: any): object is Settings {
    return object && object[''] === 'Settings';
}

export interface V3StatusResponse {
    status?: string;
    name?: string;
    version?: string;
    serverTime?: Date;
    apiEnabled?: boolean;
    careportalEnabled?: boolean;
    head?: string;
    settings?: { [key: string]: any; };
    extended?: ExtendedStatusInfo;
}

export interface ExtendedStatusInfo {
    authorization?: AuthorizationInfo;
    permissions?: { [key: string]: boolean; };
    uptimeMs?: number;
    collections?: string[];
    apiVersions?: { [key: string]: boolean; };
}

export interface AuthorizationInfo {
    isAuthorized?: boolean;
    scope?: string[];
    subject?: string | undefined;
    roles?: string[];
}

export interface VersionResponse {
    version?: string;
    name?: string;
    serverTime?: Date;
    head?: string;
}

export interface DDataResponse {
    devicestatus?: DeviceStatus[];
    sgvs?: Entry[];
    cals?: Entry[];
    profiles?: Profile[];
    mbgs?: Entry[];
    food?: Food[];
    treatments?: Treatment[];
    dbstats?: DbStats;
}

export interface DbStats {
    dataSize?: number;
    collections?: number;
    indexes?: number;
}

export interface DData {
    sgvs?: Entry[];
    treatments?: Treatment[];
    mbgs?: Entry[];
    cals?: Entry[];
    cal?: Entry | undefined;
    profiles?: Profile[];
    devicestatus?: DeviceStatus[];
    food?: Food[];
    activity?: Activity[];
    dbstats?: DbStats;
    lastUpdated?: number;
    inRetroMode?: boolean | undefined;
    sitechangeTreatments?: Treatment[];
    insulinchangeTreatments?: Treatment[];
    batteryTreatments?: Treatment[];
    sensorTreatments?: Treatment[];
    combobolusTreatments?: Treatment[];
    profileTreatments?: Treatment[];
    tempbasalTreatments?: Treatment[];
    tempTargetTreatments?: Treatment[];
}

export interface Activity extends ProcessableDocumentBase {
    _id?: string | undefined;
    created_at?: string | undefined;
    timestamp?: number | undefined;
    mills?: number;
    utcOffset?: number | undefined;
    type?: string | undefined;
    description?: string | undefined;
    duration?: number | undefined;
    intensity?: string | undefined;
    notes?: string | undefined;
    enteredBy?: string | undefined;
    dateString?: string | undefined;

    [key: string]: any;
}

export function isActivity(object: any): object is Activity {
    return object && object[''] === 'Activity';
}

export interface LoopNotificationResponse {
    success?: boolean;
    message?: string;
    timestamp?: number;
    data?: any | undefined;
}

/** Loop notification request model for the direct Loop endpoint Combines the data and loopSettings for a complete notification request */
export interface LoopSendRequest {
    /** Loop notification data (matches legacy data structure) */
    data?: LoopNotificationData;
    /** Loop settings from user profile containing device token and bundle ID */
    loopSettings?: LoopSettings;
}

export interface LoopNotificationData {
    eventType?: string;
    notes?: string | undefined;
    enteredBy?: string | undefined;
    reason?: string | undefined;
    reasonDisplay?: string | undefined;
    duration?: string | undefined;
    remoteCarbs?: string | undefined;
    remoteAbsorption?: string | undefined;
    remoteBolus?: string | undefined;
    otp?: string | undefined;
    created_at?: string | undefined;
}

export interface LoopSettings {
    deviceToken?: string | undefined;
    bundleIdentifier?: string | undefined;
}

export interface NotificationV2Response {
    success?: boolean;
    message?: string;
    data?: any | undefined;
    timestamp?: number;
}

export interface LoopNotificationRequest {
    type?: string;
    message?: string;
    title?: string | undefined;
    urgency?: string | undefined;
    sound?: string | undefined;
    group?: string | undefined;
    timestamp?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    isAnnouncement?: boolean | undefined;
}

export interface NotificationBase {
    level?: number;
    title?: string;
    message?: string;
    group?: string;
    timestamp?: number;
    plugin?: string | undefined;
    isAnnouncement?: boolean;
    debug?: any | undefined;
    count?: number;
    lastRecorded?: number;
    persistent?: boolean;
    clear?: boolean;
}

export interface SummaryResponse {
    sgvs?: SummarySgv[];
    treatments?: SummaryTreatments;
    profile?: any | undefined;
    state?: SummaryState;
}

export interface SummarySgv {
    sgv?: number;
    mills?: number;
    noise?: number | undefined;
}

export interface SummaryTreatments {
    tempBasals?: SummaryTempBasal[];
    treatments?: SummaryTreatment[];
    targets?: SummaryTarget[];
}

export interface SummaryTempBasal {
    start?: number;
    duration?: number;
    absolute?: number;
    profile?: number | undefined;
}

export interface SummaryTreatment {
    mills?: number;
    carbs?: number | undefined;
    insulin?: number | undefined;
}

export interface SummaryTarget {
    targetTop?: number;
    targetBottom?: number;
    duration?: number;
    mills?: number;
}

export interface SummaryState {
    iob?: number;
    cob?: number;
    bwp?: number;
    cage?: number | undefined;
    sage?: number | undefined;
    iage?: number | undefined;
    bage?: number | undefined;
    battery?: number | undefined;
    calib_age?: number | undefined;
    sensor_expires_in?: number | undefined;
}

export interface AlexaResponse {
    version?: string;
    sessionAttributes?: { [key: string]: any; };
    response?: AlexaResponseBody;
}

export interface AlexaResponseBody {
    outputSpeech?: AlexaOutputSpeech | undefined;
    shouldEndSession?: boolean;
    card?: AlexaCard | undefined;
    reprompt?: AlexaReprompt | undefined;
}

export interface AlexaOutputSpeech {
    type?: string;
    text?: string;
    ssml?: string | undefined;
}

export interface AlexaCard {
    type?: string;
    title?: string;
    content?: string;
    text?: string | undefined;
    smallImageUrl?: string | undefined;
    largeImageUrl?: string | undefined;
}

export interface AlexaReprompt {
    outputSpeech?: AlexaOutputSpeech | undefined;
}

export interface AlexaRequest {
    version?: string;
    session?: AlexaSession;
    request?: AlexaRequestDetails;
}

export interface AlexaSession {
    sessionId?: string;
    new?: boolean;
    attributes?: { [key: string]: any; };
    user?: AlexaUser;
}

export interface AlexaUser {
    userId?: string;
}

export interface AlexaRequestDetails {
    type?: string;
    requestId?: string;
    timestamp?: Date;
    intent?: AlexaIntent | undefined;
    locale?: string;
}

export interface AlexaIntent {
    name?: string;
    slots?: { [key: string]: AlexaSlot; };
}

export interface AlexaSlot {
    name?: string;
    value?: string;
}

/** Response object for count endpoints */
export interface CountResponse {
    /** Number of records matching the query criteria */
    count?: number;
}

export interface DeviceAgeInfo {
    found?: boolean;
    age?: number;
    days?: number;
    hours?: number;
    treatmentDate?: number | undefined;
    notes?: string | undefined;
    minFractions?: number;
    level?: number;
    display?: string;
    notification?: DeviceAgeNotification | undefined;
}

export interface DeviceAgeNotification {
    title?: string;
    message?: string;
    pushoverSound?: string;
    level?: number;
    group?: string;
}

export interface SensorAgeInfo {
    "Sensor Start"?: DeviceAgeInfo;
    "Sensor Change"?: DeviceAgeInfo;
    min?: string;
}

export interface DeviceAlert {
    id?: string;
    deviceId?: string;
    userId?: string;
    alertType?: DeviceAlertType;
    severity?: DeviceIssueSeverity;
    title?: string;
    message?: string;
    triggerTime?: Date;
    acknowledged?: boolean;
    acknowledgedAt?: Date | undefined;
    data?: { [key: string]: any; } | undefined;
}

export type DeviceAlertType = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;

export type DeviceIssueSeverity = 0 | 1 | 2 | 3;

/** Device alert summary model */
export interface DeviceAlertSummary {
    /** Total number of registered devices */
    totalDevices?: number;
    /** Number of active alerts */
    activeAlerts?: number;
    /** Number of critical alerts */
    criticalAlerts?: number;
    /** Number of warning alerts */
    warningAlerts?: number;
    /** Alerts grouped by type */
    alertsByType?: { [key in DeviceAlertType]?: number; };
}

/** Device alert settings model */
export interface DeviceAlertSettings {
    /** Enable email notifications */
    emailEnabled?: boolean;
    /** Enable push notifications */
    pushEnabled?: boolean;
    /** Enable SMS notifications */
    smsEnabled?: boolean;
    /** Enable quiet hours */
    quietHoursEnabled?: boolean;
    /** Quiet hours start time */
    quietHoursStart?: string;
    /** Quiet hours end time */
    quietHoursEnd?: string;
    /** Critical alerts override quiet hours */
    criticalAlertsOverrideQuietHours?: boolean;
    /** Battery low threshold percentage */
    batteryLowThreshold?: number;
    /** Sensor expiration warning hours */
    sensorExpirationWarningHours?: number;
    /** Data gap warning minutes */
    dataGapWarningMinutes?: number;
    /** Calibration reminder hours */
    calibrationReminderHours?: number;
}

export interface DeviceHealth {
    id?: string;
    userId?: string;
    deviceId?: string;
    deviceType?: DeviceType;
    deviceName?: string;
    manufacturer?: string | undefined;
    model?: string | undefined;
    serialNumber?: string | undefined;
    batteryLevel?: number | undefined;
    sensorExpiration?: Date | undefined;
    lastCalibration?: Date | undefined;
    lastDataReceived?: Date | undefined;
    lastMaintenanceAlert?: Date | undefined;
    batteryWarningThreshold?: number;
    sensorExpirationWarningHours?: number;
    dataGapWarningMinutes?: number;
    calibrationReminderHours?: number;
    status?: DeviceStatusType;
    lastErrorMessage?: string | undefined;
    lastStatusUpdate?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export type DeviceType = 0 | 1 | 2 | 3;

export type DeviceStatusType = 0 | 1 | 2 | 3 | 4;

export interface DeviceRegistrationRequest {
    deviceId?: string;
    deviceType?: DeviceType;
    deviceName?: string;
    manufacturer?: string | undefined;
    model?: string | undefined;
    serialNumber?: string | undefined;
    batteryLevel?: number | undefined;
    sensorExpiration?: Date | undefined;
}

export interface DeviceHealthAnalysis {
    deviceId?: string;
    healthScore?: number;
    healthStatus?: DeviceHealthStatus;
    timestamp?: Date;
    issues?: DeviceHealthIssue[];
    recommendations?: string[];
    nextMaintenanceDate?: Date | undefined;
}

export type DeviceHealthStatus = 0 | 1 | 2 | 3 | 4;

export interface DeviceHealthIssue {
    type?: DeviceIssueType;
    severity?: DeviceIssueSeverity;
    description?: string;
    detectedAt?: Date;
    suggestedResolution?: string | undefined;
}

export type DeviceIssueType = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;

export interface DeviceSettingsUpdate {
    batteryWarningThreshold?: number | undefined;
    sensorExpirationWarningHours?: number | undefined;
    dataGapWarningMinutes?: number | undefined;
    calibrationReminderHours?: number | undefined;
}

export interface DeviceHealthUpdate {
    batteryLevel?: number | undefined;
    sensorExpiration?: Date | undefined;
    lastCalibration?: Date | undefined;
    status?: DeviceStatusType | undefined;
    lastErrorMessage?: string | undefined;
    deviceSpecificData?: { [key: string]: any; } | undefined;
}

export interface DeviceHealthReport {
    deviceId?: string;
    periodStart?: Date;
    periodEnd?: Date;
    averageHealthScore?: number;
    uptimePercentage?: number;
    totalAlerts?: number;
    healthTrend?: HealthTrend;
    keyMetrics?: { [key: string]: any; };
}

export type HealthTrend = 0 | 1 | 2 | 3;

export interface MaintenancePrediction {
    deviceId?: string;
    predictedMaintenanceDate?: Date;
    confidenceLevel?: number;
    maintenanceType?: MaintenanceType;
    reasons?: string[];
}

export type MaintenanceType = 0 | 1 | 2 | 3 | 4;

export interface AsyncProcessingResponse {
    correlationId?: string;
    status?: string;
    statusUrl?: string;
    estimatedProcessingTime?: string;
    estimatedCompletion?: Date | undefined;
}

export interface IobResult {
    iob?: number;
    activity?: number | undefined;
    lastBolus?: Treatment | undefined;
    source?: string | undefined;
    device?: string | undefined;
    mills?: number | undefined;
    basalIob?: number | undefined;
    treatmentIob?: number | undefined;
    display?: string | undefined;
    displayLine?: string | undefined;
}

/** Response model for hourly IOB breakdown */
export interface HourlyIobResponse {
    startTime?: number;
    endTime?: number;
    intervalMinutes?: number;
    hours?: number;
    data?: HourlyIobData[];
}

/** Individual hourly IOB data point */
export interface HourlyIobData {
    timeSlot?: number;
    hour?: number;
    minute?: number;
    timeLabel?: string;
    totalIOB?: number;
    bolusIOB?: number;
    basalIOB?: number;
}

export interface NotificationAckResponse {
    success?: boolean;
    message?: string;
    timestamp?: number;
}

export interface NotificationAckRequest {
    level?: number;
    group?: string;
    time?: number | undefined;
    sendClear?: boolean | undefined;
}

export interface PushoverCallbackRequest {
    receipt?: string | undefined;
    status?: number | undefined;
    acknowledged_at?: number | undefined;
    acknowledged_by?: string | undefined;
    user_key?: string | undefined;
    callback?: string | undefined;
}

export interface AdminNotifiesResponse {
    status?: number;
    message?: AdminNotifiesMessage;
}

export interface AdminNotifiesMessage {
    notifies?: AdminNotification[];
    notifyCount?: number;
}

export interface AdminNotification {
    title?: string;
    message?: string;
    count?: number;
    lastRecorded?: number;
    persistent?: boolean;
}

export interface PushoverNotificationRequest {
    title?: string;
    message?: string;
    level?: number | undefined;
    group?: string | undefined;
    priority?: number | undefined;
    sound?: string | undefined;
    device?: string | undefined;
    url?: string | undefined;
    urlTitle?: string | undefined;
    retry?: number | undefined;
    expire?: number | undefined;
}

export interface ProcessingStatus {
    correlationId?: string;
    status?: string;
    progress?: number;
    processedCount?: number;
    totalCount?: number;
    startedAt?: Date;
    completedAt?: Date | undefined;
    errors?: string[];
    results?: any | undefined;
}

export interface ProcessingStatusResponse extends ProcessingStatus {
}

export function isProcessingStatusResponse(object: any): object is ProcessingStatusResponse {
    return object && object[''] === 'ProcessingStatusResponse';
}

export interface StatusResponse {
    status?: string;
    name?: string | undefined;
    version?: string | undefined;
    apiVersion?: string | undefined;
    serverTime?: Date;
    serverTimeEpoch?: number;
    enabled?: string[] | undefined;
    apiEnabled?: boolean;
    roles?: string[] | undefined;
    settings?: { [key: string]: any; } | undefined;
    extendedSettings?: { [key: string]: any; } | undefined;
    careportalEnabled?: boolean | undefined;
    head?: string | undefined;
}

export interface TimeQueryEcho {
    req?: TimeQueryRequest;
    pattern?: string[];
    query?: { [key: string]: any; };
}

export interface TimeQueryRequest {
    params?: { [key: string]: string; };
    query?: { [key: string]: any; };
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}