//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AnalyticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current analytics configuration and status
     * @return Analytics configuration and collection status
     */
    getAnalyticsStatus(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnalyticsStatus(_response);
        });
    }

    protected processGetAnalyticsStatus(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get current performance metrics
     * @return System performance metrics
     */
    getPerformanceMetrics(signal?: AbortSignal): Promise<PerformanceMetrics> {
        let url_ = this.baseUrl + "/api/Analytics/metrics/performance";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPerformanceMetrics(_response);
        });
    }

    protected processGetPerformanceMetrics(response: Response): Promise<PerformanceMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PerformanceMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PerformanceMetrics>(null as any);
    }

    /**
     * Get current usage statistics
     * @return Usage statistics
     */
    getUsageStatistics(signal?: AbortSignal): Promise<UsageStatistics> {
        let url_ = this.baseUrl + "/api/Analytics/metrics/usage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsageStatistics(_response);
        });
    }

    protected processGetUsageStatistics(response: Response): Promise<UsageStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsageStatistics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsageStatistics>(null as any);
    }

    /**
     * Get pending analytics data that would be transmitted (for transparency)
     * @return Pending analytics data or null if none
     */
    getPendingAnalyticsData(signal?: AbortSignal): Promise<AnalyticsBatch> {
        let url_ = this.baseUrl + "/api/Analytics/data/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPendingAnalyticsData(_response);
        });
    }

    protected processGetPendingAnalyticsData(response: Response): Promise<AnalyticsBatch> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticsBatch;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticsBatch>(null as any);
    }

    /**
     * Update analytics collection configuration
     * @param config New analytics configuration
     * @return Updated configuration
     */
    updateAnalyticsConfig(config: AnalyticsCollectionConfig, signal?: AbortSignal): Promise<AnalyticsCollectionConfig> {
        let url_ = this.baseUrl + "/api/Analytics/config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAnalyticsConfig(_response);
        });
    }

    protected processUpdateAnalyticsConfig(response: Response): Promise<AnalyticsCollectionConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticsCollectionConfig;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticsCollectionConfig>(null as any);
    }

    /**
     * Clear all stored analytics data
     * @return Confirmation message
     */
    clearAnalyticsData(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearAnalyticsData(_response);
        });
    }

    protected processClearAnalyticsData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get information about what data is collected and privacy policy
     * @return Privacy and data collection information
     */
    getPrivacyInformation(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/privacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPrivacyInformation(_response);
        });
    }

    protected processGetPrivacyInformation(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Track a custom analytics event (for testing or manual tracking)
     * @param eventData Custom event data
     * @return Confirmation message
     */
    trackCustomEvent(eventData: AnalyticsEvent, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Analytics/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrackCustomEvent(_response);
        });
    }

    protected processTrackCustomEvent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Verify authentication status and permissions for the current request
    This endpoint provides 1:1 compatibility with Nightscout's /api/v1/verifyauth endpoint
     * @return Authentication status and permission information
     */
    verifyAuthentication(signal?: AbortSignal): Promise<VerifyAuthResponse> {
        let url_ = this.baseUrl + "/api/v1/verifyauth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerifyAuthentication(_response);
        });
    }

    protected processVerifyAuthentication(response: Response): Promise<VerifyAuthResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VerifyAuthResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerifyAuthResponse>(null as any);
    }
}

export class AuthorizationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Generate JWT token from access token
     * @param accessToken Access token to exchange for JWT
     * @return JWT token response
     */
    generateJwtFromAccessToken(accessToken: string, signal?: AbortSignal): Promise<AuthorizationResponse> {
        let url_ = this.baseUrl + "/api/v2/authorization/request/{accessToken}";
        if (accessToken === undefined || accessToken === null)
            throw new globalThis.Error("The parameter 'accessToken' must be defined.");
        url_ = url_.replace("{accessToken}", encodeURIComponent("" + accessToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateJwtFromAccessToken(_response);
        });
    }

    protected processGenerateJwtFromAccessToken(response: Response): Promise<AuthorizationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorizationResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorizationResponse>(null as any);
    }

    /**
     * Get all permissions that have been seen by the system
     * @return List of permissions with usage statistics
     */
    getAllPermissions(signal?: AbortSignal): Promise<PermissionsResponse> {
        let url_ = this.baseUrl + "/api/v2/authorization/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: Response): Promise<PermissionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionsResponse>(null as any);
    }

    /**
     * Get permission hierarchy structure as a trie
     * @return Permission trie structure
     */
    getPermissionTrie(signal?: AbortSignal): Promise<PermissionTrieResponse> {
        let url_ = this.baseUrl + "/api/v2/authorization/permissions/trie";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissionTrie(_response);
        });
    }

    protected processGetPermissionTrie(response: Response): Promise<PermissionTrieResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionTrieResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionTrieResponse>(null as any);
    }

    /**
     * Get all subjects (users/devices)
     * @return List of all subjects
     */
    getAllSubjects(signal?: AbortSignal): Promise<Subject[]> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSubjects(_response);
        });
    }

    protected processGetAllSubjects(response: Response): Promise<Subject[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subject[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subject[]>(null as any);
    }

    /**
     * Create a new subject
     * @param subject Subject to create
     * @return Created subject
     */
    createSubject(subject: Subject, signal?: AbortSignal): Promise<Subject> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subject);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSubject(_response);
        });
    }

    protected processCreateSubject(response: Response): Promise<Subject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subject;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subject>(null as any);
    }

    /**
     * Update an existing subject
     * @param subject Subject to update
     * @return Updated subject
     */
    updateSubject(subject: Subject, signal?: AbortSignal): Promise<Subject> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subject);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSubject(_response);
        });
    }

    protected processUpdateSubject(response: Response): Promise<Subject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subject;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subject>(null as any);
    }

    /**
     * Delete a subject by ID
     * @param id Subject ID to delete
     * @return Success response
     */
    deleteSubject(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/authorization/subjects/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSubject(_response);
        });
    }

    protected processDeleteSubject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all roles
     * @return List of all roles
     */
    getAllRoles(signal?: AbortSignal): Promise<Role[]> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[]>(null as any);
    }

    /**
     * Create a new role
     * @param role Role to create
     * @return Created role
     */
    createRole(role: Role, signal?: AbortSignal): Promise<Role> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * Update an existing role
     * @param role Role to update
     * @return Updated role
     */
    updateRole(role: Role, signal?: AbortSignal): Promise<Role> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * Delete a role by ID
     * @param id Role ID to delete
     * @return Success response
     */
    deleteRole(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/authorization/roles/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ConnectorStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Gets the current status and metrics for all registered connectors
     */
    getStatus(signal?: AbortSignal): Promise<ConnectorStatusDto[]> {
        let url_ = this.baseUrl + "/api/v1/connectors/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<ConnectorStatusDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorStatusDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorStatusDto[]>(null as any);
    }
}

export class LocalAuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get local identity provider configuration
     */
    getConfig(signal?: AbortSignal): Promise<LocalAuthConfigResponse> {
        let url_ = this.baseUrl + "/auth/local/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: Response): Promise<LocalAuthConfigResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LocalAuthConfigResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LocalAuthConfigResponse>(null as any);
    }

    /**
     * Register a new user account
     */
    register(request: RegisterRequest, signal?: AbortSignal): Promise<RegisterResponse> {
        let url_ = this.baseUrl + "/auth/local/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<RegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterResponse>(null as any);
    }

    /**
     * Log in with email and password
     */
    login(request: LoginRequest, signal?: AbortSignal): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/auth/local/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Verify email address
     * @param token (optional) 
     */
    verifyEmail(token?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/auth/local/verify-email?";
        if (token === null)
            throw new globalThis.Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerifyEmail(_response);
        });
    }

    protected processVerifyEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Request password reset
     */
    forgotPassword(request: ForgotPasswordRequest, signal?: AbortSignal): Promise<ForgotPasswordResponse> {
        let url_ = this.baseUrl + "/auth/local/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<ForgotPasswordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ForgotPasswordResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ForgotPasswordResponse>(null as any);
    }

    /**
     * Reset password with token
     */
    resetPassword(request: ResetPasswordRequest, signal?: AbortSignal): Promise<ResetPasswordResponse> {
        let url_ = this.baseUrl + "/auth/local/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<ResetPasswordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResetPasswordResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResetPasswordResponse>(null as any);
    }

    /**
     * Change password for authenticated user
     */
    changePassword(request: ChangePasswordRequest, signal?: AbortSignal): Promise<ChangePasswordResponse> {
        let url_ = this.baseUrl + "/auth/local/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<ChangePasswordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangePasswordResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangePasswordResponse>(null as any);
    }

    /**
     * Check if email is allowed to register (for form validation)
     * @param email (optional) 
     */
    checkEmail(email?: string | undefined, signal?: AbortSignal): Promise<CheckEmailResponse> {
        let url_ = this.baseUrl + "/auth/local/check-email?";
        if (email === null)
            throw new globalThis.Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckEmail(_response);
        });
    }

    protected processCheckEmail(response: Response): Promise<CheckEmailResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckEmailResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckEmailResponse>(null as any);
    }

    /**
     * Resend email verification
     */
    resendVerification(request: ResendVerificationRequest, signal?: AbortSignal): Promise<ResendVerificationResponse> {
        let url_ = this.baseUrl + "/auth/local/resend-verification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendVerification(_response);
        });
    }

    protected processResendVerification(response: Response): Promise<ResendVerificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResendVerificationResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResendVerificationResponse>(null as any);
    }

    /**
     * Get pending password reset requests (admin only)
     */
    getPendingPasswordResets(signal?: AbortSignal): Promise<PasswordResetRequestListResponse> {
        let url_ = this.baseUrl + "/auth/local/admin/password-resets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPendingPasswordResets(_response);
        });
    }

    protected processGetPendingPasswordResets(response: Response): Promise<PasswordResetRequestListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PasswordResetRequestListResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PasswordResetRequestListResponse>(null as any);
    }

    /**
     * Set a temporary password for a user (admin only)
     */
    setTemporaryPassword(request: SetTemporaryPasswordRequest, signal?: AbortSignal): Promise<SetTemporaryPasswordResponse> {
        let url_ = this.baseUrl + "/auth/local/admin/set-temporary-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetTemporaryPassword(_response);
        });
    }

    protected processSetTemporaryPassword(response: Response): Promise<SetTemporaryPasswordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SetTemporaryPasswordResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetTemporaryPasswordResponse>(null as any);
    }

    /**
     * Handle a password reset request by generating a reset link (admin only)
     */
    handlePasswordReset(requestId: string, signal?: AbortSignal): Promise<HandlePasswordResetResponse> {
        let url_ = this.baseUrl + "/auth/local/admin/handle-password-reset/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new globalThis.Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandlePasswordReset(_response);
        });
    }

    protected processHandlePasswordReset(response: Response): Promise<HandlePasswordResetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HandlePasswordResetResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HandlePasswordResetResponse>(null as any);
    }
}

export class MetadataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get WebSocket event types metadata
    This endpoint exists primarily to ensure NSwag generates TypeScript types for WebSocket events
     * @return WebSocket events metadata
     */
    getWebSocketEvents(signal?: AbortSignal): Promise<WebSocketEventsMetadata> {
        let url_ = this.baseUrl + "/api/Metadata/websocket-events";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWebSocketEvents(_response);
        });
    }

    protected processGetWebSocketEvents(response: Response): Promise<WebSocketEventsMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WebSocketEventsMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebSocketEventsMetadata>(null as any);
    }

    /**
     * Get external URLs for documentation and website
    This endpoint provides a single source of truth for all external Nocturne URLs
     * @return External URLs configuration
     */
    getExternalUrls(signal?: AbortSignal): Promise<ExternalUrls> {
        let url_ = this.baseUrl + "/api/Metadata/external-urls";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalUrls(_response);
        });
    }

    protected processGetExternalUrls(response: Response): Promise<ExternalUrls> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExternalUrls;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalUrls>(null as any);
    }

    /**
     * Get treatment event types metadata
    This endpoint exposes all available treatment event types for type-safe usage in frontend clients
     * @return Treatment event types metadata
     */
    getTreatmentEventTypes(signal?: AbortSignal): Promise<TreatmentEventTypesMetadata> {
        let url_ = this.baseUrl + "/api/Metadata/treatment-event-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatmentEventTypes(_response);
        });
    }

    protected processGetTreatmentEventTypes(response: Response): Promise<TreatmentEventTypesMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentEventTypesMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentEventTypesMetadata>(null as any);
    }

    /**
     * Get state span types metadata
    This endpoint exposes all available state span categories and their states for type-safe usage in frontend clients
     * @return State span types metadata
     */
    getStateSpanTypes(signal?: AbortSignal): Promise<StateSpanTypesMetadata> {
        let url_ = this.baseUrl + "/api/Metadata/state-span-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStateSpanTypes(_response);
        });
    }

    protected processGetStateSpanTypes(response: Response): Promise<StateSpanTypesMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpanTypesMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpanTypesMetadata>(null as any);
    }

    /**
     * Get statistics metadata for type generation
    This endpoint exists primarily to ensure NSwag generates TypeScript types for statistics models
     * @return Statistics types metadata
     */
    getStatisticsTypes(signal?: AbortSignal): Promise<StatisticsTypesMetadata> {
        let url_ = this.baseUrl + "/api/Metadata/statistics-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatisticsTypes(_response);
        });
    }

    protected processGetStatisticsTypes(response: Response): Promise<StatisticsTypesMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatisticsTypesMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatisticsTypesMetadata>(null as any);
    }

    /**
     * Get widget definitions metadata
    This endpoint provides all available dashboard widget definitions for frontend configuration
     * @return Widget definitions metadata
     */
    getWidgetDefinitions(signal?: AbortSignal): Promise<WidgetDefinitionsMetadata> {
        let url_ = this.baseUrl + "/api/Metadata/widget-definitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWidgetDefinitions(_response);
        });
    }

    protected processGetWidgetDefinitions(response: Response): Promise<WidgetDefinitionsMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WidgetDefinitionsMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WidgetDefinitionsMetadata>(null as any);
    }
}

export class OidcClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get available OIDC providers for login
     * @return List of enabled providers
     */
    getProviders(signal?: AbortSignal): Promise<OidcProviderInfo[]> {
        let url_ = this.baseUrl + "/auth/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProviders(_response);
        });
    }

    protected processGetProviders(response: Response): Promise<OidcProviderInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OidcProviderInfo[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OidcProviderInfo[]>(null as any);
    }

    /**
     * Initiate OIDC login flow
    Redirects to the OIDC provider's authorization endpoint
     * @param provider (optional) Provider ID (optional, uses default if not specified)
     * @param returnUrl (optional) URL to return to after login
     */
    login(provider?: string | null | undefined, returnUrl?: string | null | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/auth/login?";
        if (provider !== undefined && provider !== null)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Handle OIDC callback from provider
    Exchanges authorization code for tokens and creates session
     * @param code (optional) Authorization code from provider
     * @param state (optional) State parameter for CSRF verification
     * @param error (optional) Error code from provider (if any)
     * @param error_description (optional) Error description from provider
     */
    callback(code?: string | null | undefined, state?: string | null | undefined, error?: string | null | undefined, error_description?: string | null | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/auth/callback?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (error !== undefined && error !== null)
            url_ += "error=" + encodeURIComponent("" + error) + "&";
        if (error_description !== undefined && error_description !== null)
            url_ += "error_description=" + encodeURIComponent("" + error_description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCallback(_response);
        });
    }

    protected processCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Refresh the session tokens
    Uses the refresh token to get a new access token
     * @return New token response
     */
    refresh(signal?: AbortSignal): Promise<OidcTokenResponse> {
        let url_ = this.baseUrl + "/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<OidcTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OidcTokenResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OidcTokenResponse>(null as any);
    }

    /**
     * Logout and revoke the session
     * @param providerId (optional) Provider ID for RP-initiated logout (optional)
     * @return Logout result with optional provider logout URL
     */
    logout(providerId?: string | null | undefined, signal?: AbortSignal): Promise<LogoutResponse> {
        let url_ = this.baseUrl + "/auth/logout?";
        if (providerId !== undefined && providerId !== null)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<LogoutResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LogoutResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogoutResponse>(null as any);
    }

    /**
     * Get current user information
     * @return User information from the current session
     */
    getUserInfo(signal?: AbortSignal): Promise<OidcUserInfo> {
        let url_ = this.baseUrl + "/auth/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<OidcUserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OidcUserInfo;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OidcUserInfo>(null as any);
    }

    /**
     * Get current session information
     * @return Session status
     */
    getSession(signal?: AbortSignal): Promise<SessionInfo> {
        let url_ = this.baseUrl + "/auth/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSession(_response);
        });
    }

    protected processGetSession(response: Response): Promise<SessionInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SessionInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionInfo>(null as any);
    }
}

export class PebbleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get pebble-formatted data for smartwatch apps and CGM monitors
    Returns current glucose, trend, delta, battery, IOB, and COB information
     * @param units (optional) Units for glucose display (mg/dl or mmol)
     * @param count (optional) Number of glucose readings to return (default: 1)
     * @return Pebble-formatted response with bgs, cals, and status
     */
    getPebbleData(units?: string | null | undefined, count?: number | undefined, signal?: AbortSignal): Promise<PebbleResponse> {
        let url_ = this.baseUrl + "/pebble?";
        if (units !== undefined && units !== null)
            url_ += "units=" + encodeURIComponent("" + units) + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPebbleData(_response);
        });
    }

    protected processGetPebbleData(response: Response): Promise<PebbleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PebbleResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PebbleResponse>(null as any);
    }
}

export class StatisticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Calculate basic glucose statistics from provided glucose values
     * @param values Array of glucose values in mg/dL
     * @return Basic glucose statistics including mean, median, percentiles, etc.
     */
    calculateBasicStats(values: number[], signal?: AbortSignal): Promise<BasicGlucoseStats> {
        let url_ = this.baseUrl + "/api/v1/Statistics/basic-stats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(values);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateBasicStats(_response);
        });
    }

    protected processCalculateBasicStats(response: Response): Promise<BasicGlucoseStats> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasicGlucoseStats;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BasicGlucoseStats>(null as any);
    }

    /**
     * Calculate comprehensive glycemic variability metrics
     * @param request Request containing glucose values and entries
     * @return Comprehensive glycemic variability metrics
     */
    calculateGlycemicVariability(request: GlycemicVariabilityRequest, signal?: AbortSignal): Promise<GlycemicVariability> {
        let url_ = this.baseUrl + "/api/v1/Statistics/glycemic-variability";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGlycemicVariability(_response);
        });
    }

    protected processCalculateGlycemicVariability(response: Response): Promise<GlycemicVariability> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlycemicVariability;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlycemicVariability>(null as any);
    }

    /**
     * Calculate time in range metrics
     * @param request Request containing entries and optional thresholds
     * @return Time in range metrics including percentages, durations, and episodes
     */
    calculateTimeInRange(request: TimeInRangeRequest, signal?: AbortSignal): Promise<TimeInRangeMetrics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/time-in-range";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateTimeInRange(_response);
        });
    }

    protected processCalculateTimeInRange(response: Response): Promise<TimeInRangeMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeInRangeMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeInRangeMetrics>(null as any);
    }

    /**
     * Calculate glucose distribution across configurable bins
     * @param request Request containing entries and optional bins
     * @return Collection of distribution data points
     */
    calculateGlucoseDistribution(request: GlucoseDistributionRequest, signal?: AbortSignal): Promise<DistributionDataPoint[]> {
        let url_ = this.baseUrl + "/api/v1/Statistics/glucose-distribution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGlucoseDistribution(_response);
        });
    }

    protected processCalculateGlucoseDistribution(response: Response): Promise<DistributionDataPoint[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DistributionDataPoint[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DistributionDataPoint[]>(null as any);
    }

    /**
     * Calculate averaged statistics for each hour of the day (0-23)
     * @param entries Array of glucose entries
     * @return Collection of averaged statistics for each hour
     */
    calculateAveragedStats(entries: Entry[], signal?: AbortSignal): Promise<AveragedStats[]> {
        let url_ = this.baseUrl + "/api/v1/Statistics/averaged-stats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateAveragedStats(_response);
        });
    }

    protected processCalculateAveragedStats(response: Response): Promise<AveragedStats[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AveragedStats[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AveragedStats[]>(null as any);
    }

    /**
     * Calculate treatment summary for a collection of treatments
     * @param treatments Array of treatments
     * @return Treatment summary with totals and counts
     */
    calculateTreatmentSummary(treatments: Treatment[], signal?: AbortSignal): Promise<TreatmentSummary> {
        let url_ = this.baseUrl + "/api/v1/Statistics/treatment-summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateTreatmentSummary(_response);
        });
    }

    protected processCalculateTreatmentSummary(response: Response): Promise<TreatmentSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentSummary>(null as any);
    }

    /**
     * Calculate overall averages across multiple days
     * @param dailyDataPoints Array of daily data points
     * @return Overall averages or null if no data
     */
    calculateOverallAverages(dailyDataPoints: DayData[], signal?: AbortSignal): Promise<OverallAverages> {
        let url_ = this.baseUrl + "/api/v1/Statistics/overall-averages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dailyDataPoints);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateOverallAverages(_response);
        });
    }

    protected processCalculateOverallAverages(response: Response): Promise<OverallAverages> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OverallAverages;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OverallAverages>(null as any);
    }

    /**
     * Master glucose analytics function that calculates comprehensive metrics
     * @param request Request containing entries, treatments, and configuration
     * @return Comprehensive glucose analytics
     */
    analyzeGlucoseData(request: GlucoseAnalyticsRequest, signal?: AbortSignal): Promise<GlucoseAnalytics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/comprehensive-analytics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnalyzeGlucoseData(_response);
        });
    }

    protected processAnalyzeGlucoseData(response: Response): Promise<GlucoseAnalytics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlucoseAnalytics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlucoseAnalytics>(null as any);
    }

    /**
     * Extended glucose analytics including GMI, GRI, and clinical target assessment
     * @param request Request containing entries, treatments, population type, and configuration
     * @return Extended glucose analytics with modern clinical metrics
     */
    analyzeGlucoseDataExtended(request: ExtendedGlucoseAnalyticsRequest, signal?: AbortSignal): Promise<ExtendedGlucoseAnalytics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/extended-analytics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnalyzeGlucoseDataExtended(_response);
        });
    }

    protected processAnalyzeGlucoseDataExtended(response: Response): Promise<ExtendedGlucoseAnalytics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExtendedGlucoseAnalytics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtendedGlucoseAnalytics>(null as any);
    }

    /**
     * Calculate Glucose Management Indicator (GMI)
     * @param meanGlucose Mean glucose in mg/dL
     * @return GMI with value and interpretation
     */
    calculateGMI(meanGlucose: number, signal?: AbortSignal): Promise<GlucoseManagementIndicator> {
        let url_ = this.baseUrl + "/api/v1/Statistics/gmi/{meanGlucose}";
        if (meanGlucose === undefined || meanGlucose === null)
            throw new globalThis.Error("The parameter 'meanGlucose' must be defined.");
        url_ = url_.replace("{meanGlucose}", encodeURIComponent("" + meanGlucose));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGMI(_response);
        });
    }

    protected processCalculateGMI(response: Response): Promise<GlucoseManagementIndicator> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlucoseManagementIndicator;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlucoseManagementIndicator>(null as any);
    }

    /**
     * Calculate Glycemic Risk Index (GRI) from time in range metrics
     * @param timeInRange Time in range metrics
     * @return GRI with score, zone, and interpretation
     */
    calculateGRI(timeInRange: TimeInRangeMetrics, signal?: AbortSignal): Promise<GlycemicRiskIndex> {
        let url_ = this.baseUrl + "/api/v1/Statistics/gri";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(timeInRange);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateGRI(_response);
        });
    }

    protected processCalculateGRI(response: Response): Promise<GlycemicRiskIndex> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlycemicRiskIndex;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlycemicRiskIndex>(null as any);
    }

    /**
     * Assess glucose data against clinical targets for a specific population
     * @param request Request containing analytics and population type
     * @return Clinical target assessment with actionable insights
     */
    assessAgainstTargets(request: ClinicalAssessmentRequest, signal?: AbortSignal): Promise<ClinicalTargetAssessment> {
        let url_ = this.baseUrl + "/api/v1/Statistics/clinical-assessment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssessAgainstTargets(_response);
        });
    }

    protected processAssessAgainstTargets(response: Response): Promise<ClinicalTargetAssessment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClinicalTargetAssessment;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClinicalTargetAssessment>(null as any);
    }

    /**
     * Assess data sufficiency for a valid clinical report
     * @param request Request containing entries and optional period settings
     * @return Data sufficiency assessment
     */
    assessDataSufficiency(request: DataSufficiencyRequest, signal?: AbortSignal): Promise<DataSufficiencyAssessment> {
        let url_ = this.baseUrl + "/api/v1/Statistics/data-sufficiency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssessDataSufficiency(_response);
        });
    }

    protected processAssessDataSufficiency(response: Response): Promise<DataSufficiencyAssessment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSufficiencyAssessment;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSufficiencyAssessment>(null as any);
    }

    /**
     * Get clinical targets for a specific diabetes population
     * @param population Population type (Type1Adult, Type2Adult, Elderly, Pregnancy, etc.)
     * @return Clinical targets for the specified population
     */
    getClinicalTargets(population: DiabetesPopulation, signal?: AbortSignal): Promise<ClinicalTargets> {
        let url_ = this.baseUrl + "/api/v1/Statistics/clinical-targets/{population}";
        if (population === undefined || population === null)
            throw new globalThis.Error("The parameter 'population' must be defined.");
        url_ = url_.replace("{population}", encodeURIComponent("" + population));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClinicalTargets(_response);
        });
    }

    protected processGetClinicalTargets(response: Response): Promise<ClinicalTargets> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClinicalTargets;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClinicalTargets>(null as any);
    }

    /**
     * Calculate estimated A1C from average glucose
     * @param averageGlucose Average glucose in mg/dL
     * @return Estimated A1C percentage
     */
    calculateEstimatedA1C(averageGlucose: number, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/Statistics/estimated-a1c/{averageGlucose}";
        if (averageGlucose === undefined || averageGlucose === null)
            throw new globalThis.Error("The parameter 'averageGlucose' must be defined.");
        url_ = url_.replace("{averageGlucose}", encodeURIComponent("" + averageGlucose));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateEstimatedA1C(_response);
        });
    }

    protected processCalculateEstimatedA1C(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Convert mg/dL to mmol/L
     * @param mgdl Glucose value in mg/dL
     * @return Glucose value in mmol/L
     */
    mgdlToMMOL(mgdl: number, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/Statistics/convert/mgdl-to-mmol/{mgdl}";
        if (mgdl === undefined || mgdl === null)
            throw new globalThis.Error("The parameter 'mgdl' must be defined.");
        url_ = url_.replace("{mgdl}", encodeURIComponent("" + mgdl));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMgdlToMMOL(_response);
        });
    }

    protected processMgdlToMMOL(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Convert mmol/L to mg/dL
     * @param mmol Glucose value in mmol/L
     * @return Glucose value in mg/dL
     */
    mmolToMGDL(mmol: number, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/Statistics/convert/mmol-to-mgdl/{mmol}";
        if (mmol === undefined || mmol === null)
            throw new globalThis.Error("The parameter 'mmol' must be defined.");
        url_ = url_.replace("{mmol}", encodeURIComponent("" + mmol));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMmolToMGDL(_response);
        });
    }

    protected processMmolToMGDL(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Format insulin value for display
     * @param value Insulin value
     * @return Formatted insulin string
     */
    formatInsulinDisplay(value: number, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/Statistics/format/insulin/{value}";
        if (value === undefined || value === null)
            throw new globalThis.Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{value}", encodeURIComponent("" + value));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormatInsulinDisplay(_response);
        });
    }

    protected processFormatInsulinDisplay(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Format carb value for display
     * @param value Carb value
     * @return Formatted carb string
     */
    formatCarbDisplay(value: number, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/Statistics/format/carb/{value}";
        if (value === undefined || value === null)
            throw new globalThis.Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{value}", encodeURIComponent("" + value));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormatCarbDisplay(_response);
        });
    }

    protected processFormatCarbDisplay(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Validate treatment data for completeness and consistency
     * @param treatment Treatment to validate
     * @return True if treatment data is valid
     */
    validateTreatmentData(treatment: Treatment, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/Statistics/validate/treatment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateTreatmentData(_response);
        });
    }

    protected processValidateTreatmentData(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Clean and filter treatment data
     * @param treatments Array of treatments to clean
     * @return Cleaned collection of treatments
     */
    cleanTreatmentData(treatments: Treatment[], signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v1/Statistics/clean/treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCleanTreatmentData(_response);
        });
    }

    protected processCleanTreatmentData(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Get comprehensive statistics for multiple time periods (1, 3, 7, 30, 90 days)
    Uses in-memory cache for performance with daily expiration
     * @return Multi-period statistics with comprehensive analytics for each time period
     */
    getMultiPeriodStatistics(signal?: AbortSignal): Promise<MultiPeriodStatistics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/periods";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMultiPeriodStatistics(_response);
        });
    }

    protected processGetMultiPeriodStatistics(response: Response): Promise<MultiPeriodStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MultiPeriodStatistics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MultiPeriodStatistics>(null as any);
    }

    /**
     * Analyze glucose patterns around site changes to identify impact of site age on control
     * @param request Request containing entries, treatments, and analysis parameters
     * @return Site change impact analysis with averaged glucose patterns
     */
    calculateSiteChangeImpact(request: SiteChangeImpactRequest, signal?: AbortSignal): Promise<SiteChangeImpactAnalysis> {
        let url_ = this.baseUrl + "/api/v1/Statistics/site-change-impact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateSiteChangeImpact(_response);
        });
    }

    protected processCalculateSiteChangeImpact(response: Response): Promise<SiteChangeImpactAnalysis> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SiteChangeImpactAnalysis;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SiteChangeImpactAnalysis>(null as any);
    }

    /**
     * Calculate daily basal/bolus ratio statistics for a date range
     * @param startDate (optional) Start date of the analysis period
     * @param endDate (optional) End date of the analysis period
     * @return Daily basal/bolus ratio breakdown with averages
     */
    getDailyBasalBolusRatios(startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<DailyBasalBolusRatioResponse> {
        let url_ = this.baseUrl + "/api/v1/Statistics/daily-basal-bolus-ratios?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDailyBasalBolusRatios(_response);
        });
    }

    protected processGetDailyBasalBolusRatios(response: Response): Promise<DailyBasalBolusRatioResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DailyBasalBolusRatioResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyBasalBolusRatioResponse>(null as any);
    }

    /**
     * Calculate comprehensive insulin delivery statistics for a date range
     * @param startDate (optional) Start date of the analysis period
     * @param endDate (optional) End date of the analysis period
     * @return Comprehensive insulin delivery statistics
     */
    getInsulinDeliveryStatistics(startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<InsulinDeliveryStatistics> {
        let url_ = this.baseUrl + "/api/v1/Statistics/insulin-delivery-stats?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsulinDeliveryStatistics(_response);
        });
    }

    protected processGetInsulinDeliveryStatistics(response: Response): Promise<InsulinDeliveryStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InsulinDeliveryStatistics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InsulinDeliveryStatistics>(null as any);
    }

    /**
     * Calculate comprehensive basal analysis statistics for a date range
     * @param startDate (optional) Start date of the analysis period
     * @param endDate (optional) End date of the analysis period
     * @return Comprehensive basal analysis with stats, temp basal info, and hourly percentiles
     */
    getBasalAnalysis(startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<BasalAnalysisResponse> {
        let url_ = this.baseUrl + "/api/v1/Statistics/basal-analysis?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBasalAnalysis(_response);
        });
    }

    protected processGetBasalAnalysis(response: Response): Promise<BasalAnalysisResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasalAnalysisResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BasalAnalysisResponse>(null as any);
    }
}

export class VersionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the list of supported API versions
     * @return List of supported API versions
     */
    getVersions(signal?: AbortSignal): Promise<VersionsResponse> {
        let url_ = this.baseUrl + "/api/Versions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersions(_response);
        });
    }

    protected processGetVersions(response: Response): Promise<VersionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionsResponse>(null as any);
    }
}

export class WellKnownClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * OpenID Connect Discovery Document
     */
    getOpenIdConfiguration(signal?: AbortSignal): Promise<OpenIdConfiguration> {
        let url_ = this.baseUrl + "/.well-known/openid-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOpenIdConfiguration(_response);
        });
    }

    protected processGetOpenIdConfiguration(response: Response): Promise<OpenIdConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OpenIdConfiguration;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIdConfiguration>(null as any);
    }

    /**
     * JSON Web Key Set (JWKS) - for token signature verification
    Note: Since we use HMAC symmetric keys, we only expose the algorithm info
    Actual key verification happens server-side
     */
    getJwks(signal?: AbortSignal): Promise<JsonWebKeySet> {
        let url_ = this.baseUrl + "/.well-known/jwks.json";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJwks(_response);
        });
    }

    protected processGetJwks(response: Response): Promise<JsonWebKeySet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as JsonWebKeySet;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JsonWebKeySet>(null as any);
    }

    /**
     * OAuth 2.0 Authorization Server Metadata
     */
    getOAuthMetadata(signal?: AbortSignal): Promise<OAuthAuthorizationServerMetadata> {
        let url_ = this.baseUrl + "/.well-known/oauth-authorization-server";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOAuthMetadata(_response);
        });
    }

    protected processGetOAuthMetadata(response: Response): Promise<OAuthAuthorizationServerMetadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OAuthAuthorizationServerMetadata;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OAuthAuthorizationServerMetadata>(null as any);
    }
}

export class BatteryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current battery status for all tracked devices
     * @param recentMinutes (optional) How many minutes back to consider for "recent" readings (default: 30)
     * @return Current battery status for all devices
     */
    getCurrentBatteryStatus(recentMinutes?: number | undefined, signal?: AbortSignal): Promise<CurrentBatteryStatus> {
        let url_ = this.baseUrl + "/api/v4/Battery/current?";
        if (recentMinutes === null)
            throw new globalThis.Error("The parameter 'recentMinutes' cannot be null.");
        else if (recentMinutes !== undefined)
            url_ += "recentMinutes=" + encodeURIComponent("" + recentMinutes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentBatteryStatus(_response);
        });
    }

    protected processGetCurrentBatteryStatus(response: Response): Promise<CurrentBatteryStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CurrentBatteryStatus;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrentBatteryStatus>(null as any);
    }

    /**
     * Get battery readings for a device over a time period
     * @param device (optional) Device identifier (optional, returns all devices if not specified)
     * @param from (optional) Start time in milliseconds since Unix epoch
     * @param to (optional) End time in milliseconds since Unix epoch
     * @return Battery readings for the specified period
     */
    getBatteryReadings(device?: string | null | undefined, from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<BatteryReading[]> {
        let url_ = this.baseUrl + "/api/v4/Battery/readings?";
        if (device !== undefined && device !== null)
            url_ += "device=" + encodeURIComponent("" + device) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBatteryReadings(_response);
        });
    }

    protected processGetBatteryReadings(response: Response): Promise<BatteryReading[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatteryReading[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatteryReading[]>(null as any);
    }

    /**
     * Get battery statistics for a device or all devices
     * @param device (optional) Device identifier (optional, returns all devices if not specified)
     * @param from (optional) Start time in milliseconds since Unix epoch (default: 7 days ago)
     * @param to (optional) End time in milliseconds since Unix epoch (default: now)
     * @return Battery statistics for the specified period
     */
    getBatteryStatistics(device?: string | null | undefined, from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<BatteryStatistics[]> {
        let url_ = this.baseUrl + "/api/v4/Battery/statistics?";
        if (device !== undefined && device !== null)
            url_ += "device=" + encodeURIComponent("" + device) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBatteryStatistics(_response);
        });
    }

    protected processGetBatteryStatistics(response: Response): Promise<BatteryStatistics[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatteryStatistics[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatteryStatistics[]>(null as any);
    }

    /**
     * Get charge cycle history for a device
     * @param device (optional) Device identifier (optional, returns all devices if not specified)
     * @param from (optional) Start time in milliseconds since Unix epoch
     * @param to (optional) End time in milliseconds since Unix epoch
     * @param limit (optional) Maximum number of cycles to return (default: 100)
     * @return Charge cycles for the specified period
     */
    getChargeCycles(device?: string | null | undefined, from?: number | null | undefined, to?: number | null | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<ChargeCycle[]> {
        let url_ = this.baseUrl + "/api/v4/Battery/cycles?";
        if (device !== undefined && device !== null)
            url_ += "device=" + encodeURIComponent("" + device) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChargeCycles(_response);
        });
    }

    protected processGetChargeCycles(response: Response): Promise<ChargeCycle[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChargeCycle[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChargeCycle[]>(null as any);
    }

    /**
     * Get list of all known devices with battery data
     * @return List of device identifiers
     */
    getKnownDevices(signal?: AbortSignal): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v4/Battery/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKnownDevices(_response);
        });
    }

    protected processGetKnownDevices(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class ChartDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get dashboard chart data with pre-calculated IOB, COB, and basal time series
     * @param startTime (optional) Start time in Unix milliseconds
     * @param endTime (optional) End time in Unix milliseconds
     * @param intervalMinutes (optional) Interval for IOB/COB calculations (default: 5)
     * @return Chart data with all calculated series
     */
    getDashboardChartData(startTime?: number | undefined, endTime?: number | undefined, intervalMinutes?: number | undefined, signal?: AbortSignal): Promise<DashboardChartData> {
        let url_ = this.baseUrl + "/api/v4/ChartData/dashboard?";
        if (startTime === null)
            throw new globalThis.Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent("" + startTime) + "&";
        if (endTime === null)
            throw new globalThis.Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent("" + endTime) + "&";
        if (intervalMinutes === null)
            throw new globalThis.Error("The parameter 'intervalMinutes' cannot be null.");
        else if (intervalMinutes !== undefined)
            url_ += "intervalMinutes=" + encodeURIComponent("" + intervalMinutes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDashboardChartData(_response);
        });
    }

    protected processGetDashboardChartData(response: Response): Promise<DashboardChartData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DashboardChartData;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardChartData>(null as any);
    }
}

export class ClockFacesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get a clock face configuration by ID (public, no authentication required)
     * @param id Clock face UUID
     * @return Clock face configuration
     */
    getById(id: string, signal?: AbortSignal): Promise<ClockFacePublicDto> {
        let url_ = this.baseUrl + "/api/v4/clockfaces/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<ClockFacePublicDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClockFacePublicDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClockFacePublicDto>(null as any);
    }

    /**
     * Update an existing clock face (owner only)
     * @param id Clock face UUID
     * @param request Update request
     * @return Updated clock face
     */
    update(id: string, request: UpdateClockFaceRequest, signal?: AbortSignal): Promise<ClockFace> {
        let url_ = this.baseUrl + "/api/v4/clockfaces/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ClockFace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClockFace;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClockFace>(null as any);
    }

    /**
     * Delete a clock face (owner only)
     * @param id Clock face UUID
     * @return Success status
     */
    delete(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/clockfaces/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * List all clock faces for the current user
     * @return List of clock faces
     */
    list(signal?: AbortSignal): Promise<ClockFaceListItem[]> {
        let url_ = this.baseUrl + "/api/v4/clockfaces";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ClockFaceListItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClockFaceListItem[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClockFaceListItem[]>(null as any);
    }

    /**
     * Create a new clock face
     * @param request Clock face creation request
     * @return Created clock face
     */
    create(request: CreateClockFaceRequest, signal?: AbortSignal): Promise<ClockFace> {
        let url_ = this.baseUrl + "/api/v4/clockfaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ClockFace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClockFace;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClockFace>(null as any);
    }
}

export class CompatibilityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get current proxy configuration
     */
    getConfiguration(signal?: AbortSignal): Promise<ProxyConfigurationDto> {
        let url_ = this.baseUrl + "/api/v4/compatibility/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: Response): Promise<ProxyConfigurationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProxyConfigurationDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProxyConfigurationDto>(null as any);
    }

    /**
     * Get overall compatibility metrics
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<CompatibilityMetrics> {
        let url_ = this.baseUrl + "/api/v4/compatibility/metrics?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMetrics(_response);
        });
    }

    protected processGetMetrics(response: Response): Promise<CompatibilityMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompatibilityMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompatibilityMetrics>(null as any);
    }

    /**
     * Get per-endpoint compatibility metrics
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getEndpointMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<EndpointMetrics[]> {
        let url_ = this.baseUrl + "/api/v4/compatibility/endpoints?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEndpointMetrics(_response);
        });
    }

    protected processGetEndpointMetrics(response: Response): Promise<EndpointMetrics[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EndpointMetrics[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointMetrics[]>(null as any);
    }

    /**
     * Get list of analyses with filtering and pagination
     * @param requestPath (optional) 
     * @param overallMatch (optional) 
     * @param requestMethod (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param count (optional) 
     * @param skip (optional) 
     */
    getAnalyses(requestPath?: string | null | undefined, overallMatch?: ResponseMatchType | null | undefined, requestMethod?: string | null | undefined, fromDate?: Date | null | undefined, toDate?: Date | null | undefined, count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<AnalysesListResponse> {
        let url_ = this.baseUrl + "/api/v4/compatibility/analyses?";
        if (requestPath !== undefined && requestPath !== null)
            url_ += "requestPath=" + encodeURIComponent("" + requestPath) + "&";
        if (overallMatch !== undefined && overallMatch !== null)
            url_ += "overallMatch=" + encodeURIComponent("" + overallMatch) + "&";
        if (requestMethod !== undefined && requestMethod !== null)
            url_ += "requestMethod=" + encodeURIComponent("" + requestMethod) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnalyses(_response);
        });
    }

    protected processGetAnalyses(response: Response): Promise<AnalysesListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalysesListResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalysesListResponse>(null as any);
    }

    /**
     * Get detailed analysis by ID
     */
    getAnalysisDetail(id: string, signal?: AbortSignal): Promise<AnalysisDetailDto> {
        let url_ = this.baseUrl + "/api/v4/compatibility/analyses/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnalysisDetail(_response);
        });
    }

    protected processGetAnalysisDetail(response: Response): Promise<AnalysisDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalysisDetailDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalysisDetailDto>(null as any);
    }

    /**
     * Test API compatibility by comparing responses from Nightscout and Nocturne
     */
    testApiComparison(request: ManualTestRequest, signal?: AbortSignal): Promise<ManualTestResult> {
        let url_ = this.baseUrl + "/api/v4/compatibility/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestApiComparison(_response);
        });
    }

    protected processTestApiComparison(response: Response): Promise<ManualTestResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ManualTestResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManualTestResult>(null as any);
    }
}

export class ConnectorFoodEntriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Import connector food entries.
     */
    importEntries(imports: ConnectorFoodEntryImport[], signal?: AbortSignal): Promise<ConnectorFoodEntry[]> {
        let url_ = this.baseUrl + "/api/v4/connector-food-entries/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(imports);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportEntries(_response);
        });
    }

    protected processImportEntries(response: Response): Promise<ConnectorFoodEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorFoodEntry[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorFoodEntry[]>(null as any);
    }
}

export class DebugClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Echo endpoint for debugging MongoDB queries
    Returns information about how REST API parameters translate into MongoDB queries
     * @param echo Storage type to query (entries, treatments, devicestatus, activity)
     * @return Query information returned successfully
     */
    echoQuery(echo: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v4/debug/echo/{echo}";
        if (echo === undefined || echo === null)
            throw new globalThis.Error("The parameter 'echo' must be defined.");
        url_ = url_.replace("{echo}", encodeURIComponent("" + echo));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoQuery(_response);
        });
    }

    protected processEchoQuery(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Echo endpoint for debugging MongoDB queries with model
    Returns information about how REST API parameters translate into MongoDB queries
     * @param echo Storage type to query (entries, treatments, devicestatus, activity)
     * @param model Model specification
     * @return Query information returned successfully
     */
    echoQueryWithModel(echo: string, model: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v4/debug/echo/{echo}/{model}";
        if (echo === undefined || echo === null)
            throw new globalThis.Error("The parameter 'echo' must be defined.");
        url_ = url_.replace("{echo}", encodeURIComponent("" + echo));
        if (model === undefined || model === null)
            throw new globalThis.Error("The parameter 'model' must be defined.");
        url_ = url_.replace("{model}", encodeURIComponent("" + model));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoQueryWithModel(_response);
        });
    }

    protected processEchoQueryWithModel(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Echo endpoint for debugging MongoDB queries with model and spec
    Returns information about how REST API parameters translate into MongoDB queries
     * @param echo Storage type to query (entries, treatments, devicestatus, activity)
     * @param model Model specification
     * @param spec Specification parameter
     * @return Query information returned successfully
     */
    echoQueryWithModelAndSpec(echo: string, model: string, spec: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v4/debug/echo/{echo}/{model}/{spec}";
        if (echo === undefined || echo === null)
            throw new globalThis.Error("The parameter 'echo' must be defined.");
        url_ = url_.replace("{echo}", encodeURIComponent("" + echo));
        if (model === undefined || model === null)
            throw new globalThis.Error("The parameter 'model' must be defined.");
        url_ = url_.replace("{model}", encodeURIComponent("" + model));
        if (spec === undefined || spec === null)
            throw new globalThis.Error("The parameter 'spec' must be defined.");
        url_ = url_.replace("{spec}", encodeURIComponent("" + spec));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoQueryWithModelAndSpec(_response);
        });
    }

    protected processEchoQueryWithModelAndSpec(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Preview endpoint for entry creation without persistence
    Allows previewing entry data without actually storing it in the database
     * @param entries Entry data to preview (single object or array)
     * @return Entry data previewed successfully
     */
    previewEntries(entries: any, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v4/debug/entries/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreviewEntries(_response);
        });
    }

    protected processPreviewEntries(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid entry data", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Test endpoint for creating in-app notifications (development only)
    Creates a test notification for the current user to verify the notification system
     * @param request The test notification parameters
     * @return Notification created successfully
     */
    createTestNotification(request: TestNotificationRequest, signal?: AbortSignal): Promise<InAppNotificationDto> {
        let url_ = this.baseUrl + "/api/v4/debug/test/inappnotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTestNotification(_response);
        });
    }

    protected processCreateTestNotification(response: Response): Promise<InAppNotificationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InAppNotificationDto;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid request parameters", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("User not authenticated", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Endpoint only available in development", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InAppNotificationDto>(null as any);
    }

    testPostgreSqlConnection(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/Debug/postgresql-test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestPostgreSqlConnection(_response);
        });
    }

    protected processTestPostgreSqlConnection(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getEntriesDirect(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/Debug/entries-direct";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntriesDirect(_response);
        });
    }

    protected processGetEntriesDirect(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class DeduplicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Start a deduplication job to link related records from different data sources.
    The job runs in the background and can be monitored using the status endpoint.
     * @return Job ID for tracking progress
     */
    startDeduplicationJob(signal?: AbortSignal): Promise<DeduplicationJobResponse> {
        let url_ = this.baseUrl + "/api/v4/admin/deduplication/run";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartDeduplicationJob(_response);
        });
    }

    protected processStartDeduplicationJob(response: Response): Promise<DeduplicationJobResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeduplicationJobResponse;
            return result202;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeduplicationJobResponse>(null as any);
    }

    /**
     * Get the status of a deduplication job.
     * @param jobId The job ID returned from the run endpoint
     * @return Current status and progress of the job
     */
    getJobStatus(jobId: string, signal?: AbortSignal): Promise<DeduplicationJobStatus> {
        let url_ = this.baseUrl + "/api/v4/admin/deduplication/status/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new globalThis.Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJobStatus(_response);
        });
    }

    protected processGetJobStatus(response: Response): Promise<DeduplicationJobStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeduplicationJobStatus;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeduplicationJobStatus>(null as any);
    }

    /**
     * Cancel a running deduplication job.
     * @param jobId The job ID to cancel
     * @return Whether the job was successfully cancelled
     */
    cancelJob(jobId: string, signal?: AbortSignal): Promise<CancelJobResponse> {
        let url_ = this.baseUrl + "/api/v4/admin/deduplication/cancel/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new globalThis.Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelJob(_response);
        });
    }

    protected processCancelJob(response: Response): Promise<CancelJobResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancelJobResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CancelJobResponse>(null as any);
    }

    /**
     * Get linked records for a specific entry by its canonical group.
     * @param entryId The entry ID
     * @return All linked records in the same canonical group
     */
    getEntryLinkedRecords(entryId: string, signal?: AbortSignal): Promise<LinkedRecordsResponse> {
        let url_ = this.baseUrl + "/api/v4/admin/deduplication/entries/{entryId}/sources";
        if (entryId === undefined || entryId === null)
            throw new globalThis.Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntryLinkedRecords(_response);
        });
    }

    protected processGetEntryLinkedRecords(response: Response): Promise<LinkedRecordsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LinkedRecordsResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkedRecordsResponse>(null as any);
    }

    /**
     * Get linked records for a specific treatment by its canonical group.
     * @param treatmentId The treatment ID
     * @return All linked records in the same canonical group
     */
    getTreatmentLinkedRecords(treatmentId: string, signal?: AbortSignal): Promise<LinkedRecordsResponse> {
        let url_ = this.baseUrl + "/api/v4/admin/deduplication/treatments/{treatmentId}/sources";
        if (treatmentId === undefined || treatmentId === null)
            throw new globalThis.Error("The parameter 'treatmentId' must be defined.");
        url_ = url_.replace("{treatmentId}", encodeURIComponent("" + treatmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatmentLinkedRecords(_response);
        });
    }

    protected processGetTreatmentLinkedRecords(response: Response): Promise<LinkedRecordsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LinkedRecordsResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkedRecordsResponse>(null as any);
    }

    /**
     * Get linked records for a specific state span by its canonical group.
     * @param stateSpanId The state span ID
     * @return All linked records in the same canonical group
     */
    getStateSpanLinkedRecords(stateSpanId: string, signal?: AbortSignal): Promise<LinkedRecordsResponse> {
        let url_ = this.baseUrl + "/api/v4/admin/deduplication/state-spans/{stateSpanId}/sources";
        if (stateSpanId === undefined || stateSpanId === null)
            throw new globalThis.Error("The parameter 'stateSpanId' must be defined.");
        url_ = url_.replace("{stateSpanId}", encodeURIComponent("" + stateSpanId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStateSpanLinkedRecords(_response);
        });
    }

    protected processGetStateSpanLinkedRecords(response: Response): Promise<LinkedRecordsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LinkedRecordsResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkedRecordsResponse>(null as any);
    }
}

export class DeviceAgeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get cannula/site age (CAGE)
     * @param info (optional) 
     * @param warn (optional) 
     * @param urgent (optional) 
     * @param display (optional) 
     * @param enableAlerts (optional) 
     */
    getCannulaAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<DeviceAgeInfo> {
        let url_ = this.baseUrl + "/api/v4/deviceage/cannula?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCannulaAge(_response);
        });
    }

    protected processGetCannulaAge(response: Response): Promise<DeviceAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAgeInfo>(null as any);
    }

    /**
     * Get sensor age (SAGE)
    Returns both Sensor Start and Sensor Change events
     * @param info (optional) 
     * @param warn (optional) 
     * @param urgent (optional) 
     * @param display (optional) 
     * @param enableAlerts (optional) 
     */
    getSensorAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<SensorAgeInfo> {
        let url_ = this.baseUrl + "/api/v4/deviceage/sensor?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSensorAge(_response);
        });
    }

    protected processGetSensorAge(response: Response): Promise<SensorAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SensorAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorAgeInfo>(null as any);
    }

    /**
     * Get insulin reservoir age (IAGE)
     * @param info (optional) 
     * @param warn (optional) 
     * @param urgent (optional) 
     * @param display (optional) 
     * @param enableAlerts (optional) 
     */
    getInsulinAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<DeviceAgeInfo> {
        let url_ = this.baseUrl + "/api/v4/deviceage/insulin?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsulinAge(_response);
        });
    }

    protected processGetInsulinAge(response: Response): Promise<DeviceAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAgeInfo>(null as any);
    }

    /**
     * Get pump battery age (BAGE)
     * @param info (optional) 
     * @param warn (optional) 
     * @param urgent (optional) 
     * @param display (optional) 
     * @param enableAlerts (optional) 
     */
    getBatteryAge(info?: number | null | undefined, warn?: number | null | undefined, urgent?: number | null | undefined, display?: string | null | undefined, enableAlerts?: boolean | null | undefined, signal?: AbortSignal): Promise<DeviceAgeInfo> {
        let url_ = this.baseUrl + "/api/v4/deviceage/battery?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        if (warn !== undefined && warn !== null)
            url_ += "warn=" + encodeURIComponent("" + warn) + "&";
        if (urgent !== undefined && urgent !== null)
            url_ += "urgent=" + encodeURIComponent("" + urgent) + "&";
        if (display !== undefined && display !== null)
            url_ += "display=" + encodeURIComponent("" + display) + "&";
        if (enableAlerts !== undefined && enableAlerts !== null)
            url_ += "enableAlerts=" + encodeURIComponent("" + enableAlerts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBatteryAge(_response);
        });
    }

    protected processGetBatteryAge(response: Response): Promise<DeviceAgeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAgeInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAgeInfo>(null as any);
    }

    /**
     * Get all device ages in a single call
     */
    getAllDeviceAges(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/deviceage/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDeviceAges(_response);
        });
    }

    protected processGetAllDeviceAges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeviceAlertsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get active device alerts for the current user
     * @param deviceId (optional) Optional device ID filter
     * @return List of active device alerts
     */
    getActiveDeviceAlerts(deviceId?: string | null | undefined, signal?: AbortSignal): Promise<DeviceAlert[]> {
        let url_ = this.baseUrl + "/api/v4/devices/alerts?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActiveDeviceAlerts(_response);
        });
    }

    protected processGetActiveDeviceAlerts(response: Response): Promise<DeviceAlert[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlert[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlert[]>(null as any);
    }

    /**
     * Get device alerts summary by type
     * @return Alert summary
     */
    getDeviceAlertSummary(signal?: AbortSignal): Promise<DeviceAlertSummary> {
        let url_ = this.baseUrl + "/api/v4/devices/alerts/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceAlertSummary(_response);
        });
    }

    protected processGetDeviceAlertSummary(response: Response): Promise<DeviceAlertSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlertSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlertSummary>(null as any);
    }

    /**
     * Acknowledge a device alert
     * @param alertId Alert identifier
     * @return Success response
     */
    acknowledgeDeviceAlert(alertId: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/devices/alerts/{alertId}/acknowledge";
        if (alertId === undefined || alertId === null)
            throw new globalThis.Error("The parameter 'alertId' must be defined.");
        url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcknowledgeDeviceAlert(_response);
        });
    }

    protected processAcknowledgeDeviceAlert(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Test device alert generation for a specific device
     * @param deviceId Device identifier
     * @return List of generated alerts
     */
    testDeviceAlerts(deviceId: string, signal?: AbortSignal): Promise<DeviceAlert[]> {
        let url_ = this.baseUrl + "/api/v4/devices/alerts/test/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new globalThis.Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestDeviceAlerts(_response);
        });
    }

    protected processTestDeviceAlerts(response: Response): Promise<DeviceAlert[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlert[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlert[]>(null as any);
    }

    /**
     * Get alert settings/preferences for device alerts
     * @return Alert settings
     */
    getAlertSettings(signal?: AbortSignal): Promise<DeviceAlertSettings> {
        let url_ = this.baseUrl + "/api/v4/devices/alerts/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAlertSettings(_response);
        });
    }

    protected processGetAlertSettings(response: Response): Promise<DeviceAlertSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceAlertSettings;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceAlertSettings>(null as any);
    }

    /**
     * Update alert settings/preferences for device alerts
     * @param settings Alert settings
     * @return Success response
     */
    updateAlertSettings(settings: DeviceAlertSettings, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/devices/alerts/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAlertSettings(_response);
        });
    }

    protected processUpdateAlertSettings(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class DeviceHealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all devices for the current user
     * @return List of user's devices
     */
    getUserDevices(signal?: AbortSignal): Promise<DeviceHealth[]> {
        let url_ = this.baseUrl + "/api/v4/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserDevices(_response);
        });
    }

    protected processGetUserDevices(response: Response): Promise<DeviceHealth[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealth[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth[]>(null as any);
    }

    /**
     * Register a new device
     * @param request Device registration request
     * @return Registered device information
     */
    registerDevice(request: DeviceRegistrationRequest, signal?: AbortSignal): Promise<DeviceHealth> {
        let url_ = this.baseUrl + "/api/v4/devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterDevice(_response);
        });
    }

    protected processRegisterDevice(response: Response): Promise<DeviceHealth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealth;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth>(null as any);
    }

    /**
     * Get device information
     * @param id Device identifier
     * @return Device information
     */
    getDevice(id: string, signal?: AbortSignal): Promise<DeviceHealth> {
        let url_ = this.baseUrl + "/api/v4/devices/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDevice(_response);
        });
    }

    protected processGetDevice(response: Response): Promise<DeviceHealth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceHealth;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth>(null as any);
    }

    /**
     * Remove a device from the registry
     * @param id Device identifier
     * @return Success response
     */
    removeDevice(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/devices/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveDevice(_response);
        });
    }

    protected processRemoveDevice(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Update device settings
     * @param id Device identifier
     * @param settings Device settings update
     * @return Success response
     */
    updateDeviceSettings(id: string, settings: DeviceSettingsUpdate, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/devices/{id}/settings";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceSettings(_response);
        });
    }

    protected processUpdateDeviceSettings(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Update device health metrics
     * @param id Device identifier
     * @param update Device health update
     * @return Success response
     */
    updateDeviceHealth(id: string, update: DeviceHealthUpdate, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/devices/{id}/health";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceHealth(_response);
        });
    }

    protected processUpdateDeviceHealth(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class DiscrepancyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get overall compatibility metrics for dashboard overview
     * @param fromDate (optional) Start date for metrics (optional)
     * @param toDate (optional) End date for metrics (optional)
     * @return Compatibility metrics including success rate and response times
     */
    getCompatibilityMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<CompatibilityMetrics> {
        let url_ = this.baseUrl + "/api/v4/Discrepancy/metrics?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompatibilityMetrics(_response);
        });
    }

    protected processGetCompatibilityMetrics(response: Response): Promise<CompatibilityMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompatibilityMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompatibilityMetrics>(null as any);
    }

    /**
     * Get per-endpoint compatibility metrics
     * @param fromDate (optional) Start date for metrics (optional)
     * @param toDate (optional) End date for metrics (optional)
     * @return List of endpoint-specific compatibility metrics
     */
    getEndpointMetrics(fromDate?: Date | null | undefined, toDate?: Date | null | undefined, signal?: AbortSignal): Promise<EndpointMetrics[]> {
        let url_ = this.baseUrl + "/api/v4/Discrepancy/endpoints?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEndpointMetrics(_response);
        });
    }

    protected processGetEndpointMetrics(response: Response): Promise<EndpointMetrics[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EndpointMetrics[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointMetrics[]>(null as any);
    }

    /**
     * Get detailed discrepancy analyses with filtering and pagination
     * @param requestPath (optional) Filter by request path (optional)
     * @param overallMatch (optional) Filter by overall match type (optional)
     * @param fromDate (optional) Start date for filter (optional)
     * @param toDate (optional) End date for filter (optional)
     * @param count (optional) Number of results to return (default: 100, max: 1000)
     * @param skip (optional) Number of results to skip for pagination (default: 0)
     * @return List of detailed discrepancy analyses
     */
    getDiscrepancyAnalyses(requestPath?: string | null | undefined, overallMatch?: number | null | undefined, fromDate?: Date | null | undefined, toDate?: Date | null | undefined, count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<DiscrepancyAnalysisDto[]> {
        let url_ = this.baseUrl + "/api/v4/Discrepancy/analyses?";
        if (requestPath !== undefined && requestPath !== null)
            url_ += "requestPath=" + encodeURIComponent("" + requestPath) + "&";
        if (overallMatch !== undefined && overallMatch !== null)
            url_ += "overallMatch=" + encodeURIComponent("" + overallMatch) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDiscrepancyAnalyses(_response);
        });
    }

    protected processGetDiscrepancyAnalyses(response: Response): Promise<DiscrepancyAnalysisDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DiscrepancyAnalysisDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiscrepancyAnalysisDto[]>(null as any);
    }

    /**
     * Get a specific discrepancy analysis by ID
     * @param id Analysis ID
     * @return Detailed discrepancy analysis
     */
    getDiscrepancyAnalysis(id: string, signal?: AbortSignal): Promise<DiscrepancyAnalysisDto> {
        let url_ = this.baseUrl + "/api/v4/Discrepancy/analyses/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDiscrepancyAnalysis(_response);
        });
    }

    protected processGetDiscrepancyAnalysis(response: Response): Promise<DiscrepancyAnalysisDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DiscrepancyAnalysisDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiscrepancyAnalysisDto>(null as any);
    }

    /**
     * Get real-time compatibility status summary
     * @return Current compatibility status
     */
    getCompatibilityStatus(signal?: AbortSignal): Promise<CompatibilityStatus> {
        let url_ = this.baseUrl + "/api/v4/Discrepancy/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompatibilityStatus(_response);
        });
    }

    protected processGetCompatibilityStatus(response: Response): Promise<CompatibilityStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompatibilityStatus;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompatibilityStatus>(null as any);
    }

    /**
     * Receive forwarded discrepancies from remote Nocturne instances
     * @param request The forwarded discrepancy data
     * @return Acknowledgement of receipt
     */
    ingestDiscrepancy(request: ForwardedDiscrepancyDto, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v4/Discrepancy/ingest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIngestDiscrepancy(_response);
        });
    }

    protected processIngestDiscrepancy(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class FoodsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get current user's favorite foods.
     */
    getFavorites(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v4/foods/favorites";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFavorites(_response);
        });
    }

    protected processGetFavorites(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Add a food to favorites.
     */
    addFavorite(foodId: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/foods/{foodId}/favorite";
        if (foodId === undefined || foodId === null)
            throw new globalThis.Error("The parameter 'foodId' must be defined.");
        url_ = url_.replace("{foodId}", encodeURIComponent("" + foodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddFavorite(_response);
        });
    }

    protected processAddFavorite(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Remove a food from favorites.
     */
    removeFavorite(foodId: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/foods/{foodId}/favorite";
        if (foodId === undefined || foodId === null)
            throw new globalThis.Error("The parameter 'foodId' must be defined.");
        url_ = url_.replace("{foodId}", encodeURIComponent("" + foodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveFavorite(_response);
        });
    }

    protected processRemoveFavorite(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get recently used foods (excluding favorites).
     * @param limit (optional) 
     */
    getRecentFoods(limit?: number | undefined, signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v4/foods/recent?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecentFoods(_response);
        });
    }

    protected processGetRecentFoods(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }
}

export class MealMatchingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get a food entry for review
     */
    getFoodEntry(id: string, signal?: AbortSignal): Promise<ConnectorFoodEntry> {
        let url_ = this.baseUrl + "/api/v4/meal-matching/food-entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodEntry(_response);
        });
    }

    protected processGetFoodEntry(response: Response): Promise<ConnectorFoodEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorFoodEntry;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorFoodEntry>(null as any);
    }

    /**
     * Get suggested meal matches for a date range
     * @param from (optional) 
     * @param to (optional) 
     */
    getSuggestions(from?: Date | null | undefined, to?: Date | null | undefined, signal?: AbortSignal): Promise<SuggestedMealMatch[]> {
        let url_ = this.baseUrl + "/api/v4/meal-matching/suggestions?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSuggestions(_response);
        });
    }

    protected processGetSuggestions(response: Response): Promise<SuggestedMealMatch[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SuggestedMealMatch[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SuggestedMealMatch[]>(null as any);
    }

    /**
     * Accept a meal match
     */
    acceptMatch(request: AcceptMatchRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/meal-matching/accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptMatch(_response);
        });
    }

    protected processAcceptMatch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Dismiss a meal match
     */
    dismissMatch(request: DismissMatchRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/meal-matching/dismiss";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDismissMatch(_response);
        });
    }

    protected processDismissMatch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MigrationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Test a migration source connection
     */
    testConnection(request: TestMigrationConnectionRequest, signal?: AbortSignal): Promise<TestMigrationConnectionResult> {
        let url_ = this.baseUrl + "/api/v4/migration/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestConnection(_response);
        });
    }

    protected processTestConnection(response: Response): Promise<TestMigrationConnectionResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestMigrationConnectionResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestMigrationConnectionResult>(null as any);
    }

    /**
     * Start a new migration job
     */
    startMigration(request: StartMigrationRequest, signal?: AbortSignal): Promise<MigrationJobInfo> {
        let url_ = this.baseUrl + "/api/v4/migration/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartMigration(_response);
        });
    }

    protected processStartMigration(response: Response): Promise<MigrationJobInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MigrationJobInfo;
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MigrationJobInfo>(null as any);
    }

    /**
     * Get the status of a migration job
     */
    getStatus(jobId: string, signal?: AbortSignal): Promise<MigrationJobStatus> {
        let url_ = this.baseUrl + "/api/v4/migration/{jobId}/status";
        if (jobId === undefined || jobId === null)
            throw new globalThis.Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<MigrationJobStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MigrationJobStatus;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MigrationJobStatus>(null as any);
    }

    /**
     * Cancel a running migration job
     */
    cancelMigration(jobId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/migration/{jobId}/cancel";
        if (jobId === undefined || jobId === null)
            throw new globalThis.Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelMigration(_response);
        });
    }

    protected processCancelMigration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get migration job history
     */
    getHistory(signal?: AbortSignal): Promise<MigrationJobInfo[]> {
        let url_ = this.baseUrl + "/api/v4/migration/history";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<MigrationJobInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MigrationJobInfo[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MigrationJobInfo[]>(null as any);
    }

    /**
     * Get pending migration configuration from environment variables
     */
    getPendingConfig(signal?: AbortSignal): Promise<PendingMigrationConfig> {
        let url_ = this.baseUrl + "/api/v4/migration/pending-config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPendingConfig(_response);
        });
    }

    protected processGetPendingConfig(response: Response): Promise<PendingMigrationConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PendingMigrationConfig;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PendingMigrationConfig>(null as any);
    }

    /**
     * Get saved migration sources with their last migration timestamps
     */
    getSources(signal?: AbortSignal): Promise<MigrationSourceDto[]> {
        let url_ = this.baseUrl + "/api/v4/migration/sources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSources(_response);
        });
    }

    protected processGetSources(response: Response): Promise<MigrationSourceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MigrationSourceDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MigrationSourceDto[]>(null as any);
    }
}

export class MyFitnessPalSettingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get global MyFitnessPal matching settings.
     */
    getSettings(signal?: AbortSignal): Promise<MyFitnessPalMatchingSettings> {
        let url_ = this.baseUrl + "/api/v4/connectors/myfitnesspal/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<MyFitnessPalMatchingSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MyFitnessPalMatchingSettings;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MyFitnessPalMatchingSettings>(null as any);
    }

    /**
     * Update global MyFitnessPal matching settings.
     */
    saveSettings(settings: MyFitnessPalMatchingSettings, signal?: AbortSignal): Promise<MyFitnessPalMatchingSettings> {
        let url_ = this.baseUrl + "/api/v4/connectors/myfitnesspal/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveSettings(_response);
        });
    }

    protected processSaveSettings(response: Response): Promise<MyFitnessPalMatchingSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MyFitnessPalMatchingSettings;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MyFitnessPalMatchingSettings>(null as any);
    }
}

export class NotificationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all active notifications for the current user
     * @return List of active notifications
     */
    getNotifications(signal?: AbortSignal): Promise<InAppNotificationDto[]> {
        let url_ = this.baseUrl + "/api/v4/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<InAppNotificationDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InAppNotificationDto[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InAppNotificationDto[]>(null as any);
    }

    /**
     * Execute an action on a notification
     * @param id The notification ID
     * @param actionId The action ID to execute
     * @return No content if successful
     */
    executeAction(id: string, actionId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/notifications/{id}/actions/{actionId}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (actionId === undefined || actionId === null)
            throw new globalThis.Error("The parameter 'actionId' must be defined.");
        url_ = url_.replace("{actionId}", encodeURIComponent("" + actionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteAction(_response);
        });
    }

    protected processExecuteAction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Dismiss a notification (archive with dismissed reason)
     * @param id The notification ID to dismiss
     * @return No content if successful
     */
    dismissNotification(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/notifications/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDismissNotification(_response);
        });
    }

    protected processDismissNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Send Loop notification for iOS Loop app integration
    Implements the /api/v2/notifications/loop endpoint from legacy notifications-v2.js
     * @param request Loop notification request data
     * @return Notification processed successfully
     */
    sendLoopNotification(request: LoopNotificationRequest, signal?: AbortSignal): Promise<NotificationV2Response> {
        let url_ = this.baseUrl + "/api/v2/notifications/loop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendLoopNotification(_response);
        });
    }

    protected processSendLoopNotification(response: Response): Promise<NotificationV2Response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationV2Response>(null as any);
    }

    /**
     * Process a generic V2 notification
    Provides a generic endpoint for processing various notification types
     * @param notification Notification data to process
     * @return Notification processed successfully
     */
    processNotification(notification: NotificationBase, signal?: AbortSignal): Promise<NotificationV2Response> {
        let url_ = this.baseUrl + "/api/v2/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notification);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcessNotification(_response);
        });
    }

    protected processProcessNotification(response: Response): Promise<NotificationV2Response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationV2Response;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationV2Response>(null as any);
    }

    /**
     * Get current notification system status and configuration
    Provides information about the notification system capabilities and status
     * @return Notification status retrieved successfully
     */
    getNotificationStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v2/notifications/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotificationStatus(_response);
        });
    }

    protected processGetNotificationStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Acknowledge a notification alarm to silence it
    Implements the /notifications/ack endpoint from legacy notifications.js
     * @param request Acknowledgment request containing level, group, and silence time
     * @return Notification acknowledged successfully
     */
    ackNotification(request: NotificationAckRequest, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/notifications/ack";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAckNotification(_response);
        });
    }

    protected processAckNotification(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid acknowledgment request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Handle Pushover webhook callbacks for notification acknowledgments
    Implements the /notifications/pushovercallback endpoint for Pushover integration
     * @param request Pushover callback request data from webhook
     * @return Pushover callback processed successfully
     */
    pushoverCallback(request: PushoverCallbackRequest, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/notifications/pushovercallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPushoverCallback(_response);
        });
    }

    protected processPushoverCallback(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid callback request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Get all admin notifications with their counts and timestamps
    Implements the /adminnotifies endpoint from legacy adminnotifies.js
     * @return Admin notifications retrieved successfully
     */
    getAdminNotifies(signal?: AbortSignal): Promise<AdminNotifiesResponse> {
        let url_ = this.baseUrl + "/api/v1/adminnotifies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdminNotifies(_response);
        });
    }

    protected processGetAdminNotifies(response: Response): Promise<AdminNotifiesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminNotifiesResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminNotifiesResponse>(null as any);
    }

    /**
     * Add a new admin notification or increment count if it already exists
    Provides an endpoint for creating admin notifications (typically used internally)
     * @param notification Admin notification to add
     * @return Admin notification added successfully
     */
    addAdminNotification(notification: AdminNotification, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/adminnotifies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notification);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAdminNotification(_response);
        });
    }

    protected processAddAdminNotification(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Clear all admin notifications
    Provides an endpoint for clearing all admin notifications (typically used for maintenance)
     * @return Admin notifications cleared successfully
     */
    clearAllAdminNotifications(signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/adminnotifies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearAllAdminNotifications(_response);
        });
    }

    protected processClearAllAdminNotifications(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }

    /**
     * Send a Pushover notification for testing or manual triggering
    Provides an endpoint for sending Pushover notifications directly
     * @param request Pushover notification request
     * @return Pushover notification sent successfully
     */
    sendPushoverNotification(request: PushoverNotificationRequest, signal?: AbortSignal): Promise<NotificationAckResponse> {
        let url_ = this.baseUrl + "/api/v1/notifications/pushover";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendPushoverNotification(_response);
        });
    }

    protected processSendPushoverNotification(response: Response): Promise<NotificationAckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Invalid notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationAckResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAckResponse>(null as any);
    }
}

export class PredictionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get glucose predictions based on current data.
    Returns predicted glucose values for the next 4 hours in 5-minute intervals.
     * @param profileId (optional) Optional profile ID to use for predictions
     * @return Glucose predictions including IOB, UAM, COB, and zero-temp curves
     */
    getPredictions(profileId?: string | null | undefined, signal?: AbortSignal): Promise<GlucosePredictionResponse> {
        let url_ = this.baseUrl + "/api/v4/predictions?";
        if (profileId !== undefined && profileId !== null)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPredictions(_response);
        });
    }

    protected processGetPredictions(response: Response): Promise<GlucosePredictionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GlucosePredictionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PredictionErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PredictionErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlucosePredictionResponse>(null as any);
    }

    /**
     * Check if the oref prediction library is available.
     * @return Status of the oref library
     */
    getStatus(signal?: AbortSignal): Promise<PredictionStatusResponse> {
        let url_ = this.baseUrl + "/api/v4/predictions/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<PredictionStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PredictionStatusResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PredictionStatusResponse>(null as any);
    }
}

export class ProcessingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the processing status for a correlation ID
     * @param correlationId The correlation ID to check
     * @return Processing status or 404 if not found
     */
    getProcessingStatus(correlationId: string, signal?: AbortSignal): Promise<ProcessingStatusResponse> {
        let url_ = this.baseUrl + "/api/v4/processing/status/{correlationId}";
        if (correlationId === undefined || correlationId === null)
            throw new globalThis.Error("The parameter 'correlationId' must be defined.");
        url_ = url_.replace("{correlationId}", encodeURIComponent("" + correlationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessingStatus(_response);
        });
    }

    protected processGetProcessingStatus(response: Response): Promise<ProcessingStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProcessingStatusResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessingStatusResponse>(null as any);
    }

    /**
     * Wait for processing to complete with long polling
     * @param correlationId The correlation ID to wait for
     * @param timeoutSeconds (optional) Maximum time to wait in seconds (default: 30)
     * @return Processing status when completed or timeout response
     */
    waitForCompletion(correlationId: string, timeoutSeconds?: number | undefined, signal?: AbortSignal): Promise<ProcessingStatusResponse> {
        let url_ = this.baseUrl + "/api/v4/processing/status/{correlationId}/wait?";
        if (correlationId === undefined || correlationId === null)
            throw new globalThis.Error("The parameter 'correlationId' must be defined.");
        url_ = url_.replace("{correlationId}", encodeURIComponent("" + correlationId));
        if (timeoutSeconds === null)
            throw new globalThis.Error("The parameter 'timeoutSeconds' cannot be null.");
        else if (timeoutSeconds !== undefined)
            url_ += "timeoutSeconds=" + encodeURIComponent("" + timeoutSeconds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWaitForCompletion(_response);
        });
    }

    protected processWaitForCompletion(response: Response): Promise<ProcessingStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProcessingStatusResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 408) {
            return response.text().then((_responseText) => {
            let result408: any = null;
            result408 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result408);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessingStatusResponse>(null as any);
    }
}

export class RetrospectiveClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get retrospective data at a specific point in time
    Returns IOB, COB, glucose, basal rate, and recent treatments
     * @param time (optional) Unix timestamp in milliseconds for the retrospective point
     * @return Returns the retrospective data
     */
    getRetrospectiveData(time?: number | undefined, signal?: AbortSignal): Promise<RetrospectiveDataResponse> {
        let url_ = this.baseUrl + "/api/v4/Retrospective/at?";
        if (time === null)
            throw new globalThis.Error("The parameter 'time' cannot be null.");
        else if (time !== undefined)
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRetrospectiveData(_response);
        });
    }

    protected processGetRetrospectiveData(response: Response): Promise<RetrospectiveDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrospectiveDataResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the time parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RetrospectiveDataResponse>(null as any);
    }

    /**
     * Get retrospective data for an entire day at specified interval
    Returns IOB, COB, glucose, and basal data for every interval throughout the day
     * @param date (optional) Date in YYYY-MM-DD format
     * @param intervalMinutes (optional) Interval in minutes between data points (default: 5)
     * @return Returns the retrospective timeline data
     */
    getRetrospectiveTimeline(date?: string | undefined, intervalMinutes?: number | undefined, signal?: AbortSignal): Promise<RetrospectiveTimelineResponse> {
        let url_ = this.baseUrl + "/api/v4/Retrospective/timeline?";
        if (date === null)
            throw new globalThis.Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        if (intervalMinutes === null)
            throw new globalThis.Error("The parameter 'intervalMinutes' cannot be null.");
        else if (intervalMinutes !== undefined)
            url_ += "intervalMinutes=" + encodeURIComponent("" + intervalMinutes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRetrospectiveTimeline(_response);
        });
    }

    protected processGetRetrospectiveTimeline(response: Response): Promise<RetrospectiveTimelineResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrospectiveTimelineResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If parameters are invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RetrospectiveTimelineResponse>(null as any);
    }

    /**
     * Get basal rate timeline for a day
    Returns basal rate data points showing scheduled and temp basal changes
     * @param date (optional) Date in YYYY-MM-DD format
     * @param intervalMinutes (optional) Interval in minutes between data points (default: 5)
     * @return Basal rate timeline for the day
     */
    getBasalTimeline(date?: string | undefined, intervalMinutes?: number | undefined, signal?: AbortSignal): Promise<BasalTimelineResponse> {
        let url_ = this.baseUrl + "/api/v4/Retrospective/basal-timeline?";
        if (date === null)
            throw new globalThis.Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        if (intervalMinutes === null)
            throw new globalThis.Error("The parameter 'intervalMinutes' cannot be null.");
        else if (intervalMinutes !== undefined)
            url_ += "intervalMinutes=" + encodeURIComponent("" + intervalMinutes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBasalTimeline(_response);
        });
    }

    protected processGetBasalTimeline(response: Response): Promise<BasalTimelineResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasalTimelineResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BasalTimelineResponse>(null as any);
    }
}

export class ServicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get a complete overview of services, data sources, and available integrations.
     * @return Complete services overview including active data sources, connectors, and uploader apps
     */
    getServicesOverview(signal?: AbortSignal): Promise<ServicesOverview> {
        let url_ = this.baseUrl + "/api/v4/services";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServicesOverview(_response);
        });
    }

    protected processGetServicesOverview(response: Response): Promise<ServicesOverview> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServicesOverview;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServicesOverview>(null as any);
    }

    /**
     * Get all active data sources that have been sending data to this Nocturne instance.
    This includes CGM apps, AID systems, and any other uploaders.
     * @return List of active data sources with their status
     */
    getActiveDataSources(signal?: AbortSignal): Promise<DataSourceInfo[]> {
        let url_ = this.baseUrl + "/api/v4/services/data-sources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActiveDataSources(_response);
        });
    }

    protected processGetActiveDataSources(response: Response): Promise<DataSourceInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSourceInfo[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSourceInfo[]>(null as any);
    }

    /**
     * Get detailed information about a specific data source.
     * @param id Data source ID or device ID
     * @return Data source information if found
     */
    getDataSource(id: string, signal?: AbortSignal): Promise<DataSourceInfo> {
        let url_ = this.baseUrl + "/api/v4/services/data-sources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDataSource(_response);
        });
    }

    protected processGetDataSource(response: Response): Promise<DataSourceInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSourceInfo;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSourceInfo>(null as any);
    }

    /**
     * Delete all data from a specific data source.
    WARNING: This is a destructive operation that cannot be undone.
     * @param id Data source ID or device ID
     * @return Result of the delete operation
     */
    deleteDataSourceData(id: string, signal?: AbortSignal): Promise<DataSourceDeleteResult> {
        let url_ = this.baseUrl + "/api/v4/services/data-sources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDataSourceData(_response);
        });
    }

    protected processDeleteDataSourceData(response: Response): Promise<DataSourceDeleteResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSourceDeleteResult;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSourceDeleteResult>(null as any);
    }

    /**
     * Get available connectors that can be configured to pull data into Nocturne.
     * @return List of available connectors
     */
    getAvailableConnectors(signal?: AbortSignal): Promise<AvailableConnector[]> {
        let url_ = this.baseUrl + "/api/v4/services/connectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableConnectors(_response);
        });
    }

    protected processGetAvailableConnectors(response: Response): Promise<AvailableConnector[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableConnector[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvailableConnector[]>(null as any);
    }

    /**
     * Get uploader apps that can push data to Nocturne with setup instructions.
     * @return List of uploader apps with setup instructions
     */
    getUploaderApps(signal?: AbortSignal): Promise<UploaderApp[]> {
        let url_ = this.baseUrl + "/api/v4/services/uploaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUploaderApps(_response);
        });
    }

    protected processGetUploaderApps(response: Response): Promise<UploaderApp[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploaderApp[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploaderApp[]>(null as any);
    }

    /**
     * Get API endpoint information for configuring external apps.
    This provides all the information needed to configure xDrip+, Loop, AAPS, etc.
     * @return API endpoint information
     */
    getApiInfo(signal?: AbortSignal): Promise<ApiEndpointInfo> {
        let url_ = this.baseUrl + "/api/v4/services/api-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiInfo(_response);
        });
    }

    protected processGetApiInfo(response: Response): Promise<ApiEndpointInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEndpointInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEndpointInfo>(null as any);
    }

    /**
     * Get setup instructions for a specific uploader app.
     * @param appId The uploader app ID (e.g., "xdrip", "loop", "aaps")
     * @return Setup instructions for the specified app
     */
    getUploaderSetup(appId: string, signal?: AbortSignal): Promise<UploaderSetupResponse> {
        let url_ = this.baseUrl + "/api/v4/services/uploaders/{appId}/setup";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUploaderSetup(_response);
        });
    }

    protected processGetUploaderSetup(response: Response): Promise<UploaderSetupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploaderSetupResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploaderSetupResponse>(null as any);
    }

    /**
     * Delete all demo data. This operation is safe as demo data can be easily regenerated.
     * @return Result of the delete operation
     */
    deleteDemoData(signal?: AbortSignal): Promise<DataSourceDeleteResult> {
        let url_ = this.baseUrl + "/api/v4/services/data-sources/demo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDemoData(_response);
        });
    }

    protected processDeleteDemoData(response: Response): Promise<DataSourceDeleteResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSourceDeleteResult;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSourceDeleteResult>(null as any);
    }

    /**
     * Get a summary of data counts for a specific connector.
    Returns the number of entries, treatments, and device statuses synced by this connector.
     * @param id Connector ID (e.g., "dexcom")
     * @return Data summary with counts by type
     */
    getConnectorDataSummary(id: string, signal?: AbortSignal): Promise<ConnectorDataSummary> {
        let url_ = this.baseUrl + "/api/v4/services/connectors/{id}/data-summary";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConnectorDataSummary(_response);
        });
    }

    protected processGetConnectorDataSummary(response: Response): Promise<ConnectorDataSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorDataSummary;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorDataSummary>(null as any);
    }

    /**
     * Delete all data from a specific connector.
    WARNING: This is a destructive operation that cannot be undone.
     * @param id Connector ID (e.g., "dexcom")
     * @return Result of the delete operation
     */
    deleteConnectorData(id: string, signal?: AbortSignal): Promise<DataSourceDeleteResult> {
        let url_ = this.baseUrl + "/api/v4/services/connectors/{id}/data";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteConnectorData(_response);
        });
    }

    protected processDeleteConnectorData(response: Response): Promise<DataSourceDeleteResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DataSourceDeleteResult;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataSourceDeleteResult>(null as any);
    }

    /**
     * Trigger a manual sync for a specific connector with granular control.
     * @param id Connector ID
     * @param request Sync request parameters
     * @return Result of the manual sync operation
     */
    triggerConnectorSync(id: string, request: SyncRequest, signal?: AbortSignal): Promise<SyncResult> {
        let url_ = this.baseUrl + "/api/v4/services/connectors/{id}/sync";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTriggerConnectorSync(_response);
        });
    }

    protected processTriggerConnectorSync(response: Response): Promise<SyncResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SyncResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SyncResult>(null as any);
    }

    /**
     * Get the supported sync capabilities for a specific connector.
     * @param id Connector ID
     * @return List of supported data types
     */
    getConnectorCapabilities(id: string, signal?: AbortSignal): Promise<SyncDataType[]> {
        let url_ = this.baseUrl + "/api/v4/services/connectors/{id}/capabilities";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConnectorCapabilities(_response);
        });
    }

    protected processGetConnectorCapabilities(response: Response): Promise<SyncDataType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SyncDataType[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SyncDataType[]>(null as any);
    }

    /**
     * Get sync status for a specific connector, including latest timestamps and connector state.
    Used by connectors on startup to determine where to resume syncing from.
     * @param id The connector ID (e.g., "dexcom", "libre", "glooko")
     * @return Complete sync status including timestamps for entries, treatments, and connector state
     */
    getConnectorSyncStatus(id: string, signal?: AbortSignal): Promise<ConnectorSyncStatus> {
        let url_ = this.baseUrl + "/api/v4/services/connectors/{id}/sync-status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConnectorSyncStatus(_response);
        });
    }

    protected processGetConnectorSyncStatus(response: Response): Promise<ConnectorSyncStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorSyncStatus;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorSyncStatus>(null as any);
    }
}

export class StateSpansClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Query all state spans with optional filtering
     * @param category (optional) 
     * @param state (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param source (optional) 
     * @param active (optional) 
     * @param count (optional) 
     * @param skip (optional) 
     */
    getStateSpans(category?: StateSpanCategory | null | undefined, state?: string | null | undefined, from?: number | null | undefined, to?: number | null | undefined, source?: string | null | undefined, active?: boolean | null | undefined, count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans?";
        if (category !== undefined && category !== null)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (source !== undefined && source !== null)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        if (active !== undefined && active !== null)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStateSpans(_response);
        });
    }

    protected processGetStateSpans(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Create a new state span (manual entry)
     */
    createStateSpan(request: CreateStateSpanRequest, signal?: AbortSignal): Promise<StateSpan> {
        let url_ = this.baseUrl + "/api/v4/state-spans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateStateSpan(_response);
        });
    }

    protected processCreateStateSpan(response: Response): Promise<StateSpan> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan>(null as any);
    }

    /**
     * Get pump mode state spans
     * @param from (optional) 
     * @param to (optional) 
     */
    getPumpModes(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/pump-modes?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPumpModes(_response);
        });
    }

    protected processGetPumpModes(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get connectivity state spans
     * @param from (optional) 
     * @param to (optional) 
     */
    getConnectivity(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/connectivity?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConnectivity(_response);
        });
    }

    protected processGetConnectivity(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get override state spans
     * @param from (optional) 
     * @param to (optional) 
     */
    getOverrides(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/overrides?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOverrides(_response);
        });
    }

    protected processGetOverrides(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get profile state spans
     * @param from (optional) 
     * @param to (optional) 
     */
    getProfiles(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/profiles?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfiles(_response);
        });
    }

    protected processGetProfiles(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get basal delivery state spans (pump-confirmed basal rates)
     * @param from (optional) 
     * @param to (optional) 
     */
    getBasalDelivery(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/basal-delivery?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBasalDelivery(_response);
        });
    }

    protected processGetBasalDelivery(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get sleep state spans (user-annotated sleep periods)
     * @param from (optional) 
     * @param to (optional) 
     */
    getSleep(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/sleep?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSleep(_response);
        });
    }

    protected processGetSleep(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get exercise state spans (user-annotated activity periods)
     * @param from (optional) 
     * @param to (optional) 
     */
    getExercise(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/exercise?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExercise(_response);
        });
    }

    protected processGetExercise(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get illness state spans (user-annotated illness periods)
     * @param from (optional) 
     * @param to (optional) 
     */
    getIllness(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/illness?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIllness(_response);
        });
    }

    protected processGetIllness(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get travel state spans (user-annotated travel/timezone change periods)
     * @param from (optional) 
     * @param to (optional) 
     */
    getTravel(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/travel?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTravel(_response);
        });
    }

    protected processGetTravel(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get all activity state spans (sleep, exercise, illness, travel)
     * @param from (optional) 
     * @param to (optional) 
     */
    getActivities(from?: number | null | undefined, to?: number | null | undefined, signal?: AbortSignal): Promise<StateSpan[]> {
        let url_ = this.baseUrl + "/api/v4/state-spans/activities?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivities(_response);
        });
    }

    protected processGetActivities(response: Response): Promise<StateSpan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan[]>(null as any);
    }

    /**
     * Get a specific state span by ID
     */
    getStateSpan(id: string, signal?: AbortSignal): Promise<StateSpan> {
        let url_ = this.baseUrl + "/api/v4/state-spans/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStateSpan(_response);
        });
    }

    protected processGetStateSpan(response: Response): Promise<StateSpan> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan>(null as any);
    }

    /**
     * Update an existing state span
     */
    updateStateSpan(id: string, request: UpdateStateSpanRequest, signal?: AbortSignal): Promise<StateSpan> {
        let url_ = this.baseUrl + "/api/v4/state-spans/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStateSpan(_response);
        });
    }

    protected processUpdateStateSpan(response: Response): Promise<StateSpan> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StateSpan;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateSpan>(null as any);
    }

    /**
     * Delete a state span
     */
    deleteStateSpan(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/state-spans/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteStateSpan(_response);
        });
    }

    protected processDeleteStateSpan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class StatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get detailed system status information
     * @return Comprehensive system status including settings, api status, and server information
     */
    getStatus(signal?: AbortSignal): Promise<StatusResponse> {
        let url_ = this.baseUrl + "/api/v4/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<StatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusResponse>(null as any);
    }

    /**
     * Get a simple health check status
     * @return Simple ok/error status
     */
    getHealthStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v4/Status/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHealthStatus(_response);
        });
    }

    protected processGetHealthStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get the current system status with extended V3 information
     * @return Extended system status information with permissions and authorization details
     */
    getStatus2(signal?: AbortSignal): Promise<V3StatusResponse> {
        let url_ = this.baseUrl + "/api/v3/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus2(_response);
        });
    }

    protected processGetStatus2(response: Response): Promise<V3StatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3StatusResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3StatusResponse>(null as any);
    }

    /**
     * Get the current system status as JSON.
    This is the .json suffix variant that always returns JSON (Nightscout compatibility).
     * @return Status response in JSON format
     */
    getStatusJson(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/status.json";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatusJson(_response);
        });
    }

    protected processGetStatusJson(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get the current system status.
    Returns JSON when Accept header includes application/json (Nightscout client behavior),
    otherwise returns HTML for browser access.
     * @return Status response in HTML or JSON format
     */
    getStatus22(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus22(_response);
        });
    }

    protected processGetStatus22(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class SystemEventsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Query system events with optional filtering
     * @param type (optional) 
     * @param category (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param source (optional) 
     * @param count (optional) 
     * @param skip (optional) 
     */
    getSystemEvents(type?: SystemEventType | null | undefined, category?: SystemEventCategory | null | undefined, from?: number | null | undefined, to?: number | null | undefined, source?: string | null | undefined, count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<SystemEvent[]> {
        let url_ = this.baseUrl + "/api/v4/system-events?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (category !== undefined && category !== null)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (source !== undefined && source !== null)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSystemEvents(_response);
        });
    }

    protected processGetSystemEvents(response: Response): Promise<SystemEvent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SystemEvent[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemEvent[]>(null as any);
    }

    /**
     * Create a new system event (manual entry or import)
     */
    createSystemEvent(request: CreateSystemEventRequest, signal?: AbortSignal): Promise<SystemEvent> {
        let url_ = this.baseUrl + "/api/v4/system-events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSystemEvent(_response);
        });
    }

    protected processCreateSystemEvent(response: Response): Promise<SystemEvent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SystemEvent;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemEvent>(null as any);
    }

    /**
     * Get a specific system event by ID
     */
    getSystemEvent(id: string, signal?: AbortSignal): Promise<SystemEvent> {
        let url_ = this.baseUrl + "/api/v4/system-events/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSystemEvent(_response);
        });
    }

    protected processGetSystemEvent(response: Response): Promise<SystemEvent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SystemEvent;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemEvent>(null as any);
    }

    /**
     * Delete a system event
     */
    deleteSystemEvent(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/system-events/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSystemEvent(_response);
        });
    }

    protected processDeleteSystemEvent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TrackerAlertsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get pending tracker alerts for the current user
     * @return List of pending alerts that need attention
     */
    getPendingAlerts(signal?: AbortSignal): Promise<TrackerAlertDto[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/alerts/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPendingAlerts(_response);
        });
    }

    protected processGetPendingAlerts(response: Response): Promise<TrackerAlertDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerAlertDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerAlertDto[]>(null as any);
    }

    /**
     * Get available alert sounds
     * @return List of available sound preset names
     */
    getAvailableSounds(signal?: AbortSignal): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/alerts/sounds";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableSounds(_response);
        });
    }

    protected processGetAvailableSounds(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class TrackersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all tracker definitions. Returns public trackers for unauthenticated users,
    or all visible trackers for authenticated users.
     * @param category (optional) 
     */
    getDefinitions(category?: TrackerCategory | null | undefined, signal?: AbortSignal): Promise<TrackerDefinitionDto[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/definitions?";
        if (category !== undefined && category !== null)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefinitions(_response);
        });
    }

    protected processGetDefinitions(response: Response): Promise<TrackerDefinitionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerDefinitionDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerDefinitionDto[]>(null as any);
    }

    /**
     * Create a new tracker definition
     */
    createDefinition(request: CreateTrackerDefinitionRequest, signal?: AbortSignal): Promise<TrackerDefinitionDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/definitions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDefinition(_response);
        });
    }

    protected processCreateDefinition(response: Response): Promise<TrackerDefinitionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerDefinitionDto;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerDefinitionDto>(null as any);
    }

    /**
     * Get a specific tracker definition
     */
    getDefinition(id: string, signal?: AbortSignal): Promise<TrackerDefinitionDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/definitions/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefinition(_response);
        });
    }

    protected processGetDefinition(response: Response): Promise<TrackerDefinitionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerDefinitionDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerDefinitionDto>(null as any);
    }

    /**
     * Update a tracker definition
     */
    updateDefinition(id: string, request: UpdateTrackerDefinitionRequest, signal?: AbortSignal): Promise<TrackerDefinitionDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/definitions/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDefinition(_response);
        });
    }

    protected processUpdateDefinition(response: Response): Promise<TrackerDefinitionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerDefinitionDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerDefinitionDto>(null as any);
    }

    /**
     * Delete a tracker definition
     */
    deleteDefinition(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/trackers/definitions/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDefinition(_response);
        });
    }

    protected processDeleteDefinition(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get active tracker instances
     */
    getActiveInstances(signal?: AbortSignal): Promise<TrackerInstanceDto[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActiveInstances(_response);
        });
    }

    protected processGetActiveInstances(response: Response): Promise<TrackerInstanceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerInstanceDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerInstanceDto[]>(null as any);
    }

    /**
     * Start a new tracker instance
     */
    startInstance(request: StartTrackerInstanceRequest, signal?: AbortSignal): Promise<TrackerInstanceDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartInstance(_response);
        });
    }

    protected processStartInstance(response: Response): Promise<TrackerInstanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerInstanceDto;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerInstanceDto>(null as any);
    }

    /**
     * Get completed tracker instances (history)
     * @param limit (optional) 
     */
    getInstanceHistory(limit?: number | undefined, signal?: AbortSignal): Promise<TrackerInstanceDto[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances/history?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstanceHistory(_response);
        });
    }

    protected processGetInstanceHistory(response: Response): Promise<TrackerInstanceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerInstanceDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerInstanceDto[]>(null as any);
    }

    /**
     * Get upcoming tracker expirations for calendar
     * @param from (optional) 
     * @param to (optional) 
     */
    getUpcomingInstances(from?: Date | null | undefined, to?: Date | null | undefined, signal?: AbortSignal): Promise<TrackerInstanceDto[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances/upcoming?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUpcomingInstances(_response);
        });
    }

    protected processGetUpcomingInstances(response: Response): Promise<TrackerInstanceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerInstanceDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerInstanceDto[]>(null as any);
    }

    /**
     * Complete a tracker instance
     */
    completeInstance(id: string, request: CompleteTrackerInstanceRequest, signal?: AbortSignal): Promise<TrackerInstanceDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances/{id}/complete";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteInstance(_response);
        });
    }

    protected processCompleteInstance(response: Response): Promise<TrackerInstanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerInstanceDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerInstanceDto>(null as any);
    }

    /**
     * Acknowledge/snooze a tracker notification
     */
    ackInstance(id: string, request: AckTrackerRequest, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances/{id}/ack";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAckInstance(_response);
        });
    }

    protected processAckInstance(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete a tracker instance
     */
    deleteInstance(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/trackers/instances/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInstance(_response);
        });
    }

    protected processDeleteInstance(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get all presets for the current user
     */
    getPresets(signal?: AbortSignal): Promise<TrackerPresetDto[]> {
        let url_ = this.baseUrl + "/api/v4/trackers/presets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPresets(_response);
        });
    }

    protected processGetPresets(response: Response): Promise<TrackerPresetDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerPresetDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerPresetDto[]>(null as any);
    }

    /**
     * Create a new preset
     */
    createPreset(request: CreateTrackerPresetRequest, signal?: AbortSignal): Promise<TrackerPresetDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/presets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePreset(_response);
        });
    }

    protected processCreatePreset(response: Response): Promise<TrackerPresetDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerPresetDto;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerPresetDto>(null as any);
    }

    /**
     * Apply a preset (starts a new instance)
     * @param request (optional) 
     */
    applyPreset(id: string, request?: ApplyPresetRequest | undefined, signal?: AbortSignal): Promise<TrackerInstanceDto> {
        let url_ = this.baseUrl + "/api/v4/trackers/presets/{id}/apply";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyPreset(_response);
        });
    }

    protected processApplyPreset(response: Response): Promise<TrackerInstanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TrackerInstanceDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackerInstanceDto>(null as any);
    }

    /**
     * Delete a preset
     */
    deletePreset(id: string, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v4/trackers/presets/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePreset(_response);
        });
    }

    protected processDeletePreset(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TreatmentFoodsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get food breakdown for a treatment.
     */
    getTreatmentFoods(id: string, signal?: AbortSignal): Promise<TreatmentFoodBreakdown> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}/foods";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatmentFoods(_response);
        });
    }

    protected processGetTreatmentFoods(response: Response): Promise<TreatmentFoodBreakdown> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentFoodBreakdown;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentFoodBreakdown>(null as any);
    }

    /**
     * Add a food breakdown entry to a treatment.
     */
    addTreatmentFood(id: string, request: TreatmentFoodRequest, signal?: AbortSignal): Promise<TreatmentFoodBreakdown> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}/foods";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddTreatmentFood(_response);
        });
    }

    protected processAddTreatmentFood(response: Response): Promise<TreatmentFoodBreakdown> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentFoodBreakdown;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentFoodBreakdown>(null as any);
    }

    /**
     * Update a food breakdown entry.
     */
    updateTreatmentFood(id: string, foodEntryId: string, request: TreatmentFoodRequest, signal?: AbortSignal): Promise<TreatmentFoodBreakdown> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}/foods/{foodEntryId}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (foodEntryId === undefined || foodEntryId === null)
            throw new globalThis.Error("The parameter 'foodEntryId' must be defined.");
        url_ = url_.replace("{foodEntryId}", encodeURIComponent("" + foodEntryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTreatmentFood(_response);
        });
    }

    protected processUpdateTreatmentFood(response: Response): Promise<TreatmentFoodBreakdown> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentFoodBreakdown;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentFoodBreakdown>(null as any);
    }

    /**
     * Remove a food breakdown entry.
     */
    deleteTreatmentFood(id: string, foodEntryId: string, signal?: AbortSignal): Promise<TreatmentFoodBreakdown> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}/foods/{foodEntryId}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (foodEntryId === undefined || foodEntryId === null)
            throw new globalThis.Error("The parameter 'foodEntryId' must be defined.");
        url_ = url_.replace("{foodEntryId}", encodeURIComponent("" + foodEntryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTreatmentFood(_response);
        });
    }

    protected processDeleteTreatmentFood(response: Response): Promise<TreatmentFoodBreakdown> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TreatmentFoodBreakdown;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreatmentFoodBreakdown>(null as any);
    }

    /**
     * Get carb treatments with attribution status for meals view.
     * @param from (optional) 
     * @param to (optional) 
     * @param attributed (optional) 
     */
    getMeals(from?: Date | null | undefined, to?: Date | null | undefined, attributed?: boolean | null | undefined, signal?: AbortSignal): Promise<MealTreatment[]> {
        let url_ = this.baseUrl + "/api/v4/treatments/meals?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (attributed !== undefined && attributed !== null)
            url_ += "attributed=" + encodeURIComponent("" + attributed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMeals(_response);
        });
    }

    protected processGetMeals(response: Response): Promise<MealTreatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MealTreatment[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MealTreatment[]>(null as any);
    }
}

export class TreatmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get treatments with optional filtering and pagination.
    Unlike V1-V3 endpoints, this does NOT include StateSpan-derived basal data.
    For basal delivery, query /api/v4/state-spans?category=BasalDelivery instead.
     * @param eventType (optional) Optional filter by event type
     * @param count (optional) Maximum number of treatments to return (default: 100)
     * @param skip (optional) Number of treatments to skip for pagination (default: 0)
     * @param findQuery (optional) Optional MongoDB-style query filter for advanced filtering
     * @return Array of treatments ordered by most recent first
     */
    getTreatments(eventType?: string | null | undefined, count?: number | undefined, skip?: number | undefined, findQuery?: string | null | undefined, signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v4/treatments?";
        if (eventType !== undefined && eventType !== null)
            url_ += "eventType=" + encodeURIComponent("" + eventType) + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (findQuery !== undefined && findQuery !== null)
            url_ += "find=" + encodeURIComponent("" + findQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatments(_response);
        });
    }

    protected processGetTreatments(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Create a treatment with tracker integration.
    If the treatment's event type matches a tracker's trigger event types,
    the tracker instance will be automatically started/restarted.
     */
    createTreatment(treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v4/treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatment(_response);
        });
    }

    protected processCreateTreatment(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Create multiple treatments with tracker integration.
     */
    createTreatments(treatments: Treatment[], signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v4/treatments/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatments(_response);
        });
    }

    protected processCreateTreatments(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Get a specific treatment by ID
     */
    getTreatment(id: string, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatment(_response);
        });
    }

    protected processGetTreatment(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Update an existing treatment by ID
     */
    updateTreatment(id: string, treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTreatment(_response);
        });
    }

    protected processUpdateTreatment(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Delete a treatment by ID
     */
    deleteTreatment(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTreatment(_response);
        });
    }

    protected processDeleteTreatment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get treatments with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 treatments collection response
     */
    getTreatments2(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatments2(_response);
        });
    }

    protected processGetTreatments2(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create a new treatment via V3 API
     * @param treatment Treatment to create
     * @return Created treatment
     */
    createTreatment2(treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v3/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatment2(_response);
        });
    }

    protected processCreateTreatment2(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Get a specific treatment by ID with V3 format
     * @param id Treatment ID
     * @return Single treatment in V3 format
     */
    getTreatment2(id: string, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v3/Treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatment2(_response);
        });
    }

    protected processGetTreatment2(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Update a treatment via V3 API
     * @param id Treatment ID
     * @param treatment Updated treatment data
     * @return Updated treatment
     */
    updateTreatment2(id: string, treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v3/Treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTreatment2(_response);
        });
    }

    protected processUpdateTreatment2(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Delete a treatment via V3 API
     * @param id Treatment ID
     * @return No content on success
     */
    deleteTreatment2(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTreatment2(_response);
        });
    }

    protected processDeleteTreatment2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create multiple treatments via V3 API (bulk operation)
     * @param treatments Treatments to create
     * @return Created treatments
     */
    createTreatments2(treatments: Treatment[], signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v3/Treatments/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatments2(_response);
        });
    }

    protected processCreateTreatments2(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Get treatments with optional filtering and pagination
     * @param find (optional) MongoDB-style query filter for date range filtering
     * @param count (optional) Maximum number of treatments to return (default: 10)
     * @param skip (optional) Number of treatments to skip for pagination (default: 0)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Array of treatments ordered by most recent first
     */
    getTreatments2All(find?: string | null | undefined, count?: number | undefined, skip?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v1/Treatments?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatments2All(_response);
        });
    }

    protected processGetTreatments2All(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Create new treatments
     * @param treatments Treatments to create (can be single object or array)
     * @return Created treatments with assigned IDs
     */
    createTreatments22(treatments: any, signal?: AbortSignal): Promise<Treatment[]> {
        let url_ = this.baseUrl + "/api/v1/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatments);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTreatments22(_response);
        });
    }

    protected processCreateTreatments22(response: Response): Promise<Treatment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment[]>(null as any);
    }

    /**
     * Bulk delete treatments using query parameters
     * @return Number of treatments deleted
     */
    bulkDeleteTreatments(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Treatments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteTreatments(_response);
        });
    }

    protected processBulkDeleteTreatments(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get a specific treatment by ID
     * @param id Treatment ID
     * @return The treatment with the specified ID
     */
    getTreatmentById(id: string, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v1/Treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatmentById(_response);
        });
    }

    protected processGetTreatmentById(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Update an existing treatment by ID
     * @param id Treatment ID to update
     * @param treatment Updated treatment data
     * @return Updated treatment
     */
    updateTreatment22(id: string, treatment: Treatment, signal?: AbortSignal): Promise<Treatment> {
        let url_ = this.baseUrl + "/api/v1/Treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(treatment);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTreatment22(_response);
        });
    }

    protected processUpdateTreatment22(response: Response): Promise<Treatment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Treatment;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Treatment>(null as any);
    }

    /**
     * Delete a treatment by ID
     * @param id Treatment ID to delete
     * @return Success status
     */
    deleteTreatment22(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Treatments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTreatment22(_response);
        });
    }

    protected processDeleteTreatment22(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UISettingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all UI settings configuration for frontend settings pages.
    In demo mode, this fetches from the demo service.
     * @return Complete UI settings configuration
     */
    getUISettings(signal?: AbortSignal): Promise<UISettingsConfiguration> {
        let url_ = this.baseUrl + "/api/v4/ui-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUISettings(_response);
        });
    }

    protected processGetUISettings(response: Response): Promise<UISettingsConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UISettingsConfiguration;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UISettingsConfiguration>(null as any);
    }

    /**
     * Save complete UI settings configuration.
     * @param settings The complete settings to save
     * @return The saved settings
     */
    saveUISettings(settings: UISettingsConfiguration, signal?: AbortSignal): Promise<UISettingsConfiguration> {
        let url_ = this.baseUrl + "/api/v4/ui-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveUISettings(_response);
        });
    }

    protected processSaveUISettings(response: Response): Promise<UISettingsConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UISettingsConfiguration;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UISettingsConfiguration>(null as any);
    }

    /**
     * Get settings for a specific section.
     * @param section Section name: devices, therapy, algorithm, features, notifications, or services
     * @return Settings for the specified section
     */
    getSectionSettings(section: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v4/ui-settings/{section}";
        if (section === undefined || section === null)
            throw new globalThis.Error("The parameter 'section' must be defined.");
        url_ = url_.replace("{section}", encodeURIComponent("" + section));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSectionSettings(_response);
        });
    }

    protected processGetSectionSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Save notification settings including alarm configuration.
     * @param settings The notification settings to save
     * @return The saved notification settings
     */
    saveNotificationSettings(settings: NotificationSettings, signal?: AbortSignal): Promise<NotificationSettings> {
        let url_ = this.baseUrl + "/api/v4/ui-settings/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveNotificationSettings(_response);
        });
    }

    protected processSaveNotificationSettings(response: Response): Promise<NotificationSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationSettings;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSettings>(null as any);
    }

    /**
     * Get alarm profiles configuration (xDrip+-style).
     * @return The alarm configuration
     */
    getAlarmConfiguration(signal?: AbortSignal): Promise<UserAlarmConfiguration> {
        let url_ = this.baseUrl + "/api/v4/ui-settings/notifications/alarms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAlarmConfiguration(_response);
        });
    }

    protected processGetAlarmConfiguration(response: Response): Promise<UserAlarmConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAlarmConfiguration;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAlarmConfiguration>(null as any);
    }

    /**
     * Save alarm profiles configuration (xDrip+-style).
     * @param config The alarm configuration to save
     * @return The saved alarm configuration
     */
    saveAlarmConfiguration(config: UserAlarmConfiguration, signal?: AbortSignal): Promise<UserAlarmConfiguration> {
        let url_ = this.baseUrl + "/api/v4/ui-settings/notifications/alarms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveAlarmConfiguration(_response);
        });
    }

    protected processSaveAlarmConfiguration(response: Response): Promise<UserAlarmConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAlarmConfiguration;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAlarmConfiguration>(null as any);
    }

    /**
     * Save a specific alarm profile.
     * @param profile The alarm profile to save
     * @return The saved alarm configuration
     */
    addOrUpdateAlarmProfile(profile: AlarmProfileConfiguration, signal?: AbortSignal): Promise<UserAlarmConfiguration> {
        let url_ = this.baseUrl + "/api/v4/ui-settings/notifications/alarms/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddOrUpdateAlarmProfile(_response);
        });
    }

    protected processAddOrUpdateAlarmProfile(response: Response): Promise<UserAlarmConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAlarmConfiguration;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAlarmConfiguration>(null as any);
    }

    /**
     * Delete an alarm profile by ID.
     * @param profileId The profile ID to delete
     * @return The updated alarm configuration
     */
    deleteAlarmProfile(profileId: string, signal?: AbortSignal): Promise<UserAlarmConfiguration> {
        let url_ = this.baseUrl + "/api/v4/ui-settings/notifications/alarms/profiles/{profileId}";
        if (profileId === undefined || profileId === null)
            throw new globalThis.Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAlarmProfile(_response);
        });
    }

    protected processDeleteAlarmProfile(response: Response): Promise<UserAlarmConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAlarmConfiguration;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAlarmConfiguration>(null as any);
    }
}

export class UserPreferencesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current user's preferences
     * @return User preferences
     */
    getPreferences(signal?: AbortSignal): Promise<UserPreferencesResponse> {
        let url_ = this.baseUrl + "/api/v4/user/preferences";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPreferences(_response);
        });
    }

    protected processGetPreferences(response: Response): Promise<UserPreferencesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserPreferencesResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPreferencesResponse>(null as any);
    }

    /**
     * Update the current user's preferences
     * @param request The preferences to update
     * @return Updated preferences
     */
    updatePreferences(request: UpdateUserPreferencesRequest, signal?: AbortSignal): Promise<UserPreferencesResponse> {
        let url_ = this.baseUrl + "/api/v4/user/preferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePreferences(_response);
        });
    }

    protected processUpdatePreferences(response: Response): Promise<UserPreferencesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserPreferencesResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPreferencesResponse>(null as any);
    }
}

export class DeviceStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get device status records with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 device status collection response
     */
    getDeviceStatus(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatus(_response);
        });
    }

    protected processGetDeviceStatus(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new device status records with V3 format and deduplication support
     * @param deviceStatusData Device status data to create (single object or array)
     * @return Created device status records
     */
    createDeviceStatus(deviceStatusData: any, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceStatusData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDeviceStatus(_response);
        });
    }

    protected processCreateDeviceStatus(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }

    /**
     * Get a specific device status record by ID with V3 format
     * @param id Device status ID
     * @return Single device status record in V3 format
     */
    getDeviceStatusById(id: string, signal?: AbortSignal): Promise<DeviceStatus> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatusById(_response);
        });
    }

    protected processGetDeviceStatusById(response: Response): Promise<DeviceStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus>(null as any);
    }

    /**
     * Update a device status record by ID with V3 format
     * @param id Device status ID to update
     * @param request Updated device status data
     * @return Updated device status record
     */
    updateDeviceStatus(id: string, request: any, signal?: AbortSignal): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceStatus(_response);
        });
    }

    protected processUpdateDeviceStatus(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: any; };
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }

    /**
     * Delete a device status record by ID
     * @param id Device status ID to delete
     * @return No content on success
     */
    deleteDeviceStatus(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDeviceStatus(_response);
        });
    }

    protected processDeleteDeviceStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get device status entries with optional filtering and pagination
     * @param count (optional) Maximum number of device status entries to return (default: 10)
     * @param skip (optional) Number of device status entries to skip for pagination (default: 0)
     * @param format (optional) Output format: json (default), csv, tsv, or txt
     * @return Array of device status entries ordered by most recent first
     */
    getDeviceStatus2(count?: number | undefined, skip?: number | undefined, format?: string | undefined, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus?";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatus2(_response);
        });
    }

    protected processGetDeviceStatus2(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }

    /**
     * Create new device status entries
     * @param body Device status entry or array of entries to create (accepts both single object and array)
     * @return Created device status entries with assigned IDs
     */
    createDeviceStatus2(body: any, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDeviceStatus2(_response);
        });
    }

    protected processCreateDeviceStatus2(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }

    /**
     * Bulk delete device status entries using query filters
     * @return Number of deleted entries
     */
    bulkDeleteDeviceStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteDeviceStatus(_response);
        });
    }

    protected processBulkDeleteDeviceStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Delete a device status entry by ID
     * @param id Device status ID to delete
     * @return Success status
     */
    deleteDeviceStatus2(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/DeviceStatus/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDeviceStatus2(_response);
        });
    }

    protected processDeleteDeviceStatus2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Alternative endpoint for device status - supports .json extension
     * @param count (optional) Maximum number of device status entries to return (default: 10)
     * @param skip (optional) Number of device status entries to skip for pagination (default: 0)
     * @return Array of device status entries ordered by most recent first
     */
    getDeviceStatusJson(count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<DeviceStatus[]> {
        let url_ = this.baseUrl + "/api/v1/devicestatus.json?";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceStatusJson(_response);
        });
    }

    protected processGetDeviceStatusJson(response: Response): Promise<DeviceStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeviceStatus[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceStatus[]>(null as any);
    }
}

export class EntriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get entries with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 entries collection response
     */
    getEntries(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Entries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntries(_response);
        });
    }

    protected processGetEntries(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create a new entry via V3 API
     * @param entry Entry to create
     * @return Created entry
     */
    createEntry(entry: Entry, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v3/Entries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entry);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntry(_response);
        });
    }

    protected processCreateEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Get a specific entry by ID with V3 format
     * @param id Entry ID
     * @return Single entry in V3 format
     */
    getEntry(id: string, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v3/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry(_response);
        });
    }

    protected processGetEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Update an entry via V3 API
     * @param id Entry ID
     * @param entry Updated entry data
     * @return Updated entry
     */
    updateEntry(id: string, entry: Entry, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v3/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entry);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntry(_response);
        });
    }

    protected processUpdateEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Delete an entry via V3 API
     * @param id Entry ID
     * @return No content on success
     */
    deleteEntry(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntry(_response);
        });
    }

    protected processDeleteEntry(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create multiple entries via V3 API (bulk operation)
     * @param entries Entries to create
     * @return Created entries
     */
    createEntries(entries: Entry[], signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v3/Entries/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entries);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntries(_response);
        });
    }

    protected processCreateEntries(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Get the most recent glucose entry
    This endpoint assumes SGV (sensor glucose value) type and returns the single most recent entry
     * @return The most recent glucose entry, or empty array if no entries exist
     */
    getCurrentEntry(signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentEntry(_response);
        });
    }

    protected processGetCurrentEntry(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Get a specific entry by ID or get entries by type
     * @param spec Either an entry ID (24-character hex string) or entry type (e.g., "sgv", "mbg", "cal")
     * @return Entry or entries matching the specification
     */
    getEntry2(spec: string, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries/{spec}";
        if (spec === undefined || spec === null)
            throw new globalThis.Error("The parameter 'spec' must be defined.");
        url_ = url_.replace("{spec}", encodeURIComponent("" + spec));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry2(_response);
        });
    }

    protected processGetEntry2(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Get entries with optional query parameters
    Supports advanced query features including find filters, date ranges, and pagination
     * @param find (optional) MongoDB-style find query filters (JSON format) - for unit tests
     * @param count (optional) Maximum number of entries to return (if not specified, returns all matching entries)
     * @param dateString (optional) ISO date string for date filtering
     * @param type (optional) Entry type filter (default: "sgv")
     * @param rr (optional) Reverse results (latest first)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Array of entries matching the criteria
     */
    getEntries2(find?: string | null | undefined, count?: number | null | undefined, dateString?: string | null | undefined, type?: string | null | undefined, rr?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (count !== undefined && count !== null)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (dateString !== undefined && dateString !== null)
            url_ += "dateString=" + encodeURIComponent("" + dateString) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (rr === null)
            throw new globalThis.Error("The parameter 'rr' cannot be null.");
        else if (rr !== undefined)
            url_ += "rr=" + encodeURIComponent("" + rr) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntries2(_response);
        });
    }

    protected processGetEntries2(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Create new entries
    Accepts both single entries and arrays of entries
     * @param entryData Entry data to create (can be single entry or array)
     * @return Created entries with assigned IDs
     */
    createEntries2All(entryData: any, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/Entries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entryData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntries2All(_response);
        });
    }

    protected processCreateEntries2All(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Bulk delete entries with query filter
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Confirmation of bulk deletion
     */
    bulkDeleteEntries(find?: string | null | undefined, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Entries?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteEntries(_response);
        });
    }

    protected processBulkDeleteEntries(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Update an existing entry by ID
     * @param id The entry ID to update
     * @param entryData Updated entry data
     * @return Updated entry
     */
    updateEntry2(id: string, entryData: Entry, signal?: AbortSignal): Promise<Entry> {
        let url_ = this.baseUrl + "/api/v1/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entryData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntry2(_response);
        });
    }

    protected processUpdateEntry2(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Delete an entry by ID
     * @param id The entry ID to delete
     * @return Confirmation of deletion
     */
    deleteEntry2(id: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntry2(_response);
        });
    }

    protected processDeleteEntry2(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Create new entries asynchronously
    Accepts both single entries and arrays of entries, returns immediately with tracking information
     * @param entryData Entry data to create (can be single entry or array)
     * @return Async processing response with correlation ID and status URL
     */
    createEntries2(entryData: any, signal?: AbortSignal): Promise<AsyncProcessingResponse> {
        let url_ = this.baseUrl + "/api/v1/Entries/async";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entryData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntries2(_response);
        });
    }

    protected processCreateEntries2(response: Response): Promise<AsyncProcessingResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AsyncProcessingResponse;
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AsyncProcessingResponse>(null as any);
    }
}

export class FoodClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get food records with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 food collection response
     */
    getFood(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Food";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFood(_response);
        });
    }

    protected processGetFood(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new food records with V3 format and deduplication support
    Nightscout V3 API requires date field validation before processing
     * @param foodData Food data to create (single object or array)
     * @return Created food records
     */
    createFood(foodData: any, signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v3/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foodData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFood(_response);
        });
    }

    protected processCreateFood(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get a specific food record by ID with V3 format
     * @param id Food ID
     * @return Single food record in V3 format
     */
    getFoodById(id: string, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v3/Food/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodById(_response);
        });
    }

    protected processGetFoodById(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Update a food record by ID with V3 format
    Nightscout V3 API requires date field validation before checking document existence
     * @param id Food ID to update
     * @param foodData Updated food data as JSON
     * @return Updated food record
     */
    updateFood(id: string, foodData: any, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v3/Food/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foodData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFood(_response);
        });
    }

    protected processUpdateFood(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Delete a food record by ID
     * @param id Food ID to delete
     * @return No content on success
     */
    deleteFood(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Food/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFood(_response);
        });
    }

    protected processDeleteFood(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all food records (both food and quickpick types)
     * @return Array of food records ordered by name/position
     */
    getFood2(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFood2(_response);
        });
    }

    protected processGetFood2(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Create new food records
     * @param foods Food records to create (can be single object or array)
     * @return Created food records with assigned IDs
     */
    createFood2(foods: any, signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foods);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFood2(_response);
        });
    }

    protected processCreateFood2(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Alternative update endpoint compatible with legacy PUT without ID in URL
     * @param food Food data with ID
     * @return Updated food record
     */
    updateFoodLegacy(food: Food, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(food);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFoodLegacy(_response);
        });
    }

    protected processUpdateFoodLegacy(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Bulk delete food records by filter query
    Compatible with Nightscout's DELETE /api/v1/food?find[field]=value
    Note: Nightscout V1 API doesn't officially support bulk delete, but returns 200 {} for such requests
     * @return Empty object for parity with Nightscout
     */
    deleteFoodByFilter(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Food";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFoodByFilter(_response);
        });
    }

    protected processDeleteFoodByFilter(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Alternative endpoint with .json extension for compatibility
     * @return Array of food records
     */
    getFoodJson(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/food.json";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodJson(_response);
        });
    }

    protected processGetFoodJson(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get regular food records only (type="food")
     * @return Array of regular food records
     */
    getRegularFood(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food/regular";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegularFood(_response);
        });
    }

    protected processGetRegularFood(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get quickpick food records only (type="quickpick" and hidden="false")
    Matches Nightscout's listquickpicks behavior which filters by hidden='false' and sorts by position
     * @return Array of quickpick food records ordered by position
     */
    getQuickPickFood(signal?: AbortSignal): Promise<Food[]> {
        let url_ = this.baseUrl + "/api/v1/Food/quickpicks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuickPickFood(_response);
        });
    }

    protected processGetQuickPickFood(response: Response): Promise<Food[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food[]>(null as any);
    }

    /**
     * Get a specific food record by ID
     * @param id Food record ID
     * @return The food record with the specified ID
     */
    getFoodById2(id: string, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v1/Food/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoodById2(_response);
        });
    }

    protected processGetFoodById2(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Update an existing food record by ID
     * @param id Food record ID to update
     * @param food Updated food data
     * @return Updated food record
     */
    updateFood2(id: string, food: Food, signal?: AbortSignal): Promise<Food> {
        let url_ = this.baseUrl + "/api/v1/Food/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(food);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFood2(_response);
        });
    }

    protected processUpdateFood2(response: Response): Promise<Food> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Food;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Food>(null as any);
    }

    /**
     * Delete a food record by ID
     * @param id Food record ID to delete
     * @return No content if successful
     */
    deleteFood2(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Food/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFood2(_response);
        });
    }

    protected processDeleteFood2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LastModifiedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get last modified timestamps for all collections
     * @return Last modified timestamps for each collection
     */
    getLastModified(signal?: AbortSignal): Promise<LastModifiedResponse> {
        let url_ = this.baseUrl + "/api/v3/LastModified";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastModified(_response);
        });
    }

    protected processGetLastModified(response: Response): Promise<LastModifiedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LastModifiedResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LastModifiedResponse>(null as any);
    }
}

export class ProfileClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get profiles with V3 API features including pagination, field selection, and advanced filtering
     * @return V3 profiles collection response
     */
    getProfiles(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfiles(_response);
        });
    }

    protected processGetProfiles(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new profiles with V3 format and deduplication support
     * @param profileData Profile data to create (single object or array)
     * @return Created profiles
     */
    createProfile(profileData: any, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v3/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profileData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProfile(_response);
        });
    }

    protected processCreateProfile(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Get a specific profile by ID with V3 format
     * @param id Profile ID
     * @return Single profile in V3 format
     */
    getProfileById(id: string, signal?: AbortSignal): Promise<Profile> {
        let url_ = this.baseUrl + "/api/v3/Profile/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfileById(_response);
        });
    }

    protected processGetProfileById(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * Update a profile by ID with V3 format
     * @param id Profile ID to update
     * @param profile Updated profile data
     * @return Updated profile
     */
    updateProfile(id: string, profile: Profile, signal?: AbortSignal): Promise<Profile> {
        let url_ = this.baseUrl + "/api/v3/Profile/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * Delete a profile by ID
     * @param id Profile ID to delete
     * @return No content on success
     */
    deleteProfile(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Profile/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProfile(_response);
        });
    }

    protected processDeleteProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get profiles with optional pagination
     * @param count (optional) Maximum number of profiles to return (default: 10)
     * @return List of profiles
     */
    getProfiles2(count?: number | undefined, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile?";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfiles2(_response);
        });
    }

    protected processGetProfiles2(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Create or update a profile.
    Nightscout accepts either a single profile object or an array of profiles.
     * @param body Profile(s) to create or update (single object or array)
     * @return Created profiles with assigned IDs as an array
     */
    createProfiles(body: any, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProfiles(_response);
        });
    }

    protected processCreateProfiles(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Get the current active profile
     * @return The current active profile as a single object (Nightscout format), or empty array if no profiles exist
     */
    getCurrentProfile(signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentProfile(_response);
        });
    }

    protected processGetCurrentProfile(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * Get a specific profile by ID or treat the spec as a profile ID
     * @param spec The profile ID (24-character hex string for MongoDB ObjectId)
     * @return The profile with the specified ID, or empty array if not found
     */
    getProfile(spec: string, signal?: AbortSignal): Promise<Profile[]> {
        let url_ = this.baseUrl + "/api/v1/Profile/{spec}";
        if (spec === undefined || spec === null)
            throw new globalThis.Error("The parameter 'spec' must be defined.");
        url_ = url_.replace("{spec}", encodeURIComponent("" + spec));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            let result304: any = null;
            result304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result304);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }
}

export class SettingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get settings with V3 API features including pagination, field selection, and advanced filtering
    Requires admin permissions as per legacy API v3 behavior
     * @return V3 settings collection response
     */
    getSettings(signal?: AbortSignal): Promise<V3CollectionResponseOfObject> {
        let url_ = this.baseUrl + "/api/v3/Settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<V3CollectionResponseOfObject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3CollectionResponseOfObject;
            return result200;
            });
        } else if (status === 304) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<V3CollectionResponseOfObject>(null as any);
    }

    /**
     * Create new settings records with V3 format and deduplication support
    Requires admin permissions as per legacy API v3 behavior
     * @param settingsData Settings data to create (single object or array)
     * @return Created settings records
     */
    createSettings(settingsData: any, signal?: AbortSignal): Promise<Settings[]> {
        let url_ = this.baseUrl + "/api/v3/Settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settingsData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSettings(_response);
        });
    }

    protected processCreateSettings(response: Response): Promise<Settings[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Settings[];
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings[]>(null as any);
    }

    /**
     * Get a specific settings record by ID with V3 format
    Requires admin permissions as per legacy API v3 behavior
     * @param id Settings ID
     * @return Single settings record in V3 format
     */
    getSettingsById(id: string, signal?: AbortSignal): Promise<Settings> {
        let url_ = this.baseUrl + "/api/v3/Settings/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettingsById(_response);
        });
    }

    protected processGetSettingsById(response: Response): Promise<Settings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Settings;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings>(null as any);
    }

    /**
     * Update a settings record by ID with V3 format
    Requires admin permissions as per legacy API v3 behavior
     * @param id Settings ID to update
     * @param settings Updated settings data
     * @return Updated settings record
     */
    updateSettings(id: string, settings: Settings, signal?: AbortSignal): Promise<Settings> {
        let url_ = this.baseUrl + "/api/v3/Settings/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSettings(_response);
        });
    }

    protected processUpdateSettings(response: Response): Promise<Settings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Settings;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings>(null as any);
    }

    /**
     * Delete a settings record by ID
    Requires admin permissions as per legacy API v3 behavior
     * @param id Settings ID to delete
     * @return No content on success
     */
    deleteSettings(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v3/Settings/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSettings(_response);
        });
    }

    protected processDeleteSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as V3ErrorResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VersionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get the current system version information
     * @return Version information
     */
    getVersion(signal?: AbortSignal): Promise<VersionResponse> {
        let url_ = this.baseUrl + "/api/v3/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<VersionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionResponse>(null as any);
    }
}

export class DDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get current DData structure
    Returns comprehensive data structure containing SGVs, treatments, profiles, and device status
     * @return Returns the DData structure
     */
    getDData(signal?: AbortSignal): Promise<DDataResponse> {
        let url_ = this.baseUrl + "/api/v2/ddata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDData(_response);
        });
    }

    protected processGetDData(response: Response): Promise<DDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DDataResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DDataResponse>(null as any);
    }

    /**
     * Get DData structure for a specific timestamp
    Returns data relevant to the specified timestamp
     * @param timestamp Unix timestamp in milliseconds or ISO date string
     * @return Returns the DData structure
     */
    getDDataAt(timestamp: string, signal?: AbortSignal): Promise<DDataResponse> {
        let url_ = this.baseUrl + "/api/v2/ddata/at/{timestamp}";
        if (timestamp === undefined || timestamp === null)
            throw new globalThis.Error("The parameter 'timestamp' must be defined.");
        url_ = url_.replace("{timestamp}", encodeURIComponent("" + timestamp));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDDataAt(_response);
        });
    }

    protected processGetDDataAt(response: Response): Promise<DDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DDataResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the timestamp parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DDataResponse>(null as any);
    }

    /**
     * Get raw DData structure (without recent status filtering)
    Returns the complete DData structure without filtering recent device statuses
     * @param timestamp (optional) Optional Unix timestamp in milliseconds or ISO date string
     * @return Returns the raw DData structure
     */
    getRawDData(timestamp?: string | null | undefined, signal?: AbortSignal): Promise<DData> {
        let url_ = this.baseUrl + "/api/v2/ddata/raw?";
        if (timestamp !== undefined && timestamp !== null)
            url_ += "timestamp=" + encodeURIComponent("" + timestamp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRawDData(_response);
        });
    }

    protected processGetRawDData(response: Response): Promise<DData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DData;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the timestamp parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DData>(null as any);
    }
}

export class LoopClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Send Loop notification directly to iOS Loop app via APNS
    Implements the legacy ctx.loop.sendNotification() functionality with 1:1 compatibility
    This endpoint expects the exact data structure used by the legacy loop.js implementation
     * @param request Loop notification data and settings
     * @return Loop notification sent successfully
     */
    sendLoopNotification(request: LoopSendRequest, signal?: AbortSignal): Promise<LoopNotificationResponse> {
        let url_ = this.baseUrl + "/api/v2/loop/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendLoopNotification(_response);
        });
    }

    protected processSendLoopNotification(response: Response): Promise<LoopNotificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoopNotificationResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoopNotificationResponse;
            return throwException("Invalid Loop notification request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoopNotificationResponse;
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoopNotificationResponse>(null as any);
    }

    /**
     * Get Loop service configuration status
    Provides debugging information about Loop/APNS configuration
     * @return Configuration status retrieved successfully
     */
    getLoopStatus(signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v2/loop/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoopStatus(_response);
        });
    }

    protected processGetLoopStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class PropertiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all client properties and settings
    Returns comprehensive properties structure containing plugin data, settings, and computed values
     * @param pretty (optional) Format JSON with indentation for readability
     * @return Returns the properties structure
     */
    getAllProperties(pretty?: boolean | undefined, signal?: AbortSignal): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/v2/properties?";
        if (pretty === null)
            throw new globalThis.Error("The parameter 'pretty' cannot be null.");
        else if (pretty !== undefined)
            url_ += "pretty=" + encodeURIComponent("" + pretty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProperties(_response);
        });
    }

    protected processGetAllProperties(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: any; };
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }

    /**
     * Get specific properties by names (comma-separated)
    Supports paths like /prop1 or /prop1,prop3 to get only specific properties
     * @param propertyPath Comma-separated list of property names to retrieve
     * @param pretty (optional) Format JSON with indentation for readability
     * @return Returns the selected properties
     */
    getSpecificProperties(propertyPath: string, pretty?: boolean | undefined, signal?: AbortSignal): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/v2/properties/{propertyPath}?";
        if (propertyPath === undefined || propertyPath === null)
            throw new globalThis.Error("The parameter 'propertyPath' must be defined.");
        url_ = url_.replace("{propertyPath}", encodeURIComponent("" + propertyPath));
        if (pretty === null)
            throw new globalThis.Error("The parameter 'pretty' cannot be null.");
        else if (pretty !== undefined)
            url_ += "pretty=" + encodeURIComponent("" + pretty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpecificProperties(_response);
        });
    }

    protected processGetSpecificProperties(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: any; };
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If property names are invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }
}

export class SummaryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get summary data for the specified time window
    Returns processed SGVs, treatments, profile, and state information
     * @param hours (optional) Number of hours to include in summary (default 6)
     * @return Returns the summary data
     */
    getSummary(hours?: number | null | undefined, signal?: AbortSignal): Promise<SummaryResponse> {
        let url_ = this.baseUrl + "/api/v2/summary?";
        if (hours !== undefined && hours !== null)
            url_ += "hours=" + encodeURIComponent("" + hours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: Response): Promise<SummaryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SummaryResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If the hours parameter is invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SummaryResponse>(null as any);
    }
}

export class ActivityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all activities with optional filtering and pagination
     * @param count (optional) Maximum number of activities to return (default: 10)
     * @param skip (optional) Number of activities to skip for pagination (default: 0)
     * @return Activities retrieved successfully
     */
    getActivities(count?: number | undefined, skip?: number | undefined, signal?: AbortSignal): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/v1/Activity?";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivities(_response);
        });
    }

    protected processGetActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * Create one or more new activities
     * @param activities Activity data (single object or array)
     * @return Activities created successfully (Nightscout compatibility)
     */
    createActivities(activities: any, signal?: AbortSignal): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/v1/Activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activities);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateActivities(_response);
        });
    }

    protected processCreateActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid activity data", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * Get a specific activity by ID
     * @param id Activity ID
     * @return Activity found and returned
     */
    getActivity(id: string, signal?: AbortSignal): Promise<Activity> {
        let url_ = this.baseUrl + "/api/v1/Activity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivity(_response);
        });
    }

    protected processGetActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Activity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * Update an existing activity
     * @param id Activity ID to update
     * @param activity Updated activity data
     * @return Activity updated successfully
     */
    updateActivity(id: string, activity: Activity, signal?: AbortSignal): Promise<Activity> {
        let url_ = this.baseUrl + "/api/v1/Activity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity(_response);
        });
    }

    protected processUpdateActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Activity;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Invalid activity data", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Activity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * Delete an activity by ID
     * @param id Activity ID to delete
     * @return Activity deleted successfully
     */
    deleteActivity(id: string, signal?: AbortSignal): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/Activity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity(_response);
        });
    }

    protected processDeleteActivity(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Activity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class AlexaClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Handle Alexa Skills Kit requests for voice assistant integration
    Processes LaunchRequest, IntentRequest, and SessionEndedRequest types
    Maintains complete compatibility with legacy /api/alexa endpoint
     * @param request Alexa Skills Kit request from Amazon
     * @return Alexa response with speech output and session handling
     */
    handleAlexaRequest(request: AlexaRequest, signal?: AbortSignal): Promise<AlexaResponse> {
        let url_ = this.baseUrl + "/api/Alexa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleAlexaRequest(_response);
        });
    }

    protected processHandleAlexaRequest(response: Response): Promise<AlexaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlexaResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlexaResponse>(null as any);
    }
}

export class CountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Count entries matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @param type (optional) Entry type filter (sgv, mbg, cal)
     * @return Count of entries matching the criteria
     */
    countEntries(find?: string | null | undefined, type?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/entries/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountEntries(_response);
        });
    }

    protected processCountEntries(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Count treatments matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Count of treatments matching the criteria
     */
    countTreatments(find?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/treatments/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountTreatments(_response);
        });
    }

    protected processCountTreatments(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Count device status entries matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Count of device status entries matching the criteria
     */
    countDeviceStatus(find?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/devicestatus/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountDeviceStatus(_response);
        });
    }

    protected processCountDeviceStatus(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Count activity entries matching specific criteria
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @return Count of activity entries matching the criteria
     */
    countActivity(find?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/activity/where?";
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountActivity(_response);
        });
    }

    protected processCountActivity(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    /**
     * Generic count endpoint for any storage type
     * @param storage Storage type (entries, treatments, devicestatus, profile, food, activity)
     * @param find (optional) MongoDB-style find query filters (JSON format)
     * @param type (optional) Additional type filter (for entries: sgv, mbg, cal)
     * @return Count of records matching the criteria
     */
    countGeneric(storage: string, find?: string | null | undefined, type?: string | null | undefined, signal?: AbortSignal): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/v1/Count/{storage}/where?";
        if (storage === undefined || storage === null)
            throw new globalThis.Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (find !== undefined && find !== null)
            url_ += "find=" + encodeURIComponent("" + find) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountGeneric(_response);
        });
    }

    protected processCountGeneric(response: Response): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountResponse>(null as any);
    }
}

export class IobClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Calculate current IOB from treatments and device status
     * @param time (optional) Optional timestamp for calculation (default: current time)
     * @return Returns the current IOB calculation
     */
    getCurrentIob(time?: number | null | undefined, signal?: AbortSignal): Promise<IobResult> {
        let url_ = this.baseUrl + "/api/v1/Iob?";
        if (time !== undefined && time !== null)
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentIob(_response);
        });
    }

    protected processGetCurrentIob(response: Response): Promise<IobResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IobResult;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IobResult>(null as any);
    }

    /**
     * Calculate IOB from treatments only (excluding device status)
     * @param time (optional) Optional timestamp for calculation (default: current time)
     * @return Returns the IOB calculation from treatments
     */
    getIobFromTreatments(time?: number | null | undefined, signal?: AbortSignal): Promise<IobResult> {
        let url_ = this.baseUrl + "/api/v1/Iob/treatments?";
        if (time !== undefined && time !== null)
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIobFromTreatments(_response);
        });
    }

    protected processGetIobFromTreatments(response: Response): Promise<IobResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IobResult;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IobResult>(null as any);
    }

    /**
     * Calculate hourly IOB breakdown for charts and analysis
     * @param intervalMinutes (optional) Time interval in minutes for calculations (default: 5)
     * @param hours (optional) Number of hours to calculate (default: 24)
     * @param startTime (optional) Start time for calculation (default: 24 hours ago)
     * @return Returns the hourly IOB breakdown
     */
    getHourlyIob(intervalMinutes?: number | undefined, hours?: number | undefined, startTime?: number | null | undefined, signal?: AbortSignal): Promise<HourlyIobResponse> {
        let url_ = this.baseUrl + "/api/v1/Iob/hourly?";
        if (intervalMinutes === null)
            throw new globalThis.Error("The parameter 'intervalMinutes' cannot be null.");
        else if (intervalMinutes !== undefined)
            url_ += "intervalMinutes=" + encodeURIComponent("" + intervalMinutes) + "&";
        if (hours === null)
            throw new globalThis.Error("The parameter 'hours' cannot be null.");
        else if (hours !== undefined)
            url_ += "hours=" + encodeURIComponent("" + hours) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "startTime=" + encodeURIComponent("" + startTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHourlyIob(_response);
        });
    }

    protected processGetHourlyIob(response: Response): Promise<HourlyIobResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HourlyIobResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("If parameters are invalid", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If there was an internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HourlyIobResponse>(null as any);
    }
}

export class TimeQueryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Complex time pattern matching with bash-style brace expansion
     * @param prefix Time prefix pattern (e.g., "2015-04", "20{14..15}")
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the time patterns
     */
    getTimeBasedEntriesWithPrefix(prefix: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/times/{prefix}?";
        if (prefix === undefined || prefix === null)
            throw new globalThis.Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeBasedEntriesWithPrefix(_response);
        });
    }

    protected processGetTimeBasedEntriesWithPrefix(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Complex time pattern matching with bash-style brace expansion
     * @param prefix Time prefix pattern (e.g., "2015-04", "20{14..15}")
     * @param regex Time regex pattern (e.g., "T{13..18}:{00..15}")
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the time patterns
     */
    getTimeBasedEntriesWithPrefixAndRegex(prefix: string, regex: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/times/{prefix}/{regex}?";
        if (prefix === undefined || prefix === null)
            throw new globalThis.Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (regex === undefined || regex === null)
            throw new globalThis.Error("The parameter 'regex' must be defined.");
        url_ = url_.replace("{regex}", encodeURIComponent("" + regex));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeBasedEntriesWithPrefixAndRegex(_response);
        });
    }

    protected processGetTimeBasedEntriesWithPrefixAndRegex(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Time query debugging and pattern inspection
    Shows how the time patterns are expanded and what MongoDB query would be generated
     * @param storage (optional) Storage type (entries, treatments, devicestatus)
     * @param field (optional) Field name to match patterns against
     * @return Debug information about the generated patterns and query
     */
    getTimeQueryEcho(storage?: string | undefined, field?: string | undefined, signal?: AbortSignal): Promise<TimeQueryEcho> {
        let url_ = this.baseUrl + "/api/v1/times/echo?";
        if (storage === null)
            throw new globalThis.Error("The parameter 'storage' cannot be null.");
        else if (storage !== undefined)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        if (field === null)
            throw new globalThis.Error("The parameter 'field' cannot be null.");
        else if (field !== undefined)
            url_ += "field=" + encodeURIComponent("" + field) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeQueryEcho(_response);
        });
    }

    protected processGetTimeQueryEcho(response: Response): Promise<TimeQueryEcho> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeQueryEcho;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeQueryEcho>(null as any);
    }

    /**
     * Time query debugging and pattern inspection with prefix
    Shows how the time patterns are expanded and what MongoDB query would be generated
     * @param prefix Time prefix pattern
     * @param storage (optional) Storage type (entries, treatments, devicestatus)
     * @param field (optional) Field name to match patterns against
     * @return Debug information about the generated patterns and query
     */
    getTimeQueryEchoWithPrefix(prefix: string, storage?: string | undefined, field?: string | undefined, signal?: AbortSignal): Promise<TimeQueryEcho> {
        let url_ = this.baseUrl + "/api/v1/times/echo/{prefix}?";
        if (prefix === undefined || prefix === null)
            throw new globalThis.Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (storage === null)
            throw new globalThis.Error("The parameter 'storage' cannot be null.");
        else if (storage !== undefined)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        if (field === null)
            throw new globalThis.Error("The parameter 'field' cannot be null.");
        else if (field !== undefined)
            url_ += "field=" + encodeURIComponent("" + field) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeQueryEchoWithPrefix(_response);
        });
    }

    protected processGetTimeQueryEchoWithPrefix(response: Response): Promise<TimeQueryEcho> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeQueryEcho;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeQueryEcho>(null as any);
    }

    /**
     * Time query debugging and pattern inspection with prefix and regex
    Shows how the time patterns are expanded and what MongoDB query would be generated
     * @param prefix Time prefix pattern
     * @param regex Time regex pattern
     * @param storage (optional) Storage type (entries, treatments, devicestatus)
     * @param field (optional) Field name to match patterns against
     * @return Debug information about the generated patterns and query
     */
    getTimeQueryEchoWithPrefixAndRegex(prefix: string, regex: string, storage?: string | undefined, field?: string | undefined, signal?: AbortSignal): Promise<TimeQueryEcho> {
        let url_ = this.baseUrl + "/api/v1/times/echo/{prefix}/{regex}?";
        if (prefix === undefined || prefix === null)
            throw new globalThis.Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (regex === undefined || regex === null)
            throw new globalThis.Error("The parameter 'regex' must be defined.");
        url_ = url_.replace("{regex}", encodeURIComponent("" + regex));
        if (storage === null)
            throw new globalThis.Error("The parameter 'storage' cannot be null.");
        else if (storage !== undefined)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        if (field === null)
            throw new globalThis.Error("The parameter 'field' cannot be null.");
        else if (field !== undefined)
            url_ += "field=" + encodeURIComponent("" + field) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeQueryEchoWithPrefixAndRegex(_response);
        });
    }

    protected processGetTimeQueryEchoWithPrefixAndRegex(response: Response): Promise<TimeQueryEcho> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeQueryEcho;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeQueryEcho>(null as any);
    }

    /**
     * Advanced data slicing with regex patterns and field filtering
    Allows specifying storage layer, field to match, entry type, and pattern matching
    - /api/v1/slice/entries/dateString - All entries matching dateString field
    - /api/v1/slice/entries/dateString/mbg/2015 - All MBG entries from 2015
    - /api/v1/slice/treatments/created_at/bolus/2015-04 - All bolus treatments from April 2015
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedData(storage: string, field: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}?";
        if (storage === undefined || storage === null)
            throw new globalThis.Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new globalThis.Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedData(_response);
        });
    }

    protected processGetSlicedData(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Advanced data slicing with type filter
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param type Entry/record type filter
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedDataWithType(storage: string, field: string, type: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}/{type}?";
        if (storage === undefined || storage === null)
            throw new globalThis.Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new globalThis.Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (type === undefined || type === null)
            throw new globalThis.Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedDataWithType(_response);
        });
    }

    protected processGetSlicedDataWithType(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Advanced data slicing with type and prefix filter
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param type Entry/record type filter
     * @param prefix Pattern prefix
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedDataWithTypeAndPrefix(storage: string, field: string, type: string, prefix: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}/{type}/{prefix}?";
        if (storage === undefined || storage === null)
            throw new globalThis.Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new globalThis.Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (type === undefined || type === null)
            throw new globalThis.Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (prefix === undefined || prefix === null)
            throw new globalThis.Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedDataWithTypeAndPrefix(_response);
        });
    }

    protected processGetSlicedDataWithTypeAndPrefix(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }

    /**
     * Advanced data slicing with all parameters
     * @param storage Storage type (entries, treatments, devicestatus)
     * @param field Field to perform pattern matching on
     * @param type Entry/record type filter
     * @param prefix Pattern prefix
     * @param regex Pattern regex
     * @param count (optional) Maximum number of entries to return (default: 10)
     * @param format (optional) Output format (json, csv, tsv, txt)
     * @return Entries matching the slice criteria
     */
    getSlicedDataWithAll(storage: string, field: string, type: string, prefix: string, regex: string, count?: number | undefined, format?: string | null | undefined, signal?: AbortSignal): Promise<Entry[]> {
        let url_ = this.baseUrl + "/api/v1/slice/{storage}/{field}/{type}/{prefix}/{regex}?";
        if (storage === undefined || storage === null)
            throw new globalThis.Error("The parameter 'storage' must be defined.");
        url_ = url_.replace("{storage}", encodeURIComponent("" + storage));
        if (field === undefined || field === null)
            throw new globalThis.Error("The parameter 'field' must be defined.");
        url_ = url_.replace("{field}", encodeURIComponent("" + field));
        if (type === undefined || type === null)
            throw new globalThis.Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (prefix === undefined || prefix === null)
            throw new globalThis.Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        if (regex === undefined || regex === null)
            throw new globalThis.Error("The parameter 'regex' must be defined.");
        url_ = url_.replace("{regex}", encodeURIComponent("" + regex));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (format !== undefined && format !== null)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSlicedDataWithAll(_response);
        });
    }

    protected processGetSlicedDataWithAll(response: Response): Promise<Entry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Entry[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry[]>(null as any);
    }
}

export class ConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Gets the configuration for a specific connector.
    Returns runtime configuration only (secrets are not included).
     * @param connectorName The connector name (e.g., "Dexcom", "Glooko")
     * @return Configuration response or 404 if not found
     */
    getConfiguration(connectorName: string, signal?: AbortSignal): Promise<ConnectorConfigurationResponse> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: Response): Promise<ConnectorConfigurationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorConfigurationResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorConfigurationResponse>(null as any);
    }

    /**
     * Saves or updates runtime configuration for a connector.
    Only properties marked with [RuntimeConfigurable] are accepted.
    Validates the configuration against the connector's schema before saving.
     * @param connectorName The connector name
     * @param configuration Configuration values as JSON
     * @return The saved configuration
     */
    saveConfiguration(connectorName: string, configuration: JsonDocument, signal?: AbortSignal): Promise<ConnectorConfigurationResponse> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configuration);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveConfiguration(_response);
        });
    }

    protected processSaveConfiguration(response: Response): Promise<ConnectorConfigurationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorConfigurationResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorConfigurationResponse>(null as any);
    }

    /**
     * Deletes all configuration and secrets for a connector.
     * @param connectorName The connector name
     */
    deleteConfiguration(connectorName: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteConfiguration(_response);
        });
    }

    protected processDeleteConfiguration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets the JSON Schema for a connector's configuration.
    Schema is generated from the connector's configuration class attributes.
    This endpoint is public since schema is just metadata, not sensitive data.
     * @param connectorName The connector name
     * @return JSON Schema document
     */
    getSchema(connectorName: string, signal?: AbortSignal): Promise<JsonDocument> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}/schema";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSchema(_response);
        });
    }

    protected processGetSchema(response: Response): Promise<JsonDocument> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as JsonDocument;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JsonDocument>(null as any);
    }

    /**
     * Gets the effective configuration from a running connector.
    This returns the actual runtime values including those resolved from environment variables.
    This endpoint is public since it only exposes non-secret configuration values.
     * @param connectorName The connector name
     * @return Dictionary of property names to effective values
     */
    getEffectiveConfiguration(connectorName: string, signal?: AbortSignal): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}/effective";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEffectiveConfiguration(_response);
        });
    }

    protected processGetEffectiveConfiguration(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: any; };
            return result200;
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }

    /**
     * Saves encrypted secrets for a connector.
    Secrets are encrypted using AES-256-GCM before storage.
     * @param connectorName The connector name
     * @param secrets Dictionary of secret property names to plaintext values
     */
    saveSecrets(connectorName: string, secrets: { [key: string]: string; }, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}/secrets";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(secrets);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveSecrets(_response);
        });
    }

    protected processSaveSecrets(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets status information for all registered connectors.
     * @return List of connector status information
     */
    getAllConnectorStatus(signal?: AbortSignal): Promise<ConnectorStatusInfo[]> {
        let url_ = this.baseUrl + "/internal/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllConnectorStatus(_response);
        });
    }

    protected processGetAllConnectorStatus(response: Response): Promise<ConnectorStatusInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConnectorStatusInfo[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectorStatusInfo[]>(null as any);
    }

    /**
     * Enables or disables a connector.
     * @param connectorName The connector name
     * @param request Request containing the active state
     */
    setActive(connectorName: string, request: SetActiveRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/internal/config/{connectorName}/active";
        if (connectorName === undefined || connectorName === null)
            throw new globalThis.Error("The parameter 'connectorName' must be defined.");
        url_ = url_.replace("{connectorName}", encodeURIComponent("" + connectorName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetActive(_response);
        });
    }

    protected processSetActive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface PerformanceMetrics {
    averageResponseTime?: number;
    totalRequests?: number;
    errorCount?: number;
    memoryUsageMB?: number;
    uptimeHours?: number;
    topEndpoints?: { [key: string]: number; };
}

export interface UsageStatistics {
    uniqueSessions?: number;
    popularFeatures?: { [key: string]: number; };
    averageSessionDuration?: number;
    deviceTypes?: { [key: string]: number; };
}

export interface AnalyticsBatch {
    installationId?: string;
    events?: AnalyticsEvent[];
    systemInfo?: SystemInfo | undefined;
    batchTimestamp?: number;
    schemaVersion?: string;
}

export interface AnalyticsEvent {
    sessionId?: string;
    eventType?: string;
    category?: string;
    action?: string;
    label?: string;
    value?: number | undefined;
    timestamp?: number;
    metadata?: { [key: string]: any; };
}

export interface SystemInfo {
    platform?: string;
    runtimeVersion?: string;
    nocturneVersion?: string;
    deploymentType?: string;
    demoModeEnabled?: boolean;
    enabledConnectors?: string[];
    enabledFeatures?: string[];
    databaseType?: string;
    cacheEnabled?: boolean;
}

export interface AnalyticsCollectionConfig {
    collectApiUsage?: boolean;
    collectUiUsage?: boolean;
    collectPerformanceMetrics?: boolean;
    collectHealthMetrics?: boolean;
    collectFeatureUsage?: boolean;
    excludedEndpoints?: string[];
    maxLocalEvents?: number;
}

/** Response for the /api/v1/verifyauth endpoint */
export interface VerifyAuthResponse {
    /** Authentication message - can be either a string or an object */
    message?: any;
}

export interface AuthorizationResponse {
    token?: string;
    exp?: number;
    sub?: string;
    iat?: number;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface PermissionsResponse {
    permissions?: Permission[];
}

export interface Permission {
    name?: string;
    count?: number;
    firstSeen?: Date;
    lastSeen?: Date;
}

export interface PermissionTrieResponse {
    root?: PermissionTrieNode;
    count?: number;
}

export interface PermissionTrieNode {
    name?: string;
    isLeaf?: boolean;
    children?: { [key: string]: PermissionTrieNode; };
}

export interface Subject {
    id?: string | undefined;
    _id?: string | undefined;
    name: string;
    roles?: string[];
    accessToken?: string;
    notes?: string | undefined;
    created?: Date;
    modified?: Date;
}

export interface Role {
    id?: string | undefined;
    _id?: string | undefined;
    name: string;
    permissions?: string[];
    notes?: string | undefined;
    autoGenerated?: boolean;
    created?: Date;
    modified?: Date;
}

export interface ConnectorStatusDto {
    id?: string;
    name?: string;
    status?: string;
    totalEntries?: number;
    lastEntryTime?: Date | undefined;
    entriesLast24Hours?: number;
    state?: string;
    stateMessage?: string | undefined;
    isHealthy?: boolean;
    /** Breakdown of total items processed by data type
Keys are data type names (e.g., "Glucose", "Treatments", "Food") */
    totalItemsBreakdown?: { [key: string]: number; } | undefined;
    /** Breakdown of items processed in the last 24 hours by data type
Keys are data type names (e.g., "Glucose", "Treatments", "Food") */
    itemsLast24HoursBreakdown?: { [key: string]: number; } | undefined;
}

/** Local auth configuration response */
export interface LocalAuthConfigResponse {
    enabled?: boolean;
    displayName?: string;
    allowRegistration?: boolean;
    requireEmailVerification?: boolean;
    passwordRequirements?: PasswordRequirementsDto;
}

/** Password requirements */
export interface PasswordRequirementsDto {
    minLength?: number;
    requireUppercase?: boolean;
    requireLowercase?: boolean;
    requireDigit?: boolean;
    requireSpecialCharacter?: boolean;
}

/** Registration response */
export interface RegisterResponse {
    success?: boolean;
    userId?: string;
    requiresEmailVerification?: boolean;
    requiresAdminApproval?: boolean;
    message?: string;
}

/** Error response */
export interface ErrorResponse {
    error?: string;
    message?: string;
    details?: any | undefined;
}

/** Registration request */
export interface RegisterRequest {
    email?: string;
    password?: string;
    displayName?: string | undefined;
}

/** Login response */
export interface LoginResponse {
    success?: boolean;
    accessToken?: string;
    refreshToken?: string;
    expiresIn?: number;
    user?: UserInfoDto;
    requirePasswordChange?: boolean;
}

/** User info */
export interface UserInfoDto {
    id?: string;
    email?: string;
    displayName?: string | undefined;
    roles?: string[];
}

/** Login request */
export interface LoginRequest {
    email?: string;
    password?: string;
}

/** Forgot password response */
export interface ForgotPasswordResponse {
    success?: boolean;
    message?: string;
    adminNotificationRequired?: boolean;
}

/** Forgot password request */
export interface ForgotPasswordRequest {
    email?: string;
}

/** Reset password response */
export interface ResetPasswordResponse {
    success?: boolean;
    message?: string;
}

/** Reset password request */
export interface ResetPasswordRequest {
    token?: string;
    newPassword?: string;
}

/** Change password response */
export interface ChangePasswordResponse {
    success?: boolean;
    message?: string;
}

/** Change password request */
export interface ChangePasswordRequest {
    currentPassword?: string;
    newPassword?: string;
}

/** Check email response */
export interface CheckEmailResponse {
    isValid?: boolean;
    error?: string | undefined;
    requiresApproval?: boolean;
}

/** Resend verification response */
export interface ResendVerificationResponse {
    success?: boolean;
    message?: string;
}

/** Resend verification request */
export interface ResendVerificationRequest {
    email?: string;
}

/** Response for pending password reset requests */
export interface PasswordResetRequestListResponse {
    requests?: PasswordResetRequestDto[];
    totalCount?: number;
}

/** Password reset request info for admin view */
export interface PasswordResetRequestDto {
    id?: string;
    email?: string;
    displayName?: string | undefined;
    requestedFromIp?: string | undefined;
    userAgent?: string | undefined;
    createdAt?: Date;
}

/** Response for setting a temporary password */
export interface SetTemporaryPasswordResponse {
    success?: boolean;
}

/** Request to set a temporary password */
export interface SetTemporaryPasswordRequest {
    email?: string;
    temporaryPassword?: string;
}

/** Response for handling password reset */
export interface HandlePasswordResetResponse {
    success?: boolean;
    resetUrl?: string;
}

/** Metadata about available WebSocket events */
export interface WebSocketEventsMetadata {
    /** Array of all available WebSocket event types */
    availableEvents?: WebSocketEvents[];
    /** Description of the WebSocket events */
    description?: string;
}

export enum WebSocketEvents {
    Connect = "connect",
    Disconnect = "disconnect",
    ConnectError = "connect_error",
    Reconnect = "reconnect",
    ReconnectFailed = "reconnect_failed",
    ConnectAck = "connect_ack",
    DataUpdate = "dataUpdate",
    TreatmentUpdate = "treatmentUpdate",
    Create = "create",
    Update = "update",
    Delete = "delete",
    Announcement = "announcement",
    Alarm = "alarm",
    UrgentAlarm = "urgent_alarm",
    ClearAlarm = "clear_alarm",
    Notification = "notification",
    StatusUpdate = "statusUpdate",
    Status = "status",
    Authenticate = "authenticate",
    Authenticated = "authenticated",
    Join = "join",
    Leave = "leave",
}

export interface ExternalUrls {
    website?: string;
    docsBase?: string;
    connectorDocs?: ConnectorDocsUrls;
}

export interface ConnectorDocsUrls {
    dexcom?: string;
    libre?: string;
    careLink?: string;
    nightscout?: string;
    glooko?: string;
}

/** Metadata about available treatment event types */
export interface TreatmentEventTypesMetadata {
    /** Array of all available treatment event types */
    availableTypes?: TreatmentEventType[];
    /** Full configurations for each event type including field applicability */
    configurations?: EventTypeConfiguration[];
    /** Description of the treatment event types */
    description?: string;
}

export enum TreatmentEventType {
    None = "<none>",
    BgCheck = "BG Check",
    SnackBolus = "Snack Bolus",
    MealBolus = "Meal Bolus",
    CorrectionBolus = "Correction Bolus",
    CarbCorrection = "Carb Correction",
    ComboBolus = "Combo Bolus",
    Announcement = "Announcement",
    Note = "Note",
    Question = "Question",
    SiteChange = "Site Change",
    SensorStart = "Sensor Start",
    SensorChange = "Sensor Change",
    SensorStop = "Sensor Stop",
    PumpBatteryChange = "Pump Battery Change",
    InsulinChange = "Insulin Change",
    TempBasalStart = "Temp Basal Start",
    TempBasalEnd = "Temp Basal End",
    ProfileSwitch = "Profile Switch",
    DadAlert = "D.A.D. Alert",
    TempBasal = "Temp Basal",
    Exercise = "Exercise",
    OpenApsOffline = "OpenAPS Offline",
    SuspendPump = "Suspend Pump",
    ResumePump = "Resume Pump",
    BolusWizard = "Bolus Wizard",
    Calibration = "Calibration",
    TransmitterSensorInsert = "Transmitter Sensor Insert",
    PodChange = "Pod Change",
}

export interface EventTypeConfiguration {
    eventType?: TreatmentEventType;
    name?: string;
    bg?: boolean;
    insulin?: boolean;
    carbs?: boolean;
    protein?: boolean;
    fat?: boolean;
    prebolus?: boolean;
    duration?: boolean;
    percent?: boolean;
    absolute?: boolean;
    profile?: boolean;
    split?: boolean;
    sensor?: boolean;
}

/** Metadata about state span types for NSwag generation */
export interface StateSpanTypesMetadata {
    /** Array of all available state span categories */
    availableCategories?: StateSpanCategory[];
    /** Array of all basal delivery states */
    basalDeliveryStates?: BasalDeliveryState[];
    /** Array of all basal delivery origin values */
    basalDeliveryOrigins?: BasalDeliveryOrigin[];
    /** Array of all pump mode states */
    pumpModeStates?: PumpModeState[];
    /** Array of all pump connectivity states */
    pumpConnectivityStates?: PumpConnectivityState[];
    /** Description of the state span types */
    description?: string;
}

export enum StateSpanCategory {
    PumpMode = "PumpMode",
    PumpConnectivity = "PumpConnectivity",
    Override = "Override",
    Profile = "Profile",
    BasalDelivery = "BasalDelivery",
    Sleep = "Sleep",
    Exercise = "Exercise",
    Illness = "Illness",
    Travel = "Travel",
}

export enum BasalDeliveryState {
    Active = "Active",
}

export enum BasalDeliveryOrigin {
    Algorithm = "Algorithm",
    Scheduled = "Scheduled",
    Manual = "Manual",
    Suspended = "Suspended",
    Inferred = "Inferred",
}

export enum PumpModeState {
    Automatic = "Automatic",
    Limited = "Limited",
    Manual = "Manual",
    Boost = "Boost",
    EaseOff = "EaseOff",
    Sleep = "Sleep",
    Exercise = "Exercise",
    Suspended = "Suspended",
    Off = "Off",
}

export enum PumpConnectivityState {
    Connected = "Connected",
    Disconnected = "Disconnected",
    Removed = "Removed",
    BluetoothOff = "BluetoothOff",
}

/** Metadata about statistics types for NSwag generation */
export interface StatisticsTypesMetadata {
    /** Description of the statistics types */
    description?: string;
    /** Sample basal analysis response (for type generation) */
    sampleBasalAnalysis?: BasalAnalysisResponse | undefined;
    /** Sample daily basal/bolus ratio response (for type generation) */
    sampleDailyBasalBolusRatio?: DailyBasalBolusRatioResponse | undefined;
    /** Sample hourly basal percentile data (for type generation) */
    sampleHourlyPercentile?: HourlyBasalPercentileData | undefined;
    /** Sample daily basal/bolus ratio data (for type generation) */
    sampleDailyData?: DailyBasalBolusRatioData | undefined;
    /** Sample insulin delivery statistics (for type generation) */
    sampleInsulinDelivery?: InsulinDeliveryStatistics | undefined;
}

export interface BasalAnalysisResponse {
    stats?: BasalStats;
    tempBasalInfo?: TempBasalInfo;
    hourlyPercentiles?: HourlyBasalPercentileData[];
    dayCount?: number;
    startDate?: string;
    endDate?: string;
}

export interface BasalStats {
    count?: number;
    avgRate?: number;
    minRate?: number;
    maxRate?: number;
    totalDelivered?: number;
}

export interface TempBasalInfo {
    total?: number;
    perDay?: number;
    highTemps?: number;
    lowTemps?: number;
    zeroTemps?: number;
}

export interface HourlyBasalPercentileData {
    hour?: number;
    p10?: number;
    p25?: number;
    median?: number;
    p75?: number;
    p90?: number;
    count?: number;
}

export interface DailyBasalBolusRatioResponse {
    dailyData?: DailyBasalBolusRatioData[];
    averageBasalPercent?: number;
    averageBolusPercent?: number;
    averageTdd?: number;
    dayCount?: number;
}

export interface DailyBasalBolusRatioData {
    date?: string;
    displayDate?: string;
    basal?: number;
    bolus?: number;
    total?: number;
    basalPercent?: number;
    bolusPercent?: number;
}

export interface InsulinDeliveryStatistics {
    totalBolus?: number;
    totalBasal?: number;
    totalInsulin?: number;
    totalCarbs?: number;
    bolusCount?: number;
    basalCount?: number;
    basalPercent?: number;
    bolusPercent?: number;
    tdd?: number;
    avgBolus?: number;
    mealBoluses?: number;
    correctionBoluses?: number;
    icRatio?: number;
    bolusesPerDay?: number;
    dayCount?: number;
    startDate?: string;
    endDate?: string;
    carbCount?: number;
    carbBolusCount?: number;
}

/** Metadata about available widget definitions */
export interface WidgetDefinitionsMetadata {
    /** Array of all widget definitions with full metadata */
    definitions?: WidgetDefinition[];
    /** All available placement options */
    availablePlacements?: WidgetPlacement[];
    /** All available size options */
    availableSizes?: WidgetSize[];
    /** All available UI category options */
    availableUICategories?: WidgetUICategory[];
    /** Description of the widget definitions */
    description?: string;
}

export interface WidgetDefinition {
    id?: WidgetId;
    name?: string;
    description?: string;
    defaultEnabled?: boolean;
    icon?: string;
    uiCategory?: WidgetUICategory;
    placement?: WidgetPlacement;
}

export enum WidgetId {
    BgDelta = "BgDelta",
    LastUpdated = "LastUpdated",
    ConnectionStatus = "ConnectionStatus",
    Meals = "Meals",
    Trackers = "Trackers",
    TirChart = "TirChart",
    DailySummary = "DailySummary",
    Clock = "Clock",
    Tdd = "Tdd",
    GlucoseChart = "GlucoseChart",
    Statistics = "Statistics",
    Treatments = "Treatments",
    Predictions = "Predictions",
    DailyStats = "DailyStats",
    Agp = "Agp",
    BatteryStatus = "BatteryStatus",
}

export enum WidgetUICategory {
    Glucose = "Glucose",
    Meals = "Meals",
    Device = "Device",
    Status = "Status",
}

export enum WidgetPlacement {
    Top = "Top",
    Main = "Main",
}

export enum WidgetSize {
    Small = "Small",
    Medium = "Medium",
    Large = "Large",
}

/** OIDC provider info for login page */
export interface OidcProviderInfo {
    /** Provider ID */
    id?: string;
    /** Display name */
    name?: string;
    /** Icon URL or CSS class */
    icon?: string | undefined;
    /** Button color for UI */
    buttonColor?: string | undefined;
}

export interface OidcTokenResponse {
    accessToken?: string;
    refreshToken?: string;
    tokenType?: string;
    expiresIn?: number;
    expiresAt?: Date;
    subjectId?: string;
}

/** Logout response */
export interface LogoutResponse {
    /** Whether logout was successful */
    success?: boolean;
    /** URL for provider logout (if RP-initiated logout is supported) */
    providerLogoutUrl?: string | undefined;
    /** Message */
    message?: string | undefined;
}

export interface OidcUserInfo {
    subjectId?: string;
    name?: string;
    email?: string | undefined;
    emailVerified?: boolean | undefined;
    picture?: string | undefined;
    roles?: string[];
    permissions?: string[];
    providerName?: string | undefined;
    lastLoginAt?: Date | undefined;
    preferredLanguage?: string | undefined;
}

/** Current session information */
export interface SessionInfo {
    /** Whether the user is authenticated */
    isAuthenticated?: boolean;
    /** Subject ID */
    subjectId?: string | undefined;
    /** User name */
    name?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Assigned roles */
    roles?: string[] | undefined;
    /** Resolved permissions */
    permissions?: string[] | undefined;
    /** Session expiration time */
    expiresAt?: Date | undefined;
    /** User's preferred language code (e.g., "en", "fr", "de") */
    preferredLanguage?: string | undefined;
}

/** Pebble response model for 1:1 Nightscout compatibility */
export interface PebbleResponse {
    /** Status array containing current timestamp */
    status?: PebbleStatus[];
    /** Blood glucose readings array */
    bgs?: PebbleBg[];
    /** Calibration readings array */
    cals?: PebbleCal[];
}

/** Pebble status entry */
export interface PebbleStatus {
    /** Current timestamp in milliseconds since epoch */
    now?: number;
}

/** Pebble blood glucose entry */
export interface PebbleBg {
    /** Sensor glucose value (formatted as string for legacy compatibility) */
    sgv?: string;
    /** Numeric trend indicator (1-9) */
    trend?: number;
    /** Direction string (Flat, SingleUp, etc.) */
    direction?: string;
    /** Timestamp in milliseconds since epoch */
    datetime?: number;
    /** Delta from previous reading (formatted string) */
    bgdelta?: string | undefined;
    /** Battery percentage (formatted string) */
    battery?: string | undefined;
    /** Insulin on board (formatted string) */
    iob?: string | undefined;
    /** Bolus wizard preview (formatted string) */
    bwp?: string | undefined;
    /** Bolus wizard preview outcome */
    bwpo?: number | undefined;
    /** Carbs on board */
    cob?: number | undefined;
}

/** Pebble calibration entry */
export interface PebbleCal {
    /** Calibration slope */
    slope?: number | undefined;
    /** Calibration intercept */
    intercept?: number | undefined;
    /** Calibration scale */
    scale?: number | undefined;
}

export interface BasicGlucoseStats {
    count?: number;
    mean?: number;
    median?: number;
    min?: number;
    max?: number;
    standardDeviation?: number;
    percentiles?: GlucosePercentiles;
}

export interface GlucosePercentiles {
    p5?: number;
    p10?: number;
    p25?: number;
    p50?: number;
    p75?: number;
    p90?: number;
    p95?: number;
}

export interface GlycemicVariability {
    coefficientOfVariation?: number;
    standardDeviation?: number;
    meanAmplitudeGlycemicExcursions?: number;
    continuousOverlappingNetGlycemicAction?: number;
    averageDailyRiskRange?: number;
    labilityIndex?: number;
    jIndex?: number;
    highBloodGlucoseIndex?: number;
    lowBloodGlucoseIndex?: number;
    glycemicVariabilityIndex?: number;
    patientGlycemicStatus?: number;
    estimatedA1c?: number;
    meanTotalDailyChange?: number;
    timeInFluctuation?: number;
}

/** Request model for glycemic variability calculation */
export interface GlycemicVariabilityRequest {
    /** Collection of glucose values in mg/dL */
    values?: number[];
    /** Collection of glucose entries with timestamps */
    entries?: Entry[];
}

export interface ProcessableDocumentBase {
    id?: string | undefined;
    createdAt?: string | undefined;
    mills?: number;
    utcOffset?: number | undefined;
}

export interface Entry extends ProcessableDocumentBase {
    _id?: string | undefined;
    mills?: number;
    dateString?: string | undefined;
    mgdl?: number;
    mbg?: number | undefined;
    mmol?: number | undefined;
    sgv?: number | undefined;
    direction?: string | undefined;
    trend?: number | undefined;
    trendRate?: number | undefined;
    isCalibration?: boolean;
    type?: string;
    device?: string | undefined;
    notes?: string | undefined;
    delta?: number | undefined;
    scaled?: any | undefined;
    sysTime?: string | undefined;
    utcOffset?: number | undefined;
    noise?: number | undefined;
    filtered?: number | undefined;
    unfiltered?: number | undefined;
    rssi?: number | undefined;
    slope?: number | undefined;
    intercept?: number | undefined;
    scale?: number | undefined;
    created_at?: string | undefined;
    modified_at?: Date | undefined;
    data_source?: string | undefined;
    meta?: { [key: string]: any; } | undefined;
    canonicalId?: string | undefined;
    sources?: string[] | undefined;
}

export function isEntry(object: any): object is Entry {
    return object && object[''] === 'Entry';
}

export interface TimeInRangeMetrics {
    percentages?: TimeInRangePercentages;
    durations?: TimeInRangeDurations;
    episodes?: TimeInRangeEpisodes;
    rangeStats?: TimeInRangeDetailedStats;
}

export interface TimeInRangePercentages {
    severeLow?: number;
    low?: number;
    target?: number;
    tightTarget?: number;
    high?: number;
    severeHigh?: number;
}

export interface TimeInRangeDurations {
    severeLow?: number;
    low?: number;
    target?: number;
    tightTarget?: number;
    high?: number;
    severeHigh?: number;
}

export interface TimeInRangeEpisodes {
    severeLow?: number;
    low?: number;
    high?: number;
    severeHigh?: number;
}

export interface TimeInRangeDetailedStats {
    low?: PeriodMetrics;
    target?: PeriodMetrics;
    high?: PeriodMetrics;
}

export interface PeriodMetrics {
    periodName?: string;
    startHour?: number;
    endHour?: number;
    readingCount?: number;
    mean?: number;
    median?: number;
    standardDeviation?: number;
    coefficientOfVariation?: number;
    timeInRange?: number;
    timeBelowRange?: number;
    timeVeryLow?: number;
    timeAboveRange?: number;
    timeVeryHigh?: number;
    hypoglycemiaEvents?: number;
    hyperglycemiaEvents?: number;
    min?: number;
    max?: number;
}

/** Request model for time in range calculation */
export interface TimeInRangeRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional glycemic thresholds */
    thresholds?: GlycemicThresholds | undefined;
}

export interface GlycemicThresholds {
    severeLow?: number;
    low?: number;
    targetBottom?: number;
    targetTop?: number;
    tightTargetBottom?: number;
    tightTargetTop?: number;
    high?: number;
    severeHigh?: number;
}

export interface DistributionDataPoint {
    range?: string;
    count?: number;
    percent?: number;
}

/** Request model for glucose distribution calculation */
export interface GlucoseDistributionRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional distribution bins */
    bins?: DistributionBin[] | undefined;
}

export interface DistributionBin {
    range?: string;
    min?: number;
    max?: number;
}

export interface AveragedStats extends BasicGlucoseStats {
    hour?: number;
    timeInRange?: ExtendedTimeInRangePercentages;
}

export function isAveragedStats(object: any): object is AveragedStats {
    return object && object[''] === 'AveragedStats';
}

export interface ExtendedTimeInRangePercentages {
    veryLow?: number;
    low?: number;
    normal?: number;
    aboveTarget?: number;
    high?: number;
    veryHigh?: number;
    severeHigh?: number;
}

export interface TreatmentSummary {
    totals?: TreatmentTotals;
    treatmentCount?: number;
    carbToInsulinRatio?: number;
}

export interface TreatmentTotals {
    food?: FoodTotals;
    insulin?: InsulinTotals;
}

export interface FoodTotals {
    carbs?: number;
    protein?: number;
    fat?: number;
}

export interface InsulinTotals {
    bolus?: number;
    basal?: number;
}

export interface Treatment extends ProcessableDocumentBase {
    _id?: string | undefined;
    identifier?: string | undefined;
    srvModified?: number | undefined;
    srvCreated?: number | undefined;
    eventType?: string | undefined;
    reason?: string | undefined;
    glucose?: number | undefined;
    glucoseType?: string | undefined;
    carbs?: number | undefined;
    insulin?: number | undefined;
    protein?: number | undefined;
    fat?: number | undefined;
    foodType?: string | undefined;
    units?: string | undefined;
    mills?: number;
    created_at?: string | undefined;
    duration?: number | undefined;
    percent?: number | undefined;
    absolute?: number | undefined;
    notes?: string | undefined;
    enteredBy?: string | undefined;
    targetTop?: number | undefined;
    targetBottom?: number | undefined;
    profile?: string | undefined;
    split?: string | undefined;
    date?: number | undefined;
    carbTime?: number | undefined;
    boluscalc?: { [key: string]: any; } | undefined;
    utcOffset?: number | undefined;
    timestamp?: string | undefined;
    cuttedby?: string | undefined;
    cutting?: string | undefined;
    eventTime?: string | undefined;
    preBolus?: number | undefined;
    rate?: number | undefined;
    mgdl?: number | undefined;
    mmol?: number | undefined;
    endmills?: number | undefined;
    durationType?: string | undefined;
    isAnnouncement?: boolean | undefined;
    profileJson?: string | undefined;
    endprofile?: string | undefined;
    insulinNeedsScaleFactor?: number | undefined;
    absorptionTime?: number | undefined;
    enteredinsulin?: number | undefined;
    splitNow?: number | undefined;
    splitExt?: number | undefined;
    status?: string | undefined;
    relative?: number | undefined;
    CR?: number | undefined;
    NSCLIENT_ID?: string | undefined;
    first?: boolean | undefined;
    end?: boolean | undefined;
    CircadianPercentageProfile?: boolean | undefined;
    percentage?: number | undefined;
    timeshift?: number | undefined;
    transmitterId?: string | undefined;
    remoteCarbs?: number | undefined;
    remoteAbsorption?: number | undefined;
    remoteBolus?: number | undefined;
    reasonDisplay?: string | undefined;
    otp?: string | undefined;
    syncIdentifier?: string | undefined;
    insulinType?: string | undefined;
    automatic?: boolean | undefined;
    temp?: string | undefined;
    amount?: number | undefined;
    programmed?: number | undefined;
    unabsorbed?: number | undefined;
    type?: string | undefined;
    bolusType?: string | undefined;
    data_source?: string | undefined;
    insulinRecommendationForCarbs?: number | undefined;
    insulinRecommendationForCorrection?: number | undefined;
    insulinProgrammed?: number | undefined;
    insulinDelivered?: number | undefined;
    insulinOnBoard?: number | undefined;
    bloodGlucoseInput?: number | undefined;
    bloodGlucoseInputSource?: string | undefined;
    calculationType?: CalculationType | undefined;
    additional_properties?: { [key: string]: any; } | undefined;
    canonicalId?: string | undefined;
    dbId?: string | undefined;
    sources?: string[] | undefined;
}

export function isTreatment(object: any): object is Treatment {
    return object && object[''] === 'Treatment';
}

export enum CalculationType {
    Suggested = "Suggested",
    Manual = "Manual",
    Automatic = "Automatic",
}

export interface OverallAverages {
    avgTotalDaily?: number;
    avgBolus?: number;
    avgBasal?: number;
    bolusPercentage?: number;
    basalPercentage?: number;
    avgCarbs?: number;
    avgProtein?: number;
    avgFat?: number;
    avgTimeInRange?: number;
    avgTightTimeInRange?: number;
}

export interface DayData {
    date?: string;
    treatments?: Treatment[];
    treatmentSummary?: TreatmentSummary;
    timeInRanges?: TimeInRangeMetrics;
}

export interface GlucoseAnalytics {
    basicStats?: BasicGlucoseStats;
    timeInRange?: TimeInRangeMetrics;
    glycemicVariability?: GlycemicVariability;
    dataQuality?: DataQuality;
    time?: AnalysisTime;
}

export interface DataQuality {
    totalReadings?: number;
    missingReadings?: number;
    dataCompleteness?: number;
    cgmActivePercent?: number;
    gapAnalysis?: GapAnalysis;
    noiseLevel?: number;
    calibrationEvents?: number;
    sensorWarmups?: number;
}

export interface GapAnalysis {
    gaps?: DataGap[];
    longestGap?: number;
    averageGap?: number;
}

export interface DataGap {
    start?: number;
    end?: number;
    duration?: number;
}

export interface AnalysisTime {
    start?: number;
    end?: number;
    timeOfAnalysis?: number;
}

/** Request model for comprehensive glucose analytics */
export interface GlucoseAnalyticsRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional collection of treatments */
    treatments?: Treatment[] | undefined;
    /** Optional extended analysis configuration */
    config?: ExtendedAnalysisConfig | undefined;
}

export interface ExtendedAnalysisConfig {
    thresholds?: GlycemicThresholds;
    sensorType?: string;
    includeLoopingMetrics?: boolean;
    units?: string;
}

export interface ExtendedGlucoseAnalytics extends GlucoseAnalytics {
    gmi?: GlucoseManagementIndicator;
    gri?: GlycemicRiskIndex;
    timeOfDayPatterns?: TimeOfDayAnalysis;
    dayOfWeekPatterns?: DayOfWeekAnalysis;
    hypoglycemiaAnalysis?: HypoglycemiaAnalysis;
    hyperglycemiaAnalysis?: HyperglycemiaAnalysis;
    clinicalAssessment?: ClinicalTargetAssessment;
    dataSufficiency?: DataSufficiencyAssessment;
    treatmentSummary?: TreatmentSummary | undefined;
}

export function isExtendedGlucoseAnalytics(object: any): object is ExtendedGlucoseAnalytics {
    return object && object[''] === 'ExtendedGlucoseAnalytics';
}

export interface GlucoseManagementIndicator {
    value?: number;
    meanGlucose?: number;
    interpretation?: string;
}

export interface GlycemicRiskIndex {
    score?: number;
    hypoglycemiaComponent?: number;
    hyperglycemiaComponent?: number;
    zone?: GRIZone;
    interpretation?: string;
}

export enum GRIZone {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
    E = 4,
}

export interface TimeOfDayAnalysis {
    overnight?: PeriodMetrics;
    morning?: PeriodMetrics;
    afternoon?: PeriodMetrics;
    evening?: PeriodMetrics;
    dawnPhenomenonDetected?: boolean;
    dawnPhenomenonMagnitude?: number;
    highestVariabilityPeriod?: string;
    lowestTIRPeriod?: string;
    mostHypoglycemiaPeriod?: string;
}

export interface DayOfWeekAnalysis {
    dayMetrics?: { [key in keyof typeof DayOfWeek]?: DayMetrics; };
    weekdayAverage?: PeriodMetrics;
    weekendAverage?: PeriodMetrics;
    highestVariabilityDay?: DayOfWeek | undefined;
    lowestTIRDay?: DayOfWeek | undefined;
    weekdayWeekendDifference?: boolean;
    patternDescription?: string;
}

export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

export interface DayMetrics extends PeriodMetrics {
    dayOfWeek?: DayOfWeek;
}

export function isDayMetrics(object: any): object is DayMetrics {
    return object && object[''] === 'DayMetrics';
}

export interface HypoglycemiaAnalysis {
    totalEpisodes?: number;
    severeEpisodes?: number;
    episodesPerDay?: number;
    averageDurationMinutes?: number;
    averageNadir?: number;
    lowestGlucose?: number;
    averageRecoveryTimeMinutes?: number;
    hourlyDistribution?: { [key: string]: number; };
    dayOfWeekDistribution?: { [key in keyof typeof DayOfWeek]?: number; };
    peakHour?: number | undefined;
    peakDay?: DayOfWeek | undefined;
    hasRecurringPattern?: boolean;
    patternDescription?: string;
    episodes?: HypoglycemiaEpisode[];
    nocturnalEpisodes?: number;
    nocturnalPercentage?: number;
    riskAssessment?: string;
}

export interface HypoglycemiaEpisode {
    startTime?: number;
    endTime?: number;
    durationMinutes?: number;
    nadirValue?: number;
    nadirTime?: number;
    isSevere?: boolean;
    hourOfDay?: number;
    dayOfWeek?: DayOfWeek;
    recoveryTimeMinutes?: number;
    preEpisodeGlucose?: number | undefined;
}

export interface HyperglycemiaAnalysis {
    totalEpisodes?: number;
    severeEpisodes?: number;
    prolongedEpisodes?: number;
    episodesPerDay?: number;
    averageDurationMinutes?: number;
    averagePeak?: number;
    highestGlucose?: number;
    averageTimeToTargetMinutes?: number;
    hourlyDistribution?: { [key: string]: number; };
    dayOfWeekDistribution?: { [key in keyof typeof DayOfWeek]?: number; };
    peakHour?: number | undefined;
    peakDay?: DayOfWeek | undefined;
    hasPostMealPattern?: boolean;
    patternDescription?: string;
    episodes?: HyperglycemiaEpisode[];
    nocturnalEpisodes?: number;
    nocturnalPercentage?: number;
}

export interface HyperglycemiaEpisode {
    startTime?: number;
    endTime?: number;
    durationMinutes?: number;
    peakValue?: number;
    peakTime?: number;
    isSevere?: boolean;
    isProlonged?: boolean;
    hourOfDay?: number;
    dayOfWeek?: DayOfWeek;
    timeToTargetMinutes?: number;
    averageGlucose?: number;
}

export interface ClinicalTargetAssessment {
    population?: DiabetesPopulation;
    targets?: ClinicalTargets;
    tirAssessment?: TargetAssessment;
    tbrAssessment?: TargetAssessment;
    veryLowAssessment?: TargetAssessment;
    tarAssessment?: TargetAssessment;
    veryHighAssessment?: TargetAssessment;
    cvAssessment?: TargetAssessment;
    targetsMet?: number;
    totalTargets?: number;
    overallAssessment?: string;
    actionableInsights?: string[];
    priorityAreas?: string[];
    strengths?: string[];
}

export enum DiabetesPopulation {
    Type1Adult = 0,
    Type2Adult = 1,
    Type1Pediatric = 2,
    Elderly = 3,
    Pregnancy = 4,
    PregnancyType1 = 5,
}

export interface ClinicalTargets {
    targetTIR?: number;
    maxTBR?: number;
    maxTBRVeryLow?: number;
    maxTAR?: number;
    maxTARVeryHigh?: number;
    targetCV?: number;
    targetLow?: number;
    targetHigh?: number;
}

export interface TargetAssessment {
    metricName?: string;
    currentValue?: number;
    targetValue?: number;
    isMaximumTarget?: boolean;
    status?: TargetStatus;
    differenceFromTarget?: number;
    progressPercentage?: number;
}

export enum TargetStatus {
    Met = 0,
    Close = 1,
    NotMet = 2,
}

export interface DataSufficiencyAssessment {
    isSufficient?: boolean;
    totalDays?: number;
    daysWithData?: number;
    expectedReadings?: number;
    actualReadings?: number;
    completenessPercentage?: number;
    minimumRequiredCompleteness?: number;
    averageReadingsPerDay?: number;
    longestGapHours?: number;
    warningMessage?: string;
    recommendation?: string;
}

/** Request model for extended glucose analytics with GMI, GRI, and clinical assessment */
export interface ExtendedGlucoseAnalyticsRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Optional collection of treatments */
    treatments?: Treatment[] | undefined;
    /** Diabetes population type for clinical target assessment */
    population?: DiabetesPopulation;
    /** Optional extended analysis configuration */
    config?: ExtendedAnalysisConfig | undefined;
}

/** Request model for clinical assessment */
export interface ClinicalAssessmentRequest {
    /** Glucose analytics to assess */
    analytics?: GlucoseAnalytics;
    /** Diabetes population type for clinical target assessment */
    population?: DiabetesPopulation;
}

/** Request model for data sufficiency assessment */
export interface DataSufficiencyRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Number of days to assess (default: 14) */
    days?: number;
    /** Expected readings per day based on sensor type (default: 288 for 5-minute intervals) */
    expectedReadingsPerDay?: number;
}

export interface MultiPeriodStatistics {
    lastDay?: PeriodStatistics;
    last3Days?: PeriodStatistics;
    lastWeek?: PeriodStatistics;
    lastMonth?: PeriodStatistics;
    last90Days?: PeriodStatistics;
    lastUpdated?: Date;
}

export interface PeriodStatistics {
    periodDays?: number;
    startDate?: Date;
    endDate?: Date;
    analytics?: GlucoseAnalytics | undefined;
    treatmentSummary?: TreatmentSummary | undefined;
    insulinDelivery?: InsulinDeliveryStatistics | undefined;
    hasSufficientData?: boolean;
    entryCount?: number;
    treatmentCount?: number;
}

export interface SiteChangeImpactAnalysis {
    siteChangeCount?: number;
    dataPoints?: SiteChangeImpactDataPoint[];
    summary?: SiteChangeImpactSummary;
    hoursBeforeChange?: number;
    hoursAfterChange?: number;
    bucketSizeMinutes?: number;
    hasSufficientData?: boolean;
}

export interface SiteChangeImpactDataPoint {
    minutesFromChange?: number;
    averageGlucose?: number;
    medianGlucose?: number;
    stdDev?: number;
    count?: number;
    percentile10?: number;
    percentile25?: number;
    percentile75?: number;
    percentile90?: number;
}

export interface SiteChangeImpactSummary {
    avgGlucoseBeforeChange?: number;
    avgGlucoseAfterChange?: number;
    percentImprovement?: number;
    timeInRangeBeforeChange?: number;
    timeInRangeAfterChange?: number;
    cvBeforeChange?: number;
    cvAfterChange?: number;
}

/** Request model for site change impact analysis */
export interface SiteChangeImpactRequest {
    /** Collection of glucose entries */
    entries?: Entry[];
    /** Collection of treatments (must include site changes) */
    treatments?: Treatment[];
    /** Hours before site change to analyze (default: 12) */
    hoursBeforeChange?: number;
    /** Hours after site change to analyze (default: 24) */
    hoursAfterChange?: number;
    /** Time bucket size for averaging in minutes (default: 30) */
    bucketSizeMinutes?: number;
}

export interface VersionsResponse {
    versions?: string[];
}

/** OpenID Connect Discovery Document See: https://openid.net/specs/openid-connect-discovery-1_0.html */
export interface OpenIdConfiguration {
    issuer?: string;
    authorizationEndpoint?: string;
    tokenEndpoint?: string;
    userinfoEndpoint?: string | undefined;
    jwksUri?: string;
    registrationEndpoint?: string | undefined;
    endSessionEndpoint?: string | undefined;
    scopesSupported?: string[];
    responseTypesSupported?: string[];
    responseModesSupported?: string[];
    grantTypesSupported?: string[];
    subjectTypesSupported?: string[];
    idTokenSigningAlgValuesSupported?: string[];
    tokenEndpointAuthMethodsSupported?: string[];
    claimsSupported?: string[];
    codeChallengeMethodsSupported?: string[];
    serviceDocumentation?: string | undefined;
}

/** JSON Web Key Set */
export interface JsonWebKeySet {
    keys?: JsonWebKey[];
}

/** JSON Web Key */
export interface JsonWebKey {
    kty?: string;
    use?: string | undefined;
    alg?: string | undefined;
    kid?: string | undefined;
    n?: string | undefined;
    e?: string | undefined;
}

/** OAuth 2.0 Authorization Server Metadata See: https://datatracker.ietf.org/doc/html/rfc8414 */
export interface OAuthAuthorizationServerMetadata {
    issuer?: string;
    authorizationEndpoint?: string;
    tokenEndpoint?: string;
    revocationEndpoint?: string | undefined;
    introspectionEndpoint?: string | undefined;
    jwksUri?: string;
    responseTypesSupported?: string[];
    grantTypesSupported?: string[];
    tokenEndpointAuthMethodsSupported?: string[];
    scopesSupported?: string[];
    codeChallengeMethodsSupported?: string[];
    serviceDocumentation?: string | undefined;
}

export interface CurrentBatteryStatus {
    level?: number | undefined;
    display?: string;
    status?: string;
    min?: BatteryReading | undefined;
    devices?: { [key: string]: DeviceBatteryStatus; };
}

export interface BatteryReading {
    id?: string | undefined;
    device?: string;
    battery?: number | undefined;
    voltage?: number | undefined;
    isCharging?: boolean;
    temperature?: number | undefined;
    mills?: number;
    timestamp?: string | undefined;
    display?: string;
    level?: number;
    notification?: string | undefined;
}

export interface DeviceBatteryStatus {
    uri?: string;
    name?: string;
    statuses?: BatteryReading[];
    min?: BatteryReading | undefined;
}

export interface BatteryStatistics {
    device?: string;
    displayName?: string;
    periodStartMills?: number;
    periodEndMills?: number;
    readingCount?: number;
    currentLevel?: number | undefined;
    isCharging?: boolean;
    lastReadingMills?: number | undefined;
    averageLevel?: number | undefined;
    minLevel?: number | undefined;
    maxLevel?: number | undefined;
    chargeCycleCount?: number;
    averageChargeDurationMinutes?: number | undefined;
    averageDischargeDurationMinutes?: number | undefined;
    averageTimeBetweenChargesHours?: number | undefined;
    longestDischargeDurationMinutes?: number | undefined;
    shortestDischargeDurationMinutes?: number | undefined;
    timeAbove80Percent?: number;
    timeBetween30And80Percent?: number;
    timeBelow30Percent?: number;
    timeBelow20Percent?: number;
    warningEventCount?: number;
    urgentEventCount?: number;
    display?: string;
    level?: number;
    status?: string;
}

export interface ChargeCycle {
    id?: string | undefined;
    device?: string;
    chargeStartMills?: number | undefined;
    chargeStartLevel?: number | undefined;
    chargeEndMills?: number | undefined;
    chargeEndLevel?: number | undefined;
    dischargeStartMills?: number | undefined;
    dischargeStartLevel?: number | undefined;
    dischargeEndMills?: number | undefined;
    dischargeEndLevel?: number | undefined;
    chargeDurationMinutes?: number | undefined;
    dischargeDurationMinutes?: number | undefined;
    isComplete?: boolean;
}

/** Dashboard chart data response with all calculated series */
export interface DashboardChartData {
    /** IOB (Insulin on Board) time series */
    iobSeries?: TimeSeriesPoint[];
    /** COB (Carbs on Board) time series */
    cobSeries?: TimeSeriesPoint[];
    /** Basal rate time series with temp basal indicators */
    basalSeries?: BasalPoint[];
    /** Default basal rate from profile (U/hr) */
    defaultBasalRate?: number;
    /** Maximum basal rate in the series (for Y-axis scaling) */
    maxBasalRate?: number;
    /** Maximum IOB in the series (for Y-axis scaling) */
    maxIob?: number;
    /** Maximum COB in the series (for Y-axis scaling) */
    maxCob?: number;
    /** Pump mode state spans for chart background coloring */
    pumpModeSpans?: StateSpan[];
    /** Basal delivery state spans (pump-confirmed delivery data) */
    basalDeliverySpans?: StateSpan[];
    /** Profile state spans showing active profile changes */
    profileSpans?: StateSpan[];
}

/** Time series data point with timestamp and value */
export interface TimeSeriesPoint {
    /** Timestamp in Unix milliseconds */
    timestamp?: number;
    /** Value at this timestamp */
    value?: number;
}

/** Basal rate data point */
export interface BasalPoint {
    /** Timestamp in Unix milliseconds */
    timestamp?: number;
    /** Effective basal rate in U/hr */
    rate?: number;
    /** Scheduled basal rate from profile in U/hr */
    scheduledRate?: number;
    /** Origin of this basal rate - where it came from */
    origin?: BasalDeliveryOrigin;
}

export interface StateSpan {
    id?: string | undefined;
    category?: StateSpanCategory;
    state?: string | undefined;
    startMills?: number;
    endMills?: number | undefined;
    source?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
    originalId?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    canonicalId?: string | undefined;
    sources?: string[] | undefined;
}

export interface ClockFacePublicDto {
    id?: string;
    config?: ClockFaceConfig;
}

export interface ClockFaceConfig {
    rows?: ClockRow[];
    settings?: ClockSettings;
}

export interface ClockRow {
    elements?: ClockElement[];
}

export interface ClockElement {
    type?: string;
    size?: number | undefined;
    showUnits?: boolean | undefined;
    hours?: number | undefined;
    width?: number | undefined;
    height?: number | undefined;
    minutesAhead?: number | undefined;
    format?: string | undefined;
    definitionId?: string | undefined;
    show?: string[] | undefined;
    categories?: string[] | undefined;
    visibilityThreshold?: string | undefined;
    text?: string | undefined;
    style?: ClockElementStyle | undefined;
    chartConfig?: ClockChartConfig | undefined;
}

export interface ClockElementStyle {
    color?: string | undefined;
    font?: string | undefined;
    fontWeight?: string | undefined;
    opacity?: number | undefined;
    custom?: { [key: string]: string; } | undefined;
}

export interface ClockChartConfig {
    showIob?: boolean;
    showCob?: boolean;
    showBasal?: boolean;
    showBolus?: boolean;
    showCarbs?: boolean;
    showDeviceEvents?: boolean;
    showAlarms?: boolean;
    showTrackers?: boolean;
    showPredictions?: boolean;
    lockToggles?: boolean;
    showLegend?: boolean;
    asBackground?: boolean;
}

export interface ClockSettings {
    bgColor?: boolean;
    staleMinutes?: number;
    alwaysShowTime?: boolean;
    backgroundImage?: string | undefined;
    backgroundOpacity?: number;
}

export interface ClockFaceListItem {
    id?: string;
    name?: string;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export interface ClockFace {
    id?: string;
    userId?: string;
    name?: string;
    config?: ClockFaceConfig;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export interface CreateClockFaceRequest {
    name?: string;
    config?: ClockFaceConfig;
}

export interface UpdateClockFaceRequest {
    name?: string | undefined;
    config?: ClockFaceConfig | undefined;
}

/** Proxy configuration DTO */
export interface ProxyConfigurationDto {
    nightscoutUrl?: string;
    defaultStrategy?: string;
    enableDetailedLogging?: boolean;
}

export interface CompatibilityMetrics {
    totalRequests?: number;
    perfectMatches?: number;
    minorDifferences?: number;
    majorDifferences?: number;
    criticalDifferences?: number;
    compatibilityScore?: number;
    averageNightscoutResponseTime?: number;
    averageNocturneResponseTime?: number;
}

export interface EndpointMetrics {
    endpoint?: string;
    totalRequests?: number;
    perfectMatches?: number;
    minorDifferences?: number;
    majorDifferences?: number;
    criticalDifferences?: number;
    compatibilityScore?: number;
    averageNightscoutResponseTime?: number;
    averageNocturneResponseTime?: number;
}

/** Analyses list response */
export interface AnalysesListResponse {
    analyses?: AnalysisListItemDto[];
    total?: number;
}

/** Analysis list item DTO */
export interface AnalysisListItemDto {
    id?: string;
    correlationId?: string;
    analysisTimestamp?: Date;
    requestMethod?: string;
    requestPath?: string;
    overallMatch?: ResponseMatchType;
    statusCodeMatch?: boolean;
    bodyMatch?: boolean;
    nightscoutStatusCode?: number | undefined;
    nocturneStatusCode?: number | undefined;
    nightscoutResponseTimeMs?: number | undefined;
    nocturneResponseTimeMs?: number | undefined;
    totalProcessingTimeMs?: number;
    summary?: string;
    criticalDiscrepancyCount?: number;
    majorDiscrepancyCount?: number;
    minorDiscrepancyCount?: number;
    nightscoutMissing?: boolean;
    nocturneMissing?: boolean;
}

export enum ResponseMatchType {
    Perfect = 0,
    MinorDifferences = 1,
    MajorDifferences = 2,
    CriticalDifferences = 3,
    NightscoutMissing = 4,
    NocturneMissing = 5,
    BothMissing = 6,
    ComparisonError = 7,
}

/** Analysis detail DTO */
export interface AnalysisDetailDto {
    id?: string;
    correlationId?: string;
    analysisTimestamp?: Date;
    requestMethod?: string;
    requestPath?: string;
    overallMatch?: ResponseMatchType;
    statusCodeMatch?: boolean;
    bodyMatch?: boolean;
    nightscoutStatusCode?: number | undefined;
    nocturneStatusCode?: number | undefined;
    nightscoutResponseTimeMs?: number | undefined;
    nocturneResponseTimeMs?: number | undefined;
    totalProcessingTimeMs?: number;
    summary?: string;
    selectedResponseTarget?: string | undefined;
    selectionReason?: string | undefined;
    criticalDiscrepancyCount?: number;
    majorDiscrepancyCount?: number;
    minorDiscrepancyCount?: number;
    nightscoutMissing?: boolean;
    nocturneMissing?: boolean;
    errorMessage?: string | undefined;
    discrepancies?: DiscrepancyDetailDto[];
}

export interface DiscrepancyDetailDto {
    id?: string;
    discrepancyType?: DiscrepancyType;
    severity?: DiscrepancySeverity;
    field?: string;
    nightscoutValue?: string;
    nocturneValue?: string;
    description?: string;
    recordedAt?: Date;
}

export enum DiscrepancyType {
    StatusCode = 0,
    Header = 1,
    ContentType = 2,
    Body = 3,
    JsonStructure = 4,
    StringValue = 5,
    NumericValue = 6,
    Timestamp = 7,
    ArrayLength = 8,
    Performance = 9,
}

export enum DiscrepancySeverity {
    Minor = 0,
    Major = 1,
    Critical = 2,
}

/** Result of manual API comparison test */
export interface ManualTestResult {
    /** The API path that was tested */
    queryPath?: string;
    /** HTTP method used */
    method?: string;
    /** When the test was performed */
    timestamp?: Date;
    /** Raw JSON response from Nightscout */
    nightscoutResponse?: string | undefined;
    /** Raw JSON response from Nocturne */
    nocturneResponse?: string | undefined;
    /** HTTP status code from Nightscout */
    nightscoutStatusCode?: number | undefined;
    /** HTTP status code from Nocturne */
    nocturneStatusCode?: number | undefined;
    /** Response time from Nightscout in milliseconds */
    nightscoutResponseTimeMs?: number;
    /** Response time from Nocturne in milliseconds */
    nocturneResponseTimeMs?: number;
    /** Error message if Nightscout request failed */
    nightscoutError?: string | undefined;
    /** Error message if Nocturne request failed */
    nocturneError?: string | undefined;
}

/** Request for manual API comparison test */
export interface ManualTestRequest {
    /** Base URL of the Nightscout server to compare against */
    nightscoutUrl?: string;
    /** API secret (SHA1 hash or plain text) */
    apiSecret?: string | undefined;
    /** API path to test (e.g., /api/v1/entries?count=10) */
    queryPath?: string;
    /** HTTP method (GET, POST, etc.) - defaults to GET */
    method?: string | undefined;
    /** Optional request body for POST/PUT requests */
    requestBody?: string | undefined;
}

export interface ConnectorFoodEntry {
    id?: string;
    connectorSource?: string;
    externalEntryId?: string;
    externalFoodId?: string;
    foodId?: string | undefined;
    food?: Food | undefined;
    consumedAt?: Date;
    loggedAt?: Date | undefined;
    mealName?: string;
    carbs?: number;
    protein?: number;
    fat?: number;
    energy?: number;
    servings?: number;
    servingDescription?: string | undefined;
    status?: ConnectorFoodEntryStatus;
    matchedTreatmentId?: string | undefined;
    resolvedAt?: Date | undefined;
}

export interface Food {
    _id?: string | undefined;
    type?: string;
    category?: string;
    subcategory?: string;
    name?: string;
    portion?: number;
    carbs?: number;
    fat?: number;
    protein?: number;
    energy?: number;
    gi?: number;
    unit?: string;
    foods?: QuickPickFood[] | undefined;
    hideafteruse?: boolean;
    hidden?: boolean;
    position?: number;
    created_at?: string | undefined;
}

export interface QuickPickFood {
    name?: string;
    portion?: number;
    carbs?: number;
    unit?: string;
    portions?: number;
}

export enum ConnectorFoodEntryStatus {
    Pending = "Pending",
    Matched = "Matched",
    Standalone = "Standalone",
    Deleted = "Deleted",
}

export interface ConnectorFoodEntryImport {
    connectorSource?: string;
    externalEntryId?: string;
    externalFoodId?: string;
    consumedAt?: Date;
    loggedAt?: Date | undefined;
    mealName?: string;
    carbs?: number;
    protein?: number;
    fat?: number;
    energy?: number;
    servings?: number;
    servingDescription?: string | undefined;
    food?: ConnectorFoodImport | undefined;
}

export interface ConnectorFoodImport {
    externalId?: string;
    name?: string;
    brandName?: string | undefined;
    carbs?: number;
    protein?: number;
    fat?: number;
    energy?: number;
    portion?: number;
    unit?: string | undefined;
}

export interface InAppNotificationDto {
    id?: string;
    type?: InAppNotificationType;
    urgency?: NotificationUrgency;
    title?: string;
    subtitle?: string | undefined;
    createdAt?: Date;
    sourceId?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
    actions?: NotificationActionDto[];
}

export enum InAppNotificationType {
    PasswordResetRequest = "PasswordResetRequest",
    UnconfiguredTracker = "UnconfiguredTracker",
    TrackerAlert = "TrackerAlert",
    StatisticsSummary = "StatisticsSummary",
    HelpResponse = "HelpResponse",
    AnonymousLoginRequest = "AnonymousLoginRequest",
    PredictedLow = "PredictedLow",
    SuggestedMealMatch = "SuggestedMealMatch",
    SuggestedTrackerMatch = "SuggestedTrackerMatch",
}

export enum NotificationUrgency {
    Info = "Info",
    Warn = "Warn",
    Hazard = "Hazard",
    Urgent = "Urgent",
}

export interface NotificationActionDto {
    actionId?: string;
    label?: string;
    icon?: string | undefined;
    variant?: string | undefined;
}

/** Request model for creating test notifications */
export interface TestNotificationRequest {
    /** Type of notification to create */
    type?: InAppNotificationType;
    /** Urgency level for the notification */
    urgency?: NotificationUrgency;
    /** Optional title (defaults to "Test {Type} Notification") */
    title?: string | undefined;
    /** Optional subtitle */
    subtitle?: string | undefined;
    /** Optional source ID for grouping */
    sourceId?: string | undefined;
    /** Optional actions for the notification */
    actions?: NotificationActionDto[] | undefined;
    /** Optional resolution conditions */
    resolutionConditions?: ResolutionConditions | undefined;
    /** Optional metadata */
    metadata?: { [key: string]: any; } | undefined;
}

export interface ResolutionConditions {
    expiresAt?: Date | undefined;
    sourceDeletedType?: string | undefined;
    glucose?: GlucoseCondition | undefined;
}

export interface GlucoseCondition {
    aboveMgDl?: number | undefined;
    belowMgDl?: number | undefined;
    sustainedMinutes?: number | undefined;
}

/** Response for starting a deduplication job */
export interface DeduplicationJobResponse {
    jobId?: string;
    message?: string;
    statusUrl?: string;
}

export interface DeduplicationJobStatus {
    jobId?: string;
    state?: DeduplicationJobState;
    startedAt?: Date;
    completedAt?: Date | undefined;
    progress?: DeduplicationProgress | undefined;
    result?: DeduplicationResult | undefined;
}

export enum DeduplicationJobState {
    Pending = "Pending",
    Running = "Running",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
}

export interface DeduplicationProgress {
    totalRecords?: number;
    processedRecords?: number;
    groupsFound?: number;
    recordsLinked?: number;
    currentPhase?: string;
    percentComplete?: number;
}

export interface DeduplicationResult {
    totalRecordsProcessed?: number;
    canonicalGroupsCreated?: number;
    recordsLinked?: number;
    duplicateGroupsFound?: number;
    duration?: string;
    entriesProcessed?: number;
    treatmentsProcessed?: number;
    stateSpansProcessed?: number;
    success?: boolean;
    errorMessage?: string | undefined;
}

/** Response for cancelling a job */
export interface CancelJobResponse {
    jobId?: string;
    cancelled?: boolean;
    message?: string;
}

/** Response containing linked records for a canonical group */
export interface LinkedRecordsResponse {
    canonicalId?: string;
    recordType?: RecordType;
    linkedRecords?: LinkedRecord[];
}

export enum RecordType {
    Entry = "Entry",
    Treatment = "Treatment",
    StateSpan = "StateSpan",
}

export interface LinkedRecord {
    id?: string | undefined;
    canonicalId?: string;
    recordType?: RecordType;
    recordId?: string;
    sourceTimestamp?: number;
    dataSource?: string;
    isPrimary?: boolean;
    createdAt?: Date;
}

export interface DeviceAgeInfo {
    found?: boolean;
    age?: number;
    days?: number;
    hours?: number;
    treatmentDate?: number | undefined;
    notes?: string | undefined;
    minFractions?: number;
    level?: number;
    display?: string;
    notification?: DeviceAgeNotification | undefined;
}

export interface DeviceAgeNotification {
    title?: string;
    message?: string;
    pushoverSound?: string;
    level?: number;
    group?: string;
}

export interface SensorAgeInfo {
    "Sensor Start"?: DeviceAgeInfo;
    "Sensor Change"?: DeviceAgeInfo;
    min?: string;
}

export interface DeviceAlert {
    id?: string;
    deviceId?: string;
    userId?: string;
    alertType?: DeviceAlertType;
    severity?: DeviceIssueSeverity;
    title?: string;
    message?: string;
    triggerTime?: Date;
    acknowledged?: boolean;
    acknowledgedAt?: Date | undefined;
    data?: { [key: string]: any; } | undefined;
}

export enum DeviceAlertType {
    BatteryWarning = 0,
    BatteryCritical = 1,
    SensorExpirationWarning = 2,
    SensorExpired = 3,
    CalibrationReminder = 4,
    CalibrationOverdue = 5,
    DataGapDetected = 6,
    CommunicationFailure = 7,
    DeviceError = 8,
    MaintenanceRequired = 9,
}

export enum DeviceIssueSeverity {
    Low = 0,
    Medium = 1,
    High = 2,
    Critical = 3,
}

/** Device alert summary model */
export interface DeviceAlertSummary {
    /** Total number of registered devices */
    totalDevices?: number;
    /** Number of active alerts */
    activeAlerts?: number;
    /** Number of critical alerts */
    criticalAlerts?: number;
    /** Number of warning alerts */
    warningAlerts?: number;
    /** Alerts grouped by type */
    alertsByType?: { [key in keyof typeof DeviceAlertType]?: number; };
}

/** Device alert settings model */
export interface DeviceAlertSettings {
    /** Enable email notifications */
    emailEnabled?: boolean;
    /** Enable push notifications */
    pushEnabled?: boolean;
    /** Enable SMS notifications */
    smsEnabled?: boolean;
    /** Enable quiet hours */
    quietHoursEnabled?: boolean;
    /** Quiet hours start time */
    quietHoursStart?: string;
    /** Quiet hours end time */
    quietHoursEnd?: string;
    /** Critical alerts override quiet hours */
    criticalAlertsOverrideQuietHours?: boolean;
    /** Battery low threshold percentage */
    batteryLowThreshold?: number;
    /** Sensor expiration warning hours */
    sensorExpirationWarningHours?: number;
    /** Data gap warning minutes */
    dataGapWarningMinutes?: number;
    /** Calibration reminder hours */
    calibrationReminderHours?: number;
}

export interface DeviceHealth {
    id?: string;
    userId?: string;
    deviceId?: string;
    deviceType?: DeviceType;
    deviceName?: string;
    manufacturer?: string | undefined;
    model?: string | undefined;
    serialNumber?: string | undefined;
    batteryLevel?: number | undefined;
    sensorExpiration?: Date | undefined;
    lastCalibration?: Date | undefined;
    lastDataReceived?: Date | undefined;
    lastMaintenanceAlert?: Date | undefined;
    batteryWarningThreshold?: number;
    sensorExpirationWarningHours?: number;
    dataGapWarningMinutes?: number;
    calibrationReminderHours?: number;
    status?: DeviceStatusType;
    lastErrorMessage?: string | undefined;
    lastStatusUpdate?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export enum DeviceType {
    CGM = 0,
    InsulinPump = 1,
    BGM = 2,
    Unknown = 3,
}

export enum DeviceStatusType {
    Active = 0,
    Inactive = 1,
    Warning = 2,
    Error = 3,
    Maintenance = 4,
}

export interface DeviceRegistrationRequest {
    deviceId?: string;
    deviceType?: DeviceType;
    deviceName?: string;
    manufacturer?: string | undefined;
    model?: string | undefined;
    serialNumber?: string | undefined;
    batteryLevel?: number | undefined;
    sensorExpiration?: Date | undefined;
}

export interface DeviceSettingsUpdate {
    batteryWarningThreshold?: number | undefined;
    sensorExpirationWarningHours?: number | undefined;
    dataGapWarningMinutes?: number | undefined;
    calibrationReminderHours?: number | undefined;
}

export interface DeviceHealthUpdate {
    batteryLevel?: number | undefined;
    sensorExpiration?: Date | undefined;
    lastCalibration?: Date | undefined;
    status?: DeviceStatusType | undefined;
    lastErrorMessage?: string | undefined;
    deviceSpecificData?: { [key: string]: any; } | undefined;
}

export interface DiscrepancyAnalysisDto {
    id?: string;
    correlationId?: string;
    analysisTimestamp?: Date;
    requestMethod?: string;
    requestPath?: string;
    overallMatch?: number;
    statusCodeMatch?: boolean;
    bodyMatch?: boolean;
    nightscoutStatusCode?: number | undefined;
    nocturneStatusCode?: number | undefined;
    nightscoutResponseTimeMs?: number | undefined;
    nocturneResponseTimeMs?: number | undefined;
    totalProcessingTimeMs?: number;
    summary?: string;
    selectedResponseTarget?: string | undefined;
    selectionReason?: string | undefined;
    criticalDiscrepancyCount?: number;
    majorDiscrepancyCount?: number;
    minorDiscrepancyCount?: number;
    nightscoutMissing?: boolean;
    nocturneMissing?: boolean;
    errorMessage?: string | undefined;
    discrepancies?: DiscrepancyDetailDto[];
}

export interface CompatibilityStatus {
    overallScore?: number;
    totalRequests?: number;
    healthStatus?: string;
    lastUpdated?: Date;
    criticalIssues?: number;
    majorIssues?: number;
    minorIssues?: number;
}

export interface ForwardedDiscrepancyDto {
    sourceId?: string;
    receivedAt?: Date;
    analysis?: DiscrepancyAnalysisDto;
}

/** A suggested meal match between a food entry and treatment */
export interface SuggestedMealMatch {
    foodEntryId?: string;
    foodName?: string | undefined;
    mealName?: string | undefined;
    carbs?: number;
    consumedAt?: Date;
    treatmentId?: string;
    treatmentCarbs?: number;
    treatmentMills?: number;
    matchScore?: number;
}

/** Request to accept a meal match */
export interface AcceptMatchRequest {
    foodEntryId?: string;
    treatmentId?: string;
    carbs?: number;
    timeOffsetMinutes?: number;
}

/** Request to dismiss a meal match */
export interface DismissMatchRequest {
    foodEntryId?: string;
}

/** Result of testing a migration connection */
export interface TestMigrationConnectionResult {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    siteName?: string | undefined;
    version?: string | undefined;
    entryCount?: number | undefined;
    treatmentCount?: number | undefined;
    availableCollections?: string[];
}

/** Request to test a Nightscout connection */
export interface TestMigrationConnectionRequest {
    mode?: MigrationMode;
    nightscoutUrl?: string | undefined;
    nightscoutApiSecret?: string | undefined;
    mongoConnectionString?: string | undefined;
    mongoDatabaseName?: string | undefined;
}

/** Enumerates the modes for data migration */
export enum MigrationMode {
    Api = 0,
    MongoDb = 1,
}

/** Information about a migration job */
export interface MigrationJobInfo {
    id?: string;
    mode?: MigrationMode;
    createdAt?: Date;
    sourceDescription?: string | undefined;
    state?: MigrationJobState;
    startedAt?: Date | undefined;
    completedAt?: Date | undefined;
    errorMessage?: string | undefined;
}

/** Current state of a migration job */
export enum MigrationJobState {
    Pending = 0,
    Validating = 1,
    Running = 2,
    Completed = 3,
    Failed = 4,
    Cancelled = 5,
}

/** Request to start a new migration job */
export interface StartMigrationRequest {
    /** Migration mode (API or MongoDB) */
    mode?: MigrationMode;
    /** Nightscout URL (for API mode) */
    nightscoutUrl?: string | undefined;
    /** Nightscout API secret (for API mode) */
    nightscoutApiSecret?: string | undefined;
    /** MongoDB connection string (for MongoDB mode) */
    mongoConnectionString?: string | undefined;
    /** MongoDB database name (for MongoDB mode) */
    mongoDatabaseName?: string | undefined;
    /** Collections to migrate. Empty means all. */
    collections?: string[];
    /** Start date for migration (optional) */
    startDate?: Date | undefined;
    /** End date for migration (optional) */
    endDate?: Date | undefined;
}

/** Status of a migration job including progress */
export interface MigrationJobStatus {
    jobId?: string;
    state?: MigrationJobState;
    progressPercentage?: number;
    currentOperation?: string | undefined;
    errorMessage?: string | undefined;
    startedAt?: Date;
    completedAt?: Date | undefined;
    estimatedTimeRemaining?: string | undefined;
    collectionProgress?: { [key: string]: CollectionProgress; };
}

/** Progress for a specific collection */
export interface CollectionProgress {
    collectionName?: string;
    totalDocuments?: number;
    documentsMigrated?: number;
    documentsFailed?: number;
    isComplete?: boolean;
}

/** Pending migration configuration from environment variables */
export interface PendingMigrationConfig {
    /** Whether there is a pending migration configuration in env vars */
    hasPendingConfig?: boolean;
    /** Migration mode from MIGRATION_MODE env var */
    mode?: MigrationMode | undefined;
    /** Nightscout URL from MIGRATION_NS_URL env var */
    nightscoutUrl?: string | undefined;
    /** Whether MIGRATION_NS_API_SECRET is set (never returns the actual secret) */
    hasApiSecret?: boolean;
    /** Whether MIGRATION_MONGO_CONNECTION_STRING is set (never returns the actual string) */
    hasMongoConnectionString?: boolean;
    /** MongoDB database name from MIGRATION_MONGO_DATABASE_NAME env var */
    mongoDatabaseName?: string | undefined;
}

/** Migration source DTO for API responses */
export interface MigrationSourceDto {
    /** Unique identifier for this source */
    id?: string;
    /** Migration mode (Api or MongoDb) */
    mode?: MigrationMode;
    /** Nightscout URL (for API mode) */
    nightscoutUrl?: string | undefined;
    /** MongoDB database name (for MongoDB mode) */
    mongoDatabaseName?: string | undefined;
    /** When the last successful migration completed */
    lastMigrationAt?: Date | undefined;
    /** Newest data timestamp migrated (for "since last" default) */
    lastMigratedDataTimestamp?: Date | undefined;
    /** When this source was first added */
    createdAt?: Date;
}

export interface MyFitnessPalMatchingSettings {
    matchTimeWindowMinutes?: number;
    matchCarbTolerancePercent?: number;
    matchCarbToleranceGrams?: number;
    enableMatchNotifications?: boolean;
}

/** Response containing glucose predictions. */
export interface GlucosePredictionResponse {
    /** Timestamp when predictions were calculated */
    timestamp?: Date;
    /** Current blood glucose (mg/dL) */
    currentBg?: number;
    /** Rate of glucose change (mg/dL per 5 min) */
    delta?: number;
    /** Eventual blood glucose if trend continues (mg/dL) */
    eventualBg?: number;
    /** Current insulin on board (U) */
    iob?: number;
    /** Current carbs on board (g) */
    cob?: number;
    /** Sensitivity ratio used (1.0 = normal) */
    sensitivityRatio?: number | undefined;
    /** Prediction interval in minutes */
    intervalMinutes?: number;
    /** Prediction curves with different scenarios */
    predictions?: PredictionCurves;
}

/** Different prediction curves for visualization. */
export interface PredictionCurves {
    /** Main prediction curve (mg/dL values at 5-min intervals) */
    default?: number[] | undefined;
    /** IOB-only prediction (ignoring COB) */
    iobOnly?: number[] | undefined;
    /** UAM (Unannounced Meal) prediction */
    uam?: number[] | undefined;
    /** COB-based prediction */
    cob?: number[] | undefined;
    /** Zero-temp prediction (what happens if basal stops) */
    zeroTemp?: number[] | undefined;
}

/** Error response for prediction failures. */
export interface PredictionErrorResponse {
    /** Error message */
    error?: string;
}

/** Status of the prediction service. */
export interface PredictionStatusResponse {
    /** Whether the oref library is available */
    available?: boolean;
    /** Version of the oref library */
    version?: string | undefined;
    /** Health check result (JSON) */
    healthCheck?: string | undefined;
}

export interface ProcessingStatus {
    correlationId?: string;
    status?: string;
    progress?: number;
    processedCount?: number;
    totalCount?: number;
    startedAt?: Date;
    completedAt?: Date | undefined;
    errors?: string[];
    results?: any | undefined;
}

export interface ProcessingStatusResponse extends ProcessingStatus {
}

export function isProcessingStatusResponse(object: any): object is ProcessingStatusResponse {
    return object && object[''] === 'ProcessingStatusResponse';
}

/** Response for single point retrospective data */
export interface RetrospectiveDataResponse {
    time?: number;
    timeFormatted?: string | undefined;
    glucose?: GlucoseData | undefined;
    iob?: IobData | undefined;
    cob?: CobData | undefined;
    basal?: BasalData | undefined;
    recentTreatments?: TreatmentSummaryData[] | undefined;
}

/** Glucose data at a specific point in time */
export interface GlucoseData {
    value?: number;
    direction?: string | undefined;
    delta?: number | undefined;
}

/** IOB data at a specific point in time */
export interface IobData {
    total?: number;
    bolus?: number;
    basal?: number;
    activity?: number | undefined;
    source?: string | undefined;
}

/** COB data at a specific point in time */
export interface CobData {
    total?: number;
    isDecaying?: number;
    carbsHr?: number | undefined;
    rawCarbImpact?: number | undefined;
    source?: string | undefined;
}

/** Basal rate data at a specific point in time */
export interface BasalData {
    rate?: number;
    isTemp?: boolean;
}

/** Treatment summary for recent treatments */
export interface TreatmentSummaryData {
    id?: string | undefined;
    mills?: number;
    eventType?: string | undefined;
    insulin?: number | undefined;
    carbs?: number | undefined;
    rate?: number | undefined;
    duration?: number | undefined;
    notes?: string | undefined;
}

/** Response for retrospective timeline */
export interface RetrospectiveTimelineResponse {
    date?: string | undefined;
    startTime?: number;
    endTime?: number;
    intervalMinutes?: number;
    totalPoints?: number;
    data?: RetrospectiveDataPoint[] | undefined;
}

/** Data point for retrospective timeline */
export interface RetrospectiveDataPoint {
    time?: number;
    hour?: number;
    minute?: number;
    timeLabel?: string | undefined;
    glucose?: number | undefined;
    glucoseDirection?: string | undefined;
    iob?: number;
    bolusIob?: number;
    basalIob?: number;
    cob?: number;
    basalRate?: number;
    isTemp?: boolean;
}

/** Response for basal timeline */
export interface BasalTimelineResponse {
    date?: string | undefined;
    startTime?: number;
    endTime?: number;
    intervalMinutes?: number;
    data?: BasalDataPoint[] | undefined;
}

/** Data point for basal timeline */
export interface BasalDataPoint {
    time?: number;
    hour?: number;
    minute?: number;
    timeLabel?: string | undefined;
    rate?: number;
    isTemp?: boolean;
}

export interface ServicesOverview {
    activeDataSources?: DataSourceInfo[];
    availableConnectors?: AvailableConnector[];
    uploaderApps?: UploaderApp[];
    apiEndpoint?: ApiEndpointInfo;
}

export interface DataSourceInfo {
    id?: string;
    name?: string;
    deviceId?: string;
    category?: string;
    sourceType?: string;
    description?: string;
    lastSeen?: Date | undefined;
    firstSeen?: Date | undefined;
    entriesLast24h?: number;
    totalEntries?: number;
    status?: string;
    minutesSinceLastData?: number | undefined;
    icon?: string;
    isHealthy?: boolean;
}

export interface AvailableConnector {
    id?: string;
    name?: string;
    category?: string;
    description?: string;
    icon?: string;
    available?: boolean;
    requiresServerConfig?: boolean;
    isConfigured?: boolean;
    configFields?: ConnectorConfigField[] | undefined;
    documentationUrl?: string | undefined;
    dataSourceId?: string | undefined;
}

export interface ConnectorConfigField {
    id?: string;
    label?: string;
    type?: string;
    required?: boolean;
    placeholder?: string | undefined;
    helpText?: string | undefined;
    options?: SelectOption[] | undefined;
}

export interface SelectOption {
    value?: string;
    label?: string;
}

export interface UploaderApp {
    id?: string;
    name?: string;
    platform?: string;
    description?: string;
    category?: string;
    icon?: string;
    setupInstructions?: SetupStep[] | undefined;
    url?: string | undefined;
}

export interface SetupStep {
    step?: number;
    title?: string;
    description?: string;
    imageUrl?: string | undefined;
}

export interface ApiEndpointInfo {
    baseUrl?: string;
    requiresApiSecret?: boolean;
    isAuthenticated?: boolean;
    entriesEndpoint?: string;
    treatmentsEndpoint?: string;
    deviceStatusEndpoint?: string;
}

/** Response model for uploader setup instructions */
export interface UploaderSetupResponse {
    /** The uploader app details */
    app?: UploaderApp;
    /** Base URL for this Nocturne instance */
    baseUrl?: string;
    /** Placeholder for where the API secret goes */
    apiSecretPlaceholder?: string;
    /** Full API URL (base + /api/v1) */
    fullApiUrl?: string;
    /** Entries endpoint URL */
    entriesUrl?: string;
    /** Treatments endpoint URL */
    treatmentsUrl?: string;
    /** Device status endpoint URL */
    deviceStatusUrl?: string;
    /** xDrip+ style URL with embedded secret placeholder */
    xdripStyleUrl?: string;
}

export interface DataSourceDeleteResult {
    success?: boolean;
    entriesDeleted?: number;
    treatmentsDeleted?: number;
    deviceStatusDeleted?: number;
    dataSource?: string;
    error?: string | undefined;
}

export interface ConnectorDataSummary {
    connectorId?: string;
    entries?: number;
    treatments?: number;
    deviceStatuses?: number;
    total?: number;
}

export interface SyncResult {
    success?: boolean;
    message?: string;
    startTime?: Date;
    endTime?: Date;
    itemsSynced?: { [key in keyof typeof SyncDataType]?: number; };
    lastEntryTimes?: { [key in keyof typeof SyncDataType]?: Date; };
    errors?: string[];
}

export enum SyncDataType {
    Glucose = "Glucose",
    Treatments = "Treatments",
    Profiles = "Profiles",
    DeviceStatus = "DeviceStatus",
    Activity = "Activity",
    Food = "Food",
}

export interface SyncRequest {
    from?: Date | undefined;
    to?: Date | undefined;
    dataTypes?: SyncDataType[];
}

/** Response model for connector sync status */
export interface ConnectorSyncStatus {
    /** The connector ID (e.g., "dexcom", "libre") */
    connectorId?: string;
    /** The data source name used in the database (e.g., "dexcom-connector") */
    dataSource?: string;
    /** The timestamp of the latest entry, or null if no entries exist */
    latestEntryTimestamp?: Date | undefined;
    /** The timestamp of the oldest entry, or null if no entries exist */
    oldestEntryTimestamp?: Date | undefined;
    /** The timestamp of the latest treatment, or null if no treatments exist */
    latestTreatmentTimestamp?: Date | undefined;
    /** The timestamp of the oldest treatment, or null if no treatments exist */
    oldestTreatmentTimestamp?: Date | undefined;
    /** Whether any entries exist for this connector */
    hasEntries?: boolean;
    /** Whether any treatments exist for this connector */
    hasTreatments?: boolean;
    /** Current connector state (Idle, Syncing, BackingOff, Error) */
    state?: string;
    /** Optional message describing the current state */
    stateMessage?: string | undefined;
    /** Whether the connector is healthy */
    isHealthy?: boolean;
    /** When this status was queried */
    queriedAt?: Date;
}

export interface CreateStateSpanRequest {
    category?: StateSpanCategory;
    state?: string | undefined;
    startMills?: number;
    endMills?: number | undefined;
    source?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
    originalId?: string | undefined;
}

export interface UpdateStateSpanRequest {
    category?: StateSpanCategory | undefined;
    state?: string | undefined;
    startMills?: number | undefined;
    endMills?: number | undefined;
    source?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
}

export interface StatusResponse {
    status?: string;
    name?: string | undefined;
    version?: string | undefined;
    apiVersion?: string | undefined;
    serverTime?: Date;
    serverTimeEpoch?: number;
    enabled?: string[] | undefined;
    apiEnabled?: boolean;
    roles?: string[] | undefined;
    settings?: { [key: string]: any; } | undefined;
    extendedSettings?: { [key: string]: any; } | undefined;
    careportalEnabled?: boolean | undefined;
    boluscalcEnabled?: boolean | undefined;
    authorized?: any | undefined;
    runtimeState?: string | undefined;
    head?: string | undefined;
}

export interface SystemEvent {
    id?: string | undefined;
    eventType?: SystemEventType;
    category?: SystemEventCategory;
    code?: string | undefined;
    description?: string | undefined;
    mills?: number;
    source?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
    originalId?: string | undefined;
    createdAt?: Date | undefined;
}

export enum SystemEventType {
    Alarm = "Alarm",
    Hazard = "Hazard",
    Warning = "Warning",
    Info = "Info",
}

export enum SystemEventCategory {
    Pump = "Pump",
    Cgm = "Cgm",
    Connectivity = "Connectivity",
}

export interface CreateSystemEventRequest {
    eventType?: SystemEventType;
    category?: SystemEventCategory;
    code?: string | undefined;
    description?: string | undefined;
    mills?: number;
    source?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
    originalId?: string | undefined;
}

/** DTO for tracker alerts returned to the frontend */
export interface TrackerAlertDto {
    instanceId?: string;
    definitionId?: string;
    thresholdId?: string;
    trackerName?: string;
    urgency?: NotificationUrgency;
    message?: string;
    pushEnabled?: boolean;
    audioEnabled?: boolean;
    audioSound?: string | undefined;
    vibrateEnabled?: boolean;
}

export interface TrackerDefinitionDto {
    id?: string;
    name?: string;
    description?: string | undefined;
    category?: TrackerCategory;
    icon?: string;
    triggerEventTypes?: string[];
    triggerNotesContains?: string | undefined;
    lifespanHours?: number | undefined;
    notificationThresholds?: NotificationThresholdDto[];
    isFavorite?: boolean;
    /** Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent */
    dashboardVisibility?: DashboardVisibility;
    /** Visibility level for this tracker (Public, Private, RoleRestricted) */
    visibility?: TrackerVisibility;
    /** Event type to create when tracker is started (for Nightscout compatibility) */
    startEventType?: string | undefined;
    /** Event type to create when tracker is completed (for Nightscout compatibility) */
    completionEventType?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export enum TrackerCategory {
    Consumable = "Consumable",
    Reservoir = "Reservoir",
    Appointment = "Appointment",
    Reminder = "Reminder",
    Custom = "Custom",
    Sensor = "Sensor",
    Cannula = "Cannula",
    Battery = "Battery",
}

export interface NotificationThresholdDto {
    id?: string | undefined;
    urgency?: NotificationUrgency;
    hours?: number;
    description?: string | undefined;
    displayOrder?: number;
    pushEnabled?: boolean;
    audioEnabled?: boolean;
    audioSound?: string | undefined;
    vibrateEnabled?: boolean;
    repeatIntervalMins?: number;
    maxRepeats?: number;
    respectQuietHours?: boolean;
}

export enum DashboardVisibility {
    Off = "Off",
    Always = "Always",
    Info = "Info",
    Warn = "Warn",
    Hazard = "Hazard",
    Urgent = "Urgent",
}

export enum TrackerVisibility {
    Public = "Public",
    Private = "Private",
    RoleRestricted = "RoleRestricted",
}

export interface CreateTrackerDefinitionRequest {
    name: string;
    description?: string | undefined;
    category?: TrackerCategory;
    icon?: string | undefined;
    triggerEventTypes?: string[] | undefined;
    triggerNotesContains?: string | undefined;
    lifespanHours?: number | undefined;
    notificationThresholds?: CreateNotificationThresholdRequest[] | undefined;
    isFavorite?: boolean;
    /** Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent */
    dashboardVisibility?: DashboardVisibility;
    /** Visibility level for this tracker (Public, Private, RoleRestricted) */
    visibility?: TrackerVisibility;
    /** Event type to create when tracker is started (for Nightscout compatibility) */
    startEventType?: string | undefined;
    /** Event type to create when tracker is completed (for Nightscout compatibility) */
    completionEventType?: string | undefined;
}

export interface CreateNotificationThresholdRequest {
    urgency?: NotificationUrgency;
    hours?: number;
    description?: string | undefined;
    displayOrder?: number;
    pushEnabled?: boolean;
    audioEnabled?: boolean;
    audioSound?: string | undefined;
    vibrateEnabled?: boolean;
    repeatIntervalMins?: number;
    maxRepeats?: number;
    respectQuietHours?: boolean;
}

export interface UpdateTrackerDefinitionRequest {
    name?: string | undefined;
    description?: string | undefined;
    category?: TrackerCategory | undefined;
    icon?: string | undefined;
    triggerEventTypes?: string[] | undefined;
    triggerNotesContains?: string | undefined;
    lifespanHours?: number | undefined;
    notificationThresholds?: CreateNotificationThresholdRequest[] | undefined;
    isFavorite?: boolean | undefined;
    /** Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent */
    dashboardVisibility?: DashboardVisibility | undefined;
    /** Visibility level for this tracker (Public, Private, RoleRestricted) */
    visibility?: TrackerVisibility | undefined;
    /** Event type to create when tracker is started (for Nightscout compatibility) */
    startEventType?: string | undefined;
    /** Event type to create when tracker is completed (for Nightscout compatibility) */
    completionEventType?: string | undefined;
}

export interface TrackerInstanceDto {
    id?: string;
    definitionId?: string;
    definitionName?: string;
    category?: TrackerCategory;
    icon?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    expectedEndAt?: Date | undefined;
    startNotes?: string | undefined;
    completionNotes?: string | undefined;
    completionReason?: CompletionReason | undefined;
    ageHours?: number;
    isActive?: boolean;
    lastAckedAt?: Date | undefined;
    ackSnoozeMins?: number | undefined;
}

export enum CompletionReason {
    Completed = "Completed",
    Expired = "Expired",
    Other = "Other",
    Failed = "Failed",
    FellOff = "FellOff",
    ReplacedEarly = "ReplacedEarly",
    Empty = "Empty",
    Refilled = "Refilled",
    Attended = "Attended",
    Rescheduled = "Rescheduled",
    Cancelled = "Cancelled",
    Missed = "Missed",
}

export interface StartTrackerInstanceRequest {
    definitionId: string;
    startNotes?: string | undefined;
    startTreatmentId?: string | undefined;
    /** Optional custom start time for backdating. Defaults to now if not provided. */
    startedAt?: Date | undefined;
}

export interface CompleteTrackerInstanceRequest {
    reason: CompletionReason;
    completionNotes?: string | undefined;
    completeTreatmentId?: string | undefined;
    /** Optional custom completion time for backdating. Defaults to now if not provided. */
    completedAt?: Date | undefined;
}

export interface AckTrackerRequest {
    snoozeMins?: number;
    global?: boolean;
}

export interface TrackerPresetDto {
    id?: string;
    name?: string;
    definitionId?: string;
    definitionName?: string;
    defaultStartNotes?: string | undefined;
    createdAt?: Date;
}

export interface CreateTrackerPresetRequest {
    name: string;
    definitionId: string;
    defaultStartNotes?: string | undefined;
}

export interface ApplyPresetRequest {
    overrideNotes?: string | undefined;
}

export interface TreatmentFoodBreakdown {
    treatmentId?: string;
    foods?: TreatmentFood[];
    isAttributed?: boolean;
    attributedCarbs?: number;
    unspecifiedCarbs?: number;
}

export interface TreatmentFood {
    id?: string;
    treatmentId?: string;
    foodId?: string | undefined;
    portions?: number;
    carbs?: number;
    timeOffsetMinutes?: number;
    note?: string | undefined;
    foodName?: string | undefined;
    carbsPerPortion?: number | undefined;
}

export interface TreatmentFoodRequest {
    foodId?: string | undefined;
    portions?: number | undefined;
    carbs?: number | undefined;
    timeOffsetMinutes?: number | undefined;
    note?: string | undefined;
    inputMode?: TreatmentFoodInputMode | undefined;
}

export enum TreatmentFoodInputMode {
    Portions = 0,
    Carbs = 1,
}

export interface MealTreatment {
    treatment?: Treatment;
    foods?: TreatmentFood[];
    isAttributed?: boolean;
    attributedCarbs?: number;
    unspecifiedCarbs?: number;
}

export interface UISettingsConfiguration {
    devices?: DeviceSettings;
    algorithm?: AlgorithmSettings;
    features?: FeatureSettings;
    notifications?: NotificationSettings;
    services?: ServicesSettings;
}

export interface DeviceSettings {
    connectedDevices?: ConnectedDevice[];
    autoConnect?: boolean;
    showRawData?: boolean;
    uploadEnabled?: boolean;
    cgmConfiguration?: CgmConfiguration;
}

export interface ConnectedDevice {
    id?: string;
    name?: string;
    type?: string;
    status?: string;
    battery?: number | undefined;
    lastSync?: Date | undefined;
    serialNumber?: string | undefined;
}

export interface CgmConfiguration {
    dataSourcePriority?: string;
    sensorWarmupHours?: number;
}

export interface AlgorithmSettings {
    prediction?: PredictionSettings;
    autosens?: AutosensSettings;
    carbAbsorption?: CarbAbsorptionSettings;
    loop?: LoopSettings;
    safetyLimits?: SafetyLimits;
}

export interface PredictionSettings {
    enabled?: boolean;
    minutes?: number;
    model?: string;
}

export interface AutosensSettings {
    enabled?: boolean;
    min?: number;
    max?: number;
}

export interface CarbAbsorptionSettings {
    defaultMinutes?: number;
    minRateGramsPerHour?: number;
}

export interface LoopSettings {
    enabled?: boolean;
    mode?: string;
    maxBasalRate?: number;
    maxBolus?: number;
    smbEnabled?: boolean;
    uamEnabled?: boolean;
}

export interface SafetyLimits {
    maxIOB?: number;
    maxDailyBasalMultiplier?: number;
}

export interface FeatureSettings {
    display?: DisplaySettings;
    widgets?: WidgetConfig[];
    plugins?: { [key: string]: PluginSettings; };
    battery?: BatteryDisplaySettings;
    trackerPills?: TrackerPillsSettings;
}

export interface DisplaySettings {
    nightMode?: boolean;
    theme?: string;
    timeFormat?: string;
    units?: string;
    showRawBG?: boolean;
    focusHours?: number;
}

export interface WidgetConfig {
    id?: WidgetId;
    enabled?: boolean;
    placement?: WidgetPlacement;
    size?: WidgetSize | undefined;
    settings?: { [key: string]: any; } | undefined;
}

export interface PluginSettings {
    enabled?: boolean;
    description?: string;
}

export interface BatteryDisplaySettings {
    warnThreshold?: number;
    urgentThreshold?: number;
    enableAlerts?: boolean;
    recentMinutes?: number;
    showVoltage?: boolean;
    showStatistics?: boolean;
}

export interface TrackerPillsSettings {
    enabled?: boolean;
    visibility?: string;
}

export interface NotificationSettings {
    alarmConfiguration?: UserAlarmConfiguration;
}

export interface UserAlarmConfiguration {
    version?: number;
    enabled?: boolean;
    soundEnabled?: boolean;
    vibrationEnabled?: boolean;
    globalVolume?: number;
    profiles?: AlarmProfileConfiguration[];
    quietHours?: QuietHoursConfiguration;
    customSounds?: CustomSoundReference[];
    emergencyContacts?: EmergencyContactConfig[];
    channels?: NotificationChannelsConfig;
}

export interface AlarmProfileConfiguration {
    id?: string;
    name?: string;
    description?: string | undefined;
    enabled?: boolean;
    alarmType?: AlarmTriggerType;
    threshold?: number;
    thresholdHigh?: number | undefined;
    forecastLeadTimeMinutes?: number | undefined;
    persistenceMinutes?: number;
    audio?: AlarmAudioSettings;
    vibration?: AlarmVibrationSettings;
    visual?: AlarmVisualSettings;
    snooze?: AlarmSnoozeSettings;
    reraise?: AlarmReraiseSettings;
    smartSnooze?: SmartSnoozeSettings;
    schedule?: AlarmScheduleSettings;
    priority?: AlarmPriority;
    overrideQuietHours?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date;
}

export enum AlarmTriggerType {
    High = "High",
    Low = "Low",
    UrgentHigh = "UrgentHigh",
    UrgentLow = "UrgentLow",
    RisingFast = "RisingFast",
    FallingFast = "FallingFast",
    StaleData = "StaleData",
    ForecastLow = "ForecastLow",
    Custom = "Custom",
}

export interface AlarmAudioSettings {
    enabled?: boolean;
    soundId?: string;
    customSoundUrl?: string | undefined;
    ascendingVolume?: boolean;
    startVolume?: number;
    maxVolume?: number;
    ascendDurationSeconds?: number;
    repeatCount?: number;
}

export interface AlarmVibrationSettings {
    enabled?: boolean;
    pattern?: string;
    customPattern?: number[] | undefined;
}

export interface AlarmVisualSettings {
    screenFlash?: boolean;
    flashColor?: string;
    flashIntervalMs?: number;
    persistentBanner?: boolean;
    wakeScreen?: boolean;
}

export interface AlarmSnoozeSettings {
    defaultMinutes?: number;
    options?: number[];
    maxMinutes?: number;
    maxSnoozeCount?: number | undefined;
}

export interface AlarmReraiseSettings {
    enabled?: boolean;
    intervalMinutes?: number;
    escalate?: boolean;
    escalationVolumeStep?: number;
}

export interface SmartSnoozeSettings {
    enabled?: boolean;
    extendWhenTrendingCorrect?: boolean;
    minDeltaThreshold?: number;
    extensionMinutes?: number;
    maxTotalMinutes?: number;
}

export interface AlarmScheduleSettings {
    enabled?: boolean;
    activeRanges?: TimeRange[];
    activeDays?: number[] | undefined;
    timezone?: string | undefined;
}

export interface TimeRange {
    startTime?: string;
    endTime?: string;
}

export enum AlarmPriority {
    Low = "Low",
    Normal = "Normal",
    High = "High",
    Critical = "Critical",
}

export interface QuietHoursConfiguration {
    enabled?: boolean;
    startTime?: string;
    endTime?: string;
    allowCritical?: boolean;
    reduceVolume?: boolean;
    quietVolume?: number;
}

export interface CustomSoundReference {
    id?: string;
    name?: string;
    url?: string;
    durationSeconds?: number | undefined;
    uploadedAt?: Date;
}

export interface EmergencyContactConfig {
    id?: string;
    name?: string;
    phone?: string | undefined;
    email?: string | undefined;
    criticalOnly?: boolean;
    delayMinutes?: number;
    enabled?: boolean;
}

export interface NotificationChannelsConfig {
    push?: ChannelConfig;
    email?: ChannelConfig;
    sms?: ChannelConfig;
    pushover?: PushoverChannelConfig | undefined;
}

export interface ChannelConfig {
    enabled?: boolean;
    minPriority?: AlarmPriority;
}

export interface PushoverChannelConfig extends ChannelConfig {
    userKey?: string | undefined;
    apiToken?: string | undefined;
}

export function isPushoverChannelConfig(object: any): object is PushoverChannelConfig {
    return object && object[''] === 'PushoverChannelConfig';
}

export interface ServicesSettings {
    connectedServices?: ConnectedService[];
    availableServices?: AvailableService[];
    syncSettings?: SyncSettings;
}

export interface ConnectedService {
    id?: string;
    name?: string;
    type?: string;
    description?: string;
    status?: string;
    lastSync?: Date | undefined;
    icon?: string;
    configured?: boolean;
    enabled?: boolean;
}

export interface AvailableService {
    id?: string;
    name?: string;
    type?: string;
    description?: string;
    icon?: string;
}

export interface SyncSettings {
    autoSync?: boolean;
    syncOnAppOpen?: boolean;
    backgroundRefresh?: boolean;
}

/** User preferences response */
export interface UserPreferencesResponse {
    /** User's preferred language code (e.g., "en", "fr", "de") */
    preferredLanguage?: string | undefined;
}

/** Request to update user preferences */
export interface UpdateUserPreferencesRequest {
    /** User's preferred language code (e.g., "en", "fr", "de") */
    preferredLanguage?: string | undefined;
}

export interface V3CollectionResponseOfObject {
    status?: string;
    data?: any[];
    total?: number | undefined;
    skip?: number | undefined;
    limit?: number | undefined;
    meta?: V3ResponseMetadata;
}

export interface V3ResponseMetadata {
    timestamp?: Date;
    version?: string;
    executionTime?: number | undefined;
    requestId?: string | undefined;
    eTag?: string | undefined;
    lastModified?: Date | undefined;
    totalCount?: number;
    limit?: number;
    offset?: number;
}

export interface V3ErrorResponse {
    status?: string;
    message?: string;
    code?: string | undefined;
    timestamp?: Date | undefined;
    path?: string | undefined;
    details?: { [key: string]: any; } | undefined;
}

export interface DeviceStatus extends ProcessableDocumentBase {
    _id?: string | undefined;
    mills?: number;
    created_at?: string | undefined;
    utcOffset?: number | undefined;
    uploaderBattery?: number | undefined;
    device?: string;
    isCharging?: boolean | undefined;
    uploader?: UploaderStatus | undefined;
    pump?: PumpStatus | undefined;
    openaps?: OpenApsStatus | undefined;
    loop?: LoopStatus | undefined;
    xdripjs?: XDripJsStatus | undefined;
    radioAdapter?: RadioAdapterStatus | undefined;
    connect?: any | undefined;
    override?: OverrideStatus | undefined;
    cgm?: CgmStatus | undefined;
    meter?: MeterStatus | undefined;
    insulinPen?: InsulinPenStatus | undefined;
    mmtune?: OpenApsMmTune | undefined;
}

export function isDeviceStatus(object: any): object is DeviceStatus {
    return object && object[''] === 'DeviceStatus';
}

export interface UploaderStatus {
    battery?: number | undefined;
    batteryVoltage?: number | undefined;
    temperature?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
}

export interface PumpStatus {
    battery?: PumpBattery | undefined;
    reservoir?: number | undefined;
    clock?: string | undefined;
    status?: PumpStatusDetails | undefined;
    iob?: PumpIob | undefined;
    reservoir_display_override?: string | undefined;
    reservoir_level_override?: PumpAlertLevel | undefined;
    manufacturer?: string | undefined;
    model?: string | undefined;
    extended?: { [key: string]: any; } | undefined;
}

export interface PumpBattery {
    percent?: number | undefined;
    voltage?: number | undefined;
}

export interface PumpStatusDetails {
    status?: string | undefined;
    bolusing?: boolean | undefined;
    suspended?: boolean | undefined;
}

export interface PumpIob {
    timestamp?: string | undefined;
    bolusiob?: number | undefined;
    basaliob?: number | undefined;
    iob?: number | undefined;
}

export enum PumpAlertLevel {
    None = 0,
    Info = 1,
    Warn = 2,
    Urgent = 3,
}

export interface OpenApsStatus {
    suggested?: any | undefined;
    enacted?: any | undefined;
    iob?: any | undefined;
    cob?: number | undefined;
}

export interface LoopStatus {
    iob?: LoopIob | undefined;
    cob?: LoopCob | undefined;
    predicted?: LoopPredicted | undefined;
    recommendedBolus?: number | undefined;
    name?: string | undefined;
    version?: string | undefined;
    timestamp?: string | undefined;
    recommended?: any | undefined;
    enacted?: LoopEnacted | undefined;
    recommendedTempBasal?: LoopRecommendedTempBasal | undefined;
    failureReason?: string | undefined;
    rileylinks?: RileyLinkStatus[] | undefined;
    automaticDoseRecommendation?: LoopAutomaticDoseRecommendation | undefined;
    currentCorrectionRange?: CorrectionRange | undefined;
    forecastError?: any | undefined;
}

export interface LoopIob {
    timestamp?: string | undefined;
    iob?: number | undefined;
    basaliob?: number | undefined;
    netbasalinsulin?: number | undefined;
}

export interface LoopCob {
    timestamp?: string | undefined;
    cob?: number | undefined;
}

export interface LoopPredicted {
    values?: number[] | undefined;
    startDate?: string | undefined;
}

export interface LoopEnacted {
    bolusVolume?: number | undefined;
    rate?: number | undefined;
    duration?: number | undefined;
    timestamp?: string | undefined;
    reason?: string | undefined;
    received?: boolean | undefined;
}

export interface LoopRecommendedTempBasal {
    rate?: number | undefined;
    duration?: number | undefined;
    timestamp?: string | undefined;
}

export interface RileyLinkStatus {
    name?: string | undefined;
    signal?: number | undefined;
    timestamp?: string | undefined;
    radioFirmware?: string | undefined;
    bleFirmware?: string | undefined;
    connected?: boolean | undefined;
}

export interface LoopAutomaticDoseRecommendation {
    bolus?: number | undefined;
    tempBasal?: LoopRecommendedTempBasal | undefined;
    timestamp?: string | undefined;
    notice?: string | undefined;
}

export interface CorrectionRange {
    maxValue?: number | undefined;
    minValue?: number | undefined;
}

export interface XDripJsStatus {
    state?: number | undefined;
    stateString?: string | undefined;
    voltagea?: number | undefined;
    voltageb?: number | undefined;
}

export interface RadioAdapterStatus {
    pumpRSSI?: number | undefined;
    RSSI?: number | undefined;
}

export interface OverrideStatus {
    name?: string | undefined;
    timestamp?: string | undefined;
    duration?: number | undefined;
    active?: boolean | undefined;
    multiplier?: number | undefined;
    currentCorrectionRange?: CorrectionRange | undefined;
}

export interface CgmStatus {
    sensorAge?: string | undefined;
    transmitterAge?: string | undefined;
    signalStrength?: number | undefined;
    calibrationStatus?: string | undefined;
    lastReading?: Date | undefined;
    sensorState?: string | undefined;
    sessionTimeRemaining?: number | undefined;
    transmitterBattery?: number | undefined;
}

export interface MeterStatus {
    batteryLevel?: number | undefined;
    testStripsRemaining?: number | undefined;
    lastReading?: Date | undefined;
    clockStatus?: string | undefined;
    meterModel?: string | undefined;
    memoryUsage?: number | undefined;
}

export interface InsulinPenStatus {
    batteryLevel?: number | undefined;
    cartridgeRemaining?: number | undefined;
    lastInjection?: Date | undefined;
    penModel?: string | undefined;
    insulinType?: string | undefined;
    needleAttached?: boolean | undefined;
    cartridgeExpiration?: Date | undefined;
}

export interface OpenApsMmTune {
    scanDetails?: any[][] | undefined;
    setFreq?: number | undefined;
    timestamp?: string | undefined;
    usedDefault?: boolean | undefined;
    moment?: Date | undefined;
}

export interface LastModifiedResponse {
    entries?: Date | undefined;
    treatments?: Date | undefined;
    profile?: Date | undefined;
    deviceStatus?: Date | undefined;
    food?: Date | undefined;
    settings?: Date | undefined;
    activity?: Date | undefined;
    serverTime?: Date;
    additional?: { [key: string]: Date; };
}

export interface Profile {
    _id?: string | undefined;
    defaultProfile?: string;
    startDate?: string;
    mills?: number;
    created_at?: string | undefined;
    units?: string;
    store?: { [key: string]: ProfileData; };
    enteredBy?: string | undefined;
    loopSettings?: LoopProfileSettings | undefined;
    isExternallyManaged?: boolean;
}

export interface ProfileData {
    dia?: number;
    carbs_hr?: number;
    delay?: number;
    timezone?: string | undefined;
    units?: string | undefined;
    perGIvalues?: boolean | undefined;
    carbs_hr_high?: number | undefined;
    carbs_hr_medium?: number | undefined;
    carbs_hr_low?: number | undefined;
    delay_high?: number | undefined;
    delay_medium?: number | undefined;
    delay_low?: number | undefined;
    basal?: TimeValue[];
    carbratio?: TimeValue[];
    sens?: TimeValue[];
    target_low?: TimeValue[];
    target_high?: TimeValue[];
}

export interface TimeValue {
    time?: string;
    value?: number;
    timeAsSeconds?: number | undefined;
}

export interface LoopProfileSettings {
    deviceToken?: string | undefined;
    bundleIdentifier?: string | undefined;
    overridePresets?: LoopOverridePreset[] | undefined;
    dosingEnabled?: boolean | undefined;
    minimumBGGuard?: number | undefined;
    preMealTargetRange?: LoopTargetRange | undefined;
    workoutTargetRange?: LoopTargetRange | undefined;
    maximumBolus?: number | undefined;
    maximumBasalRatePerHour?: number | undefined;
    dosingStrategy?: string | undefined;
    scheduleOverride?: LoopOverridePreset | undefined;
}

export interface LoopOverridePreset {
    name?: string | undefined;
    symbol?: string | undefined;
    duration?: number | undefined;
    targetRange?: LoopTargetRange | undefined;
    insulinNeedsScaleFactor?: number | undefined;
}

export interface LoopTargetRange {
    minValue?: number | undefined;
    maxValue?: number | undefined;
}

export interface Settings extends ProcessableDocumentBase {
    _id?: string | undefined;
    key: string;
    value?: any | undefined;
    created_at?: string | undefined;
    mills?: number;
    utcOffset?: number | undefined;
    srvCreated?: Date | undefined;
    srvModified?: Date | undefined;
    app?: string | undefined;
    device?: string | undefined;
    enteredBy?: string | undefined;
    version?: number | undefined;
    isActive?: boolean;
    notes?: string | undefined;
}

export function isSettings(object: any): object is Settings {
    return object && object[''] === 'Settings';
}

export interface V3StatusResponse {
    status?: string;
    name?: string;
    version?: string;
    serverTime?: Date;
    apiEnabled?: boolean;
    careportalEnabled?: boolean;
    head?: string;
    settings?: { [key: string]: any; };
    extended?: ExtendedStatusInfo;
}

export interface ExtendedStatusInfo {
    authorization?: AuthorizationInfo;
    permissions?: { [key: string]: boolean; };
    uptimeMs?: number;
    collections?: string[];
    apiVersions?: { [key: string]: boolean; };
}

export interface AuthorizationInfo {
    isAuthorized?: boolean;
    scope?: string[];
    subject?: string | undefined;
    roles?: string[];
}

export interface VersionResponse {
    version?: string;
    name?: string;
    serverTime?: Date;
    head?: string;
    build?: string;
    apiCompatibility?: string;
}

export interface DDataResponse {
    devicestatus?: DeviceStatus[];
    sgvs?: Entry[];
    cals?: Entry[];
    profiles?: Profile[];
    mbgs?: Entry[];
    food?: Food[];
    treatments?: Treatment[];
    dbstats?: DbStats;
}

export interface DbStats {
    dataSize?: number;
    collections?: number;
    indexes?: number;
}

export interface DData {
    sgvs?: Entry[];
    treatments?: Treatment[];
    mbgs?: Entry[];
    cals?: Entry[];
    cal?: Entry | undefined;
    profiles?: Profile[];
    devicestatus?: DeviceStatus[];
    food?: Food[];
    activity?: Activity[];
    dbstats?: DbStats;
    lastUpdated?: number;
    inRetroMode?: boolean | undefined;
    sitechangeTreatments?: Treatment[];
    insulinchangeTreatments?: Treatment[];
    batteryTreatments?: Treatment[];
    sensorTreatments?: Treatment[];
    combobolusTreatments?: Treatment[];
    profileTreatments?: Treatment[];
    tempbasalTreatments?: Treatment[];
    tempTargetTreatments?: Treatment[];
}

export interface Activity extends ProcessableDocumentBase {
    _id?: string | undefined;
    created_at?: string | undefined;
    timestamp?: number | undefined;
    mills?: number;
    utcOffset?: number | undefined;
    type?: string | undefined;
    description?: string | undefined;
    duration?: number | undefined;
    intensity?: string | undefined;
    notes?: string | undefined;
    enteredBy?: string | undefined;
    dateString?: string | undefined;
    distance?: number | undefined;
    distanceUnits?: string | undefined;
    energy?: number | undefined;
    energyUnits?: string | undefined;
    name?: string | undefined;

    [key: string]: any;
}

export function isActivity(object: any): object is Activity {
    return object && object[''] === 'Activity';
}

export interface LoopNotificationResponse {
    success?: boolean;
    message?: string;
    timestamp?: number;
    data?: any | undefined;
}

/** Loop notification request model for the direct Loop endpoint Combines the data and loopSettings for a complete notification request */
export interface LoopSendRequest {
    /** Loop notification data (matches legacy data structure) */
    data?: LoopNotificationData;
    /** Loop settings from user profile containing device token and bundle ID */
    loopSettings?: LoopSettings2;
}

export interface LoopNotificationData {
    eventType?: string;
    notes?: string | undefined;
    enteredBy?: string | undefined;
    reason?: string | undefined;
    reasonDisplay?: string | undefined;
    duration?: string | undefined;
    remoteCarbs?: string | undefined;
    remoteAbsorption?: string | undefined;
    remoteBolus?: string | undefined;
    otp?: string | undefined;
    created_at?: string | undefined;
}

export interface LoopSettings2 {
    deviceToken?: string | undefined;
    bundleIdentifier?: string | undefined;
}

export interface NotificationV2Response {
    success?: boolean;
    message?: string;
    data?: any | undefined;
    timestamp?: number;
}

export interface LoopNotificationRequest {
    type?: string;
    message?: string;
    title?: string | undefined;
    urgency?: string | undefined;
    sound?: string | undefined;
    group?: string | undefined;
    timestamp?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    isAnnouncement?: boolean | undefined;
}

export interface NotificationBase {
    level?: number;
    title?: string;
    message?: string;
    group?: string;
    timestamp?: number;
    plugin?: string | undefined;
    isAnnouncement?: boolean;
    debug?: any | undefined;
    count?: number;
    lastRecorded?: number;
    persistent?: boolean;
    clear?: boolean;
}

export interface SummaryResponse {
    sgvs?: SummarySgv[];
    treatments?: SummaryTreatments;
    profile?: any | undefined;
    state?: SummaryState;
}

export interface SummarySgv {
    sgv?: number;
    mills?: number;
    noise?: number | undefined;
}

export interface SummaryTreatments {
    tempBasals?: SummaryTempBasal[];
    treatments?: SummaryTreatment[];
    targets?: SummaryTarget[];
}

export interface SummaryTempBasal {
    start?: number;
    duration?: number;
    absolute?: number;
    profile?: number | undefined;
}

export interface SummaryTreatment {
    mills?: number;
    carbs?: number | undefined;
    insulin?: number | undefined;
}

export interface SummaryTarget {
    targetTop?: number;
    targetBottom?: number;
    duration?: number;
    mills?: number;
}

export interface SummaryState {
    iob?: number;
    cob?: number;
    bwp?: number;
    cage?: number | undefined;
    sage?: number | undefined;
    iage?: number | undefined;
    bage?: number | undefined;
    battery?: number | undefined;
    calib_age?: number | undefined;
    sensor_expires_in?: number | undefined;
}

export interface AlexaResponse {
    version?: string;
    sessionAttributes?: { [key: string]: any; };
    response?: AlexaResponseBody;
}

export interface AlexaResponseBody {
    outputSpeech?: AlexaOutputSpeech | undefined;
    shouldEndSession?: boolean;
    card?: AlexaCard | undefined;
    reprompt?: AlexaReprompt | undefined;
}

export interface AlexaOutputSpeech {
    type?: string;
    text?: string;
    ssml?: string | undefined;
}

export interface AlexaCard {
    type?: string;
    title?: string;
    content?: string;
    text?: string | undefined;
    smallImageUrl?: string | undefined;
    largeImageUrl?: string | undefined;
}

export interface AlexaReprompt {
    outputSpeech?: AlexaOutputSpeech | undefined;
}

export interface AlexaRequest {
    version?: string;
    session?: AlexaSession;
    request?: AlexaRequestDetails;
}

export interface AlexaSession {
    sessionId?: string;
    new?: boolean;
    attributes?: { [key: string]: any; };
    user?: AlexaUser;
}

export interface AlexaUser {
    userId?: string;
}

export interface AlexaRequestDetails {
    type?: string;
    requestId?: string;
    timestamp?: Date;
    intent?: AlexaIntent | undefined;
    locale?: string;
}

export interface AlexaIntent {
    name?: string;
    slots?: { [key: string]: AlexaSlot; };
}

export interface AlexaSlot {
    name?: string;
    value?: string;
}

/** Response object for count endpoints */
export interface CountResponse {
    /** Number of records matching the query criteria */
    count?: number;
}

export interface AsyncProcessingResponse {
    correlationId?: string;
    status?: string;
    statusUrl?: string;
    estimatedProcessingTime?: string;
    estimatedCompletion?: Date | undefined;
}

export interface IobResult {
    iob?: number;
    activity?: number | undefined;
    lastBolus?: Treatment | undefined;
    source?: string | undefined;
    device?: string | undefined;
    mills?: number | undefined;
    basalIob?: number | undefined;
    treatmentIob?: number | undefined;
    display?: string | undefined;
    displayLine?: string | undefined;
}

/** Response model for hourly IOB breakdown */
export interface HourlyIobResponse {
    startTime?: number;
    endTime?: number;
    intervalMinutes?: number;
    hours?: number;
    data?: HourlyIobData[];
}

/** Individual hourly IOB data point */
export interface HourlyIobData {
    timeSlot?: number;
    hour?: number;
    minute?: number;
    timeLabel?: string;
    totalIOB?: number;
    bolusIOB?: number;
    basalIOB?: number;
}

export interface NotificationAckResponse {
    success?: boolean;
    message?: string;
    timestamp?: number;
}

export interface NotificationAckRequest {
    level?: number;
    group?: string;
    time?: number | undefined;
    sendClear?: boolean | undefined;
}

export interface PushoverCallbackRequest {
    receipt?: string | undefined;
    status?: number | undefined;
    acknowledged_at?: number | undefined;
    acknowledged_by?: string | undefined;
    user_key?: string | undefined;
    callback?: string | undefined;
}

export interface AdminNotifiesResponse {
    status?: number;
    message?: AdminNotifiesMessage;
}

export interface AdminNotifiesMessage {
    notifies?: AdminNotification[];
    notifyCount?: number;
}

export interface AdminNotification {
    title?: string;
    message?: string;
    count?: number;
    lastRecorded?: number;
    persistent?: boolean;
}

export interface PushoverNotificationRequest {
    title?: string;
    message?: string;
    level?: number | undefined;
    group?: string | undefined;
    priority?: number | undefined;
    sound?: string | undefined;
    device?: string | undefined;
    url?: string | undefined;
    urlTitle?: string | undefined;
    retry?: number | undefined;
    expire?: number | undefined;
}

export interface TimeQueryEcho {
    req?: TimeQueryRequest;
    pattern?: string[];
    query?: { [key: string]: any; };
}

export interface TimeQueryRequest {
    params?: { [key: string]: string; };
    query?: { [key: string]: any; };
}

export interface ConnectorConfigurationResponse {
    connectorName?: string;
    configuration?: JsonDocument;
    schemaVersion?: number;
    isActive?: boolean;
    lastModified?: Date;
    modifiedBy?: string | undefined;
}

export interface JsonDocument {
    isDisposable?: boolean;
    rootElement?: any;
}

export interface ConnectorStatusInfo {
    connectorName?: string;
    isEnabled?: boolean;
    hasDatabaseConfig?: boolean;
    hasSecrets?: boolean;
    lastModified?: Date | undefined;
}

export interface SetActiveRequest {
    isActive?: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}