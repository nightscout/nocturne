// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error, redirect } from '@sveltejs/kit';
import { z } from 'zod';
import { JsonDocumentSchema, SetActiveRequestSchema } from '$lib/api/generated/schemas';
import { type JsonDocument, type SetActiveRequest } from '$api';

/** Gets the configuration for a specific connector.
Returns runtime configuration only (secrets are not included). */
export const getConfiguration = query(z.string(), async (connectorName) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.configuration.getConfiguration(connectorName);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.getConfiguration:', err);
    throw error(500, 'Failed to get configuration');
  }
});

/** Saves or updates runtime configuration for a connector.
Only properties marked with [RuntimeConfigurable] are accepted.
Validates the configuration against the connector's schema before saving. */
export const saveConfiguration = command(z.object({ connectorName: z.string(), request: JsonDocumentSchema }), async ({ connectorName, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.configuration.saveConfiguration(connectorName, request as JsonDocument);
    await Promise.all([
      getConfiguration(connectorName).refresh(),
      getAllConnectorStatus(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.saveConfiguration:', err);
    throw error(500, 'Failed to save configuration');
  }
});

/** Deletes all configuration and secrets for a connector. */
export const deleteConfiguration = command(z.string(), async (connectorName) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.configuration.deleteConfiguration(connectorName);
    await Promise.all([
      getConfiguration(connectorName).refresh(),
      getAllConnectorStatus(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.deleteConfiguration:', err);
    throw error(500, 'Failed to delete configuration');
  }
});

/** Gets the JSON Schema for a connector's configuration.
Schema is generated from the connector's configuration class attributes.
This endpoint is public since schema is just metadata, not sensitive data. */
export const getSchema = query(z.string(), async (connectorName) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.configuration.getSchema(connectorName);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.getSchema:', err);
    throw error(500, 'Failed to get schema');
  }
});

/** Gets the effective configuration from a running connector.
This returns the actual runtime values including those resolved from environment variables.
This endpoint is public since it only exposes non-secret configuration values. */
export const getEffectiveConfiguration = query(z.string(), async (connectorName) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.configuration.getEffectiveConfiguration(connectorName);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.getEffectiveConfiguration:', err);
    throw error(500, 'Failed to get effective configuration');
  }
});

/** Saves encrypted secrets for a connector.
Secrets are encrypted using AES-256-GCM before storage. */
export const saveSecrets = command(z.object({ connectorName: z.string(), request: z.record(z.string(), z.string()) }), async ({ connectorName, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.configuration.saveSecrets(connectorName, request as { [key: string]: string; });
    await Promise.all([
      getConfiguration(connectorName).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.saveSecrets:', err);
    throw error(500, 'Failed to save secrets');
  }
});

/** Gets status information for all registered connectors. */
export const getAllConnectorStatus = query(async () => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.configuration.getAllConnectorStatus();
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.getAllConnectorStatus:', err);
    throw error(500, 'Failed to get all connector status');
  }
});

/** Enables or disables a connector. */
export const setActive = command(z.object({ connectorName: z.string(), request: SetActiveRequestSchema }), async ({ connectorName, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.configuration.setActive(connectorName, request as SetActiveRequest);
    await Promise.all([
      getAllConnectorStatus(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in configuration.setActive:', err);
    throw error(500, 'Failed to set active');
  }
});
