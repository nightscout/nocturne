// @ts-nocheck
// Auto-generated from OpenAPI spec - DO NOT EDIT
// Generated by: pnpm run generate-zod-schemas
// Source: openapi.json (2026-01-11T04:56:58.190Z)

import { z } from 'zod';

export const PerformanceMetricsSchema = z.object({ "averageResponseTime": z.number().optional(), "totalRequests": z.number().int().optional(), "errorCount": z.number().int().optional(), "memoryUsageMB": z.number().int().optional(), "uptimeHours": z.number().optional(), "topEndpoints": z.record(z.number().int()).optional() }).strict();
export type PerformanceMetrics = z.infer<typeof PerformanceMetricsSchema>;

export const UsageStatisticsSchema = z.object({ "uniqueSessions": z.number().int().optional(), "popularFeatures": z.record(z.number().int()).optional(), "averageSessionDuration": z.number().optional(), "deviceTypes": z.record(z.number().int()).optional() }).strict();
export type UsageStatistics = z.infer<typeof UsageStatisticsSchema>;

export const AnalyticsBatchSchema = z.object({ "installationId": z.string().optional(), "events": z.array(z.any()).optional(), "systemInfo": z.any().nullable().optional(), "batchTimestamp": z.number().int().optional(), "schemaVersion": z.string().optional() }).strict();
export type AnalyticsBatch = z.infer<typeof AnalyticsBatchSchema>;

export const AnalyticsEventSchema = z.object({ "sessionId": z.string().optional(), "eventType": z.string().optional(), "category": z.string().optional(), "action": z.string().optional(), "label": z.string().optional(), "value": z.number().int().nullable().optional(), "timestamp": z.number().int().optional(), "metadata": z.record(z.any()).optional() }).strict();
export type AnalyticsEvent = z.infer<typeof AnalyticsEventSchema>;

export const SystemInfoSchema = z.object({ "platform": z.string().optional(), "runtimeVersion": z.string().optional(), "nocturneVersion": z.string().optional(), "deploymentType": z.string().optional(), "demoModeEnabled": z.boolean().optional(), "enabledConnectors": z.array(z.string()).optional(), "enabledFeatures": z.array(z.string()).optional(), "databaseType": z.string().optional(), "cacheEnabled": z.boolean().optional() }).strict();
export type SystemInfo = z.infer<typeof SystemInfoSchema>;

export const AnalyticsCollectionConfigSchema = z.object({ "collectApiUsage": z.boolean().optional(), "collectUiUsage": z.boolean().optional(), "collectPerformanceMetrics": z.boolean().optional(), "collectHealthMetrics": z.boolean().optional(), "collectFeatureUsage": z.boolean().optional(), "excludedEndpoints": z.array(z.string()).optional(), "maxLocalEvents": z.number().int().optional() }).strict();
export type AnalyticsCollectionConfig = z.infer<typeof AnalyticsCollectionConfigSchema>;

export const VerifyAuthResponseSchema = z.object({ 
/**Authentication message - can be either a string or an object*/
"message": z.any().describe("Authentication message - can be either a string or an object").optional() }).strict().describe("Response for the /api/v1/verifyauth endpoint");
export type VerifyAuthResponse = z.infer<typeof VerifyAuthResponseSchema>;

export const AuthorizationResponseSchema = z.object({ "token": z.string().optional(), "exp": z.number().int().optional(), "sub": z.string().optional(), "iat": z.number().int().optional() }).strict();
export type AuthorizationResponse = z.infer<typeof AuthorizationResponseSchema>;

export const ProblemDetailsSchema = z.object({ "type": z.string().nullable().optional(), "title": z.string().nullable().optional(), "status": z.number().int().nullable().optional(), "detail": z.string().nullable().optional(), "instance": z.string().nullable().optional() }).catchall(z.any().nullable());
export type ProblemDetails = z.infer<typeof ProblemDetailsSchema>;

export const PermissionsResponseSchema = z.object({ "permissions": z.array(z.any()).optional() }).strict();
export type PermissionsResponse = z.infer<typeof PermissionsResponseSchema>;

export const PermissionSchema = z.object({ "name": z.string().optional(), "count": z.number().int().optional(), "firstSeen": z.string().datetime({ offset: true }).optional(), "lastSeen": z.string().datetime({ offset: true }).optional() }).strict();
export type Permission = z.infer<typeof PermissionSchema>;

export const PermissionTrieResponseSchema = z.object({ "root": z.any().optional(), "count": z.number().int().optional() }).strict();
export type PermissionTrieResponse = z.infer<typeof PermissionTrieResponseSchema>;

export const PermissionTrieNodeSchema = z.object({ "name": z.string().optional(), "isLeaf": z.boolean().optional(), "children": z.record(z.any()).optional() }).strict();
export type PermissionTrieNode = z.infer<typeof PermissionTrieNodeSchema>;

export const SubjectSchema = z.object({ "id": z.string().nullable().optional(), "_id": z.string().nullable().optional(), "name": z.string().min(1), "roles": z.array(z.string()).optional(), "accessToken": z.string().optional(), "notes": z.string().nullable().optional(), "created": z.string().datetime({ offset: true }).optional(), "modified": z.string().datetime({ offset: true }).optional() }).strict();
export type Subject = z.infer<typeof SubjectSchema>;

export const RoleSchema = z.object({ "id": z.string().nullable().optional(), "_id": z.string().nullable().optional(), "name": z.string().min(1), "permissions": z.array(z.string()).optional(), "notes": z.string().nullable().optional(), "autoGenerated": z.boolean().optional(), "created": z.string().datetime({ offset: true }).optional(), "modified": z.string().datetime({ offset: true }).optional() }).strict();
export type Role = z.infer<typeof RoleSchema>;

export const ConnectorStatusDtoSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "status": z.string().optional(), "description": z.string().nullable().optional(), "totalEntries": z.number().int().optional(), "lastEntryTime": z.string().datetime({ offset: true }).nullable().optional(), "entriesLast24Hours": z.number().int().optional(), "state": z.string().optional(), "stateMessage": z.string().nullable().optional(), "isHealthy": z.boolean().optional(), 
/**
* Breakdown of total items processed by data type
* Keys are data type names (e.g., "Glucose", "Treatments", "Food")
*/
"totalItemsBreakdown": z.record(z.number().int()).nullable().describe("Breakdown of total items processed by data type\nKeys are data type names (e.g., \"Glucose\", \"Treatments\", \"Food\")").optional(), 
/**
* Breakdown of items processed in the last 24 hours by data type
* Keys are data type names (e.g., "Glucose", "Treatments", "Food")
*/
"itemsLast24HoursBreakdown": z.record(z.number().int()).nullable().describe("Breakdown of items processed in the last 24 hours by data type\nKeys are data type names (e.g., \"Glucose\", \"Treatments\", \"Food\")").optional() }).strict();
export type ConnectorStatusDto = z.infer<typeof ConnectorStatusDtoSchema>;

export const LocalAuthConfigResponseSchema = z.object({ "enabled": z.boolean().optional(), "displayName": z.string().optional(), "allowRegistration": z.boolean().optional(), "requireEmailVerification": z.boolean().optional(), "passwordRequirements": z.any().optional() }).strict().describe("Local auth configuration response");
export type LocalAuthConfigResponse = z.infer<typeof LocalAuthConfigResponseSchema>;

export const PasswordRequirementsDtoSchema = z.object({ "minLength": z.number().int().optional(), "requireUppercase": z.boolean().optional(), "requireLowercase": z.boolean().optional(), "requireDigit": z.boolean().optional(), "requireSpecialCharacter": z.boolean().optional() }).strict().describe("Password requirements");
export type PasswordRequirementsDto = z.infer<typeof PasswordRequirementsDtoSchema>;

export const RegisterResponseSchema = z.object({ "success": z.boolean().optional(), "userId": z.string().optional(), "requiresEmailVerification": z.boolean().optional(), "requiresAdminApproval": z.boolean().optional(), "message": z.string().optional() }).strict().describe("Registration response");
export type RegisterResponse = z.infer<typeof RegisterResponseSchema>;

export const ErrorResponseSchema = z.object({ "error": z.string().optional(), "message": z.string().optional(), "details": z.any().nullable().optional() }).strict().describe("Error response");
export type ErrorResponse = z.infer<typeof ErrorResponseSchema>;

export const RegisterRequestSchema = z.object({ "email": z.string().optional(), "password": z.string().optional(), "displayName": z.string().nullable().optional() }).strict().describe("Registration request");
export type RegisterRequest = z.infer<typeof RegisterRequestSchema>;

export const LoginResponseSchema = z.object({ "success": z.boolean().optional(), "accessToken": z.string().optional(), "refreshToken": z.string().optional(), "expiresIn": z.number().int().optional(), "user": z.any().optional(), "requirePasswordChange": z.boolean().optional() }).strict().describe("Login response");
export type LoginResponse = z.infer<typeof LoginResponseSchema>;

export const UserInfoDtoSchema = z.object({ "id": z.string().optional(), "email": z.string().optional(), "displayName": z.string().nullable().optional(), "roles": z.array(z.string()).optional() }).strict().describe("User info");
export type UserInfoDto = z.infer<typeof UserInfoDtoSchema>;

export const LoginRequestSchema = z.object({ "email": z.string().optional(), "password": z.string().optional() }).strict().describe("Login request");
export type LoginRequest = z.infer<typeof LoginRequestSchema>;

export const ForgotPasswordResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional(), "adminNotificationRequired": z.boolean().optional() }).strict().describe("Forgot password response");
export type ForgotPasswordResponse = z.infer<typeof ForgotPasswordResponseSchema>;

export const ForgotPasswordRequestSchema = z.object({ "email": z.string().optional() }).strict().describe("Forgot password request");
export type ForgotPasswordRequest = z.infer<typeof ForgotPasswordRequestSchema>;

export const ResetPasswordResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional() }).strict().describe("Reset password response");
export type ResetPasswordResponse = z.infer<typeof ResetPasswordResponseSchema>;

export const ResetPasswordRequestSchema = z.object({ "token": z.string().optional(), "newPassword": z.string().optional() }).strict().describe("Reset password request");
export type ResetPasswordRequest = z.infer<typeof ResetPasswordRequestSchema>;

export const ChangePasswordResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional() }).strict().describe("Change password response");
export type ChangePasswordResponse = z.infer<typeof ChangePasswordResponseSchema>;

export const ChangePasswordRequestSchema = z.object({ "currentPassword": z.string().optional(), "newPassword": z.string().optional() }).strict().describe("Change password request");
export type ChangePasswordRequest = z.infer<typeof ChangePasswordRequestSchema>;

export const CheckEmailResponseSchema = z.object({ "isValid": z.boolean().optional(), "error": z.string().nullable().optional(), "requiresApproval": z.boolean().optional() }).strict().describe("Check email response");
export type CheckEmailResponse = z.infer<typeof CheckEmailResponseSchema>;

export const ResendVerificationResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional() }).strict().describe("Resend verification response");
export type ResendVerificationResponse = z.infer<typeof ResendVerificationResponseSchema>;

export const ResendVerificationRequestSchema = z.object({ "email": z.string().optional() }).strict().describe("Resend verification request");
export type ResendVerificationRequest = z.infer<typeof ResendVerificationRequestSchema>;

export const PasswordResetRequestListResponseSchema = z.object({ "requests": z.array(z.any()).optional(), "totalCount": z.number().int().optional() }).strict().describe("Response for pending password reset requests");
export type PasswordResetRequestListResponse = z.infer<typeof PasswordResetRequestListResponseSchema>;

export const PasswordResetRequestDtoSchema = z.object({ "id": z.string().optional(), "email": z.string().optional(), "displayName": z.string().nullable().optional(), "requestedFromIp": z.string().nullable().optional(), "userAgent": z.string().nullable().optional(), "createdAt": z.string().datetime({ offset: true }).optional() }).strict().describe("Password reset request info for admin view");
export type PasswordResetRequestDto = z.infer<typeof PasswordResetRequestDtoSchema>;

export const SetTemporaryPasswordResponseSchema = z.object({ "success": z.boolean().optional() }).strict().describe("Response for setting a temporary password");
export type SetTemporaryPasswordResponse = z.infer<typeof SetTemporaryPasswordResponseSchema>;

export const SetTemporaryPasswordRequestSchema = z.object({ "email": z.string().optional(), "temporaryPassword": z.string().optional() }).strict().describe("Request to set a temporary password");
export type SetTemporaryPasswordRequest = z.infer<typeof SetTemporaryPasswordRequestSchema>;

export const HandlePasswordResetResponseSchema = z.object({ "success": z.boolean().optional(), "resetUrl": z.string().optional() }).strict().describe("Response for handling password reset");
export type HandlePasswordResetResponse = z.infer<typeof HandlePasswordResetResponseSchema>;

export const WebSocketEventsMetadataSchema = z.object({ 
/**Array of all available WebSocket event types*/
"availableEvents": z.array(z.any()).describe("Array of all available WebSocket event types").optional(), 
/**Description of the WebSocket events*/
"description": z.string().describe("Description of the WebSocket events").optional() }).strict().describe("Metadata about available WebSocket events");
export type WebSocketEventsMetadata = z.infer<typeof WebSocketEventsMetadataSchema>;

export const WebSocketEventsSchema = z.enum(["connect","disconnect","connect_error","reconnect","reconnect_failed","connect_ack","dataUpdate","treatmentUpdate","create","update","delete","announcement","alarm","urgent_alarm","clear_alarm","notification","statusUpdate","status","authenticate","authenticated","join","leave"]);
export type WebSocketEvents = z.infer<typeof WebSocketEventsSchema>;

export const ExternalUrlsSchema = z.object({ "website": z.string().optional(), "docsBase": z.string().optional(), "connectorDocs": z.any().optional() }).strict();
export type ExternalUrls = z.infer<typeof ExternalUrlsSchema>;

export const ConnectorDocsUrlsSchema = z.object({ "dexcom": z.string().optional(), "libre": z.string().optional(), "careLink": z.string().optional(), "nightscout": z.string().optional(), "glooko": z.string().optional() }).strict();
export type ConnectorDocsUrls = z.infer<typeof ConnectorDocsUrlsSchema>;

export const TreatmentEventTypesMetadataSchema = z.object({ 
/**Array of all available treatment event types*/
"availableTypes": z.array(z.any()).describe("Array of all available treatment event types").optional(), 
/**Full configurations for each event type including field applicability*/
"configurations": z.array(z.any()).describe("Full configurations for each event type including field applicability").optional(), 
/**Description of the treatment event types*/
"description": z.string().describe("Description of the treatment event types").optional() }).strict().describe("Metadata about available treatment event types");
export type TreatmentEventTypesMetadata = z.infer<typeof TreatmentEventTypesMetadataSchema>;

export const TreatmentEventTypeSchema = z.enum(["<none>","BG Check","Snack Bolus","Meal Bolus","Correction Bolus","Carb Correction","Combo Bolus","Announcement","Note","Question","Site Change","Sensor Start","Sensor Change","Sensor Stop","Pump Battery Change","Insulin Change","Temp Basal Start","Temp Basal End","Profile Switch","D.A.D. Alert","Temp Basal","Exercise","OpenAPS Offline","Suspend Pump","Resume Pump","Bolus Wizard","Calibration","Transmitter Sensor Insert","Pod Change"]);
export type TreatmentEventType = z.infer<typeof TreatmentEventTypeSchema>;

export const EventTypeConfigurationSchema = z.object({ "eventType": z.any().optional(), "name": z.string().optional(), "bg": z.boolean().optional(), "insulin": z.boolean().optional(), "carbs": z.boolean().optional(), "protein": z.boolean().optional(), "fat": z.boolean().optional(), "prebolus": z.boolean().optional(), "duration": z.boolean().optional(), "percent": z.boolean().optional(), "absolute": z.boolean().optional(), "profile": z.boolean().optional(), "split": z.boolean().optional(), "sensor": z.boolean().optional() }).strict();
export type EventTypeConfiguration = z.infer<typeof EventTypeConfigurationSchema>;

export const WidgetDefinitionsMetadataSchema = z.object({ 
/**Array of all widget definitions with full metadata*/
"definitions": z.array(z.any()).describe("Array of all widget definitions with full metadata").optional(), 
/**All available placement options*/
"availablePlacements": z.array(z.any()).describe("All available placement options").optional(), 
/**All available size options*/
"availableSizes": z.array(z.any()).describe("All available size options").optional(), 
/**All available UI category options*/
"availableUICategories": z.array(z.any()).describe("All available UI category options").optional(), 
/**Description of the widget definitions*/
"description": z.string().describe("Description of the widget definitions").optional() }).strict().describe("Metadata about available widget definitions");
export type WidgetDefinitionsMetadata = z.infer<typeof WidgetDefinitionsMetadataSchema>;

export const WidgetDefinitionSchema = z.object({ "id": z.any().optional(), "name": z.string().optional(), "description": z.string().optional(), "defaultEnabled": z.boolean().optional(), "icon": z.string().optional(), "uiCategory": z.any().optional(), "placement": z.any().optional() }).strict();
export type WidgetDefinition = z.infer<typeof WidgetDefinitionSchema>;

export const WidgetIdSchema = z.enum(["BgDelta","LastUpdated","ConnectionStatus","Meals","Trackers","TirChart","DailySummary","GlucoseChart","Statistics","Treatments","Predictions","DailyStats","Agp","BatteryStatus"]);
export type WidgetId = z.infer<typeof WidgetIdSchema>;

export const WidgetUICategorySchema = z.enum(["Glucose","Meals","Device","Status"]);
export type WidgetUICategory = z.infer<typeof WidgetUICategorySchema>;

export const WidgetPlacementSchema = z.enum(["Top","Main"]);
export type WidgetPlacement = z.infer<typeof WidgetPlacementSchema>;

export const WidgetSizeSchema = z.enum(["Small","Medium","Large"]);
export type WidgetSize = z.infer<typeof WidgetSizeSchema>;

export const OidcProviderInfoSchema = z.object({ 
/**Provider ID*/
"id": z.string().describe("Provider ID").optional(), 
/**Display name*/
"name": z.string().describe("Display name").optional(), 
/**Icon URL or CSS class*/
"icon": z.string().nullable().describe("Icon URL or CSS class").optional(), 
/**Button color for UI*/
"buttonColor": z.string().nullable().describe("Button color for UI").optional() }).strict().describe("OIDC provider info for login page");
export type OidcProviderInfo = z.infer<typeof OidcProviderInfoSchema>;

export const OidcTokenResponseSchema = z.object({ "accessToken": z.string().optional(), "refreshToken": z.string().optional(), "tokenType": z.string().optional(), "expiresIn": z.number().int().optional(), "expiresAt": z.string().datetime({ offset: true }).optional(), "subjectId": z.string().optional() }).strict();
export type OidcTokenResponse = z.infer<typeof OidcTokenResponseSchema>;

export const LogoutResponseSchema = z.object({ 
/**Whether logout was successful*/
"success": z.boolean().describe("Whether logout was successful").optional(), 
/**URL for provider logout (if RP-initiated logout is supported)*/
"providerLogoutUrl": z.string().nullable().describe("URL for provider logout (if RP-initiated logout is supported)").optional(), 
/**Message*/
"message": z.string().nullable().describe("Message").optional() }).strict().describe("Logout response");
export type LogoutResponse = z.infer<typeof LogoutResponseSchema>;

export const OidcUserInfoSchema = z.object({ "subjectId": z.string().optional(), "name": z.string().optional(), "email": z.string().nullable().optional(), "emailVerified": z.boolean().nullable().optional(), "picture": z.string().nullable().optional(), "roles": z.array(z.string()).optional(), "permissions": z.array(z.string()).optional(), "providerName": z.string().nullable().optional(), "lastLoginAt": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type OidcUserInfo = z.infer<typeof OidcUserInfoSchema>;

export const SessionInfoSchema = z.object({ 
/**Whether the user is authenticated*/
"isAuthenticated": z.boolean().describe("Whether the user is authenticated").optional(), 
/**Subject ID*/
"subjectId": z.string().nullable().describe("Subject ID").optional(), 
/**User name*/
"name": z.string().nullable().describe("User name").optional(), 
/**Email address*/
"email": z.string().nullable().describe("Email address").optional(), 
/**Assigned roles*/
"roles": z.array(z.string()).nullable().describe("Assigned roles").optional(), 
/**Resolved permissions*/
"permissions": z.array(z.string()).nullable().describe("Resolved permissions").optional(), 
/**Session expiration time*/
"expiresAt": z.string().datetime({ offset: true }).nullable().describe("Session expiration time").optional() }).strict().describe("Current session information");
export type SessionInfo = z.infer<typeof SessionInfoSchema>;

export const PebbleResponseSchema = z.object({ 
/**Status array containing current timestamp*/
"status": z.array(z.any()).describe("Status array containing current timestamp").optional(), 
/**Blood glucose readings array*/
"bgs": z.array(z.any()).describe("Blood glucose readings array").optional(), 
/**Calibration readings array*/
"cals": z.array(z.any()).describe("Calibration readings array").optional() }).strict().describe("Pebble response model for 1:1 Nightscout compatibility");
export type PebbleResponse = z.infer<typeof PebbleResponseSchema>;

export const PebbleStatusSchema = z.object({ 
/**Current timestamp in milliseconds since epoch*/
"now": z.number().int().describe("Current timestamp in milliseconds since epoch").optional() }).strict().describe("Pebble status entry");
export type PebbleStatus = z.infer<typeof PebbleStatusSchema>;

export const PebbleBgSchema = z.object({ 
/**Sensor glucose value (formatted as string for legacy compatibility)*/
"sgv": z.string().describe("Sensor glucose value (formatted as string for legacy compatibility)").optional(), 
/**Numeric trend indicator (1-9)*/
"trend": z.number().int().describe("Numeric trend indicator (1-9)").optional(), 
/**Direction string (Flat, SingleUp, etc.)*/
"direction": z.string().describe("Direction string (Flat, SingleUp, etc.)").optional(), 
/**Timestamp in milliseconds since epoch*/
"datetime": z.number().int().describe("Timestamp in milliseconds since epoch").optional(), 
/**Delta from previous reading (formatted string)*/
"bgdelta": z.string().nullable().describe("Delta from previous reading (formatted string)").optional(), 
/**Battery percentage (formatted string)*/
"battery": z.string().nullable().describe("Battery percentage (formatted string)").optional(), 
/**Insulin on board (formatted string)*/
"iob": z.string().nullable().describe("Insulin on board (formatted string)").optional(), 
/**Bolus wizard preview (formatted string)*/
"bwp": z.string().nullable().describe("Bolus wizard preview (formatted string)").optional(), 
/**Bolus wizard preview outcome*/
"bwpo": z.number().nullable().describe("Bolus wizard preview outcome").optional(), 
/**Carbs on board*/
"cob": z.number().nullable().describe("Carbs on board").optional() }).strict().describe("Pebble blood glucose entry");
export type PebbleBg = z.infer<typeof PebbleBgSchema>;

export const PebbleCalSchema = z.object({ 
/**Calibration slope*/
"slope": z.number().nullable().describe("Calibration slope").optional(), 
/**Calibration intercept*/
"intercept": z.number().nullable().describe("Calibration intercept").optional(), 
/**Calibration scale*/
"scale": z.number().nullable().describe("Calibration scale").optional() }).strict().describe("Pebble calibration entry");
export type PebbleCal = z.infer<typeof PebbleCalSchema>;

export const BasicGlucoseStatsSchema = z.object({ "count": z.number().int().optional(), "mean": z.number().optional(), "median": z.number().optional(), "min": z.number().optional(), "max": z.number().optional(), "standardDeviation": z.number().optional(), "percentiles": z.any().optional() }).strict();
export type BasicGlucoseStats = z.infer<typeof BasicGlucoseStatsSchema>;

export const GlucosePercentilesSchema = z.object({ "p5": z.number().optional(), "p10": z.number().optional(), "p25": z.number().optional(), "p50": z.number().optional(), "p75": z.number().optional(), "p90": z.number().optional(), "p95": z.number().optional() }).strict();
export type GlucosePercentiles = z.infer<typeof GlucosePercentilesSchema>;

export const GlycemicVariabilitySchema = z.object({ "coefficientOfVariation": z.number().optional(), "standardDeviation": z.number().optional(), "meanAmplitudeGlycemicExcursions": z.number().optional(), "continuousOverlappingNetGlycemicAction": z.number().optional(), "averageDailyRiskRange": z.number().optional(), "labilityIndex": z.number().optional(), "jIndex": z.number().optional(), "highBloodGlucoseIndex": z.number().optional(), "lowBloodGlucoseIndex": z.number().optional(), "glycemicVariabilityIndex": z.number().optional(), "patientGlycemicStatus": z.number().optional(), "estimatedA1c": z.number().optional(), "meanTotalDailyChange": z.number().optional(), "timeInFluctuation": z.number().optional() }).strict();
export type GlycemicVariability = z.infer<typeof GlycemicVariabilitySchema>;

export const GlycemicVariabilityRequestSchema = z.object({ 
/**Collection of glucose values in mg/dL*/
"values": z.array(z.number()).describe("Collection of glucose values in mg/dL").optional(), 
/**Collection of glucose entries with timestamps*/
"entries": z.array(z.any()).describe("Collection of glucose entries with timestamps").optional() }).strict().describe("Request model for glycemic variability calculation");
export type GlycemicVariabilityRequest = z.infer<typeof GlycemicVariabilityRequestSchema>;

export const EntrySchema = z.intersection(z.any(), z.object({ "_id": z.string().nullable().optional(), "mills": z.number().int().optional(), "dateString": z.string().nullable().optional(), "mgdl": z.number().optional(), "mbg": z.number().nullable().optional(), "mmol": z.number().nullable().optional(), "sgv": z.number().nullable().optional(), "direction": z.string().nullable().optional(), "trend": z.number().int().nullable().optional(), "trendRate": z.number().nullable().optional(), "isCalibration": z.boolean().optional(), "type": z.string().optional(), "device": z.string().nullable().optional(), "notes": z.string().nullable().optional(), "delta": z.number().nullable().optional(), "scaled": z.any().nullable().optional(), "sysTime": z.string().nullable().optional(), "utcOffset": z.number().int().nullable().optional(), "noise": z.number().int().nullable().optional(), "filtered": z.number().nullable().optional(), "unfiltered": z.number().nullable().optional(), "rssi": z.number().int().nullable().optional(), "slope": z.number().nullable().optional(), "intercept": z.number().nullable().optional(), "scale": z.number().nullable().optional(), "created_at": z.string().nullable().optional(), "modified_at": z.string().datetime({ offset: true }).nullable().optional(), "data_source": z.string().nullable().optional(), "meta": z.record(z.any()).nullable().optional() }).strict());
export type Entry = z.infer<typeof EntrySchema>;

export const ProcessableDocumentBaseSchema = z.object({ "id": z.string().nullable().optional(), "createdAt": z.string().nullable().optional(), "mills": z.number().int().optional(), "utcOffset": z.number().int().nullable().optional() }).strict();
export type ProcessableDocumentBase = z.infer<typeof ProcessableDocumentBaseSchema>;

export const TimeInRangeMetricsSchema = z.object({ "percentages": z.any().optional(), "durations": z.any().optional(), "episodes": z.any().optional(), "rangeStats": z.any().optional() }).strict();
export type TimeInRangeMetrics = z.infer<typeof TimeInRangeMetricsSchema>;

export const TimeInRangePercentagesSchema = z.object({ "severeLow": z.number().optional(), "low": z.number().optional(), "target": z.number().optional(), "tightTarget": z.number().optional(), "high": z.number().optional(), "severeHigh": z.number().optional() }).strict();
export type TimeInRangePercentages = z.infer<typeof TimeInRangePercentagesSchema>;

export const TimeInRangeDurationsSchema = z.object({ "severeLow": z.number().optional(), "low": z.number().optional(), "target": z.number().optional(), "tightTarget": z.number().optional(), "high": z.number().optional(), "severeHigh": z.number().optional() }).strict();
export type TimeInRangeDurations = z.infer<typeof TimeInRangeDurationsSchema>;

export const TimeInRangeEpisodesSchema = z.object({ "severeLow": z.number().int().optional(), "low": z.number().int().optional(), "high": z.number().int().optional(), "severeHigh": z.number().int().optional() }).strict();
export type TimeInRangeEpisodes = z.infer<typeof TimeInRangeEpisodesSchema>;

export const TimeInRangeDetailedStatsSchema = z.object({ "low": z.any().optional(), "target": z.any().optional(), "high": z.any().optional() }).strict();
export type TimeInRangeDetailedStats = z.infer<typeof TimeInRangeDetailedStatsSchema>;

export const PeriodMetricsSchema = z.object({ "periodName": z.string().optional(), "startHour": z.number().int().optional(), "endHour": z.number().int().optional(), "readingCount": z.number().int().optional(), "mean": z.number().optional(), "median": z.number().optional(), "standardDeviation": z.number().optional(), "coefficientOfVariation": z.number().optional(), "timeInRange": z.number().optional(), "timeBelowRange": z.number().optional(), "timeVeryLow": z.number().optional(), "timeAboveRange": z.number().optional(), "timeVeryHigh": z.number().optional(), "hypoglycemiaEvents": z.number().int().optional(), "hyperglycemiaEvents": z.number().int().optional(), "min": z.number().optional(), "max": z.number().optional() }).strict();
export type PeriodMetrics = z.infer<typeof PeriodMetricsSchema>;

export const TimeInRangeRequestSchema = z.object({ 
/**Collection of glucose entries*/
"entries": z.array(z.any()).describe("Collection of glucose entries").optional(), 
/**Optional glycemic thresholds*/
"thresholds": z.any().nullable().describe("Optional glycemic thresholds").optional() }).strict().describe("Request model for time in range calculation");
export type TimeInRangeRequest = z.infer<typeof TimeInRangeRequestSchema>;

export const GlycemicThresholdsSchema = z.object({ "severeLow": z.number().optional(), "low": z.number().optional(), "targetBottom": z.number().optional(), "targetTop": z.number().optional(), "tightTargetBottom": z.number().optional(), "tightTargetTop": z.number().optional(), "high": z.number().optional(), "severeHigh": z.number().optional() }).strict();
export type GlycemicThresholds = z.infer<typeof GlycemicThresholdsSchema>;

export const DistributionDataPointSchema = z.object({ "range": z.string().optional(), "count": z.number().int().optional(), "percent": z.number().optional() }).strict();
export type DistributionDataPoint = z.infer<typeof DistributionDataPointSchema>;

export const GlucoseDistributionRequestSchema = z.object({ 
/**Collection of glucose entries*/
"entries": z.array(z.any()).describe("Collection of glucose entries").optional(), 
/**Optional distribution bins*/
"bins": z.array(z.any()).nullable().describe("Optional distribution bins").optional() }).strict().describe("Request model for glucose distribution calculation");
export type GlucoseDistributionRequest = z.infer<typeof GlucoseDistributionRequestSchema>;

export const DistributionBinSchema = z.object({ "range": z.string().optional(), "min": z.number().optional(), "max": z.number().optional() }).strict();
export type DistributionBin = z.infer<typeof DistributionBinSchema>;

export const AveragedStatsSchema = z.intersection(z.any(), z.object({ "hour": z.number().int().optional(), "timeInRange": z.any().optional() }).strict());
export type AveragedStats = z.infer<typeof AveragedStatsSchema>;

export const ExtendedTimeInRangePercentagesSchema = z.object({ "veryLow": z.number().optional(), "low": z.number().optional(), "normal": z.number().optional(), "aboveTarget": z.number().optional(), "high": z.number().optional(), "veryHigh": z.number().optional(), "severeHigh": z.number().optional() }).strict();
export type ExtendedTimeInRangePercentages = z.infer<typeof ExtendedTimeInRangePercentagesSchema>;

export const TreatmentSummarySchema = z.object({ "totals": z.any().optional(), "treatmentCount": z.number().int().optional(), "carbToInsulinRatio": z.number().optional() }).strict();
export type TreatmentSummary = z.infer<typeof TreatmentSummarySchema>;

export const TreatmentTotalsSchema = z.object({ "food": z.any().optional(), "insulin": z.any().optional() }).strict();
export type TreatmentTotals = z.infer<typeof TreatmentTotalsSchema>;

export const FoodTotalsSchema = z.object({ "carbs": z.number().optional(), "protein": z.number().optional(), "fat": z.number().optional() }).strict();
export type FoodTotals = z.infer<typeof FoodTotalsSchema>;

export const InsulinTotalsSchema = z.object({ "bolus": z.number().optional(), "basal": z.number().optional() }).strict();
export type InsulinTotals = z.infer<typeof InsulinTotalsSchema>;

export const TreatmentSchema = z.intersection(z.any(), z.object({ "_id": z.string().nullable().optional(), "eventType": z.string().nullable().optional(), "reason": z.string().nullable().optional(), "glucose": z.number().nullable().optional(), "glucoseType": z.string().nullable().optional(), "carbs": z.number().nullable().optional(), "insulin": z.number().nullable().optional(), "protein": z.number().nullable().optional(), "fat": z.number().nullable().optional(), "foodType": z.string().nullable().optional(), "units": z.string().nullable().optional(), "mills": z.number().int().optional(), "created_at": z.string().nullable().optional(), "duration": z.number().nullable().optional(), "percent": z.number().nullable().optional(), "absolute": z.number().nullable().optional(), "notes": z.string().nullable().optional(), "enteredBy": z.string().nullable().optional(), "targetTop": z.number().nullable().optional(), "targetBottom": z.number().nullable().optional(), "profile": z.string().nullable().optional(), "split": z.string().nullable().optional(), "date": z.number().int().nullable().optional(), "carbTime": z.number().int().nullable().optional(), "boluscalc": z.record(z.any()).nullable().optional(), "utcOffset": z.number().int().nullable().optional(), "timestamp": z.string().nullable().optional(), "cuttedby": z.string().nullable().optional(), "cutting": z.string().nullable().optional(), "eventTime": z.string().nullable().optional(), "preBolus": z.number().nullable().optional(), "rate": z.number().nullable().optional(), "mgdl": z.number().nullable().optional(), "mmol": z.number().nullable().optional(), "endmills": z.number().int().nullable().optional(), "durationType": z.string().nullable().optional(), "isAnnouncement": z.boolean().nullable().optional(), "profileJson": z.string().nullable().optional(), "endprofile": z.string().nullable().optional(), "insulinNeedsScaleFactor": z.number().nullable().optional(), "absorptionTime": z.number().int().nullable().optional(), "enteredinsulin": z.number().nullable().optional(), "splitNow": z.number().nullable().optional(), "splitExt": z.number().nullable().optional(), "status": z.string().nullable().optional(), "relative": z.number().nullable().optional(), "CR": z.number().nullable().optional(), "NSCLIENT_ID": z.string().nullable().optional(), "first": z.boolean().nullable().optional(), "end": z.boolean().nullable().optional(), "CircadianPercentageProfile": z.boolean().nullable().optional(), "percentage": z.number().nullable().optional(), "timeshift": z.number().nullable().optional(), "transmitterId": z.string().nullable().optional(), "remoteCarbs": z.number().nullable().optional(), "remoteAbsorption": z.number().nullable().optional(), "remoteBolus": z.number().nullable().optional(), "reasonDisplay": z.string().nullable().optional(), "otp": z.string().nullable().optional(), "syncIdentifier": z.string().nullable().optional(), "insulinType": z.string().nullable().optional(), "automatic": z.boolean().nullable().optional(), "temp": z.string().nullable().optional(), "amount": z.number().nullable().optional(), "programmed": z.number().nullable().optional(), "unabsorbed": z.number().nullable().optional(), "type": z.string().nullable().optional(), "bolusType": z.string().nullable().optional(), "data_source": z.string().nullable().optional(), "insulinRecommendationForCarbs": z.number().nullable().optional(), "insulinRecommendationForCorrection": z.number().nullable().optional(), "insulinProgrammed": z.number().nullable().optional(), "insulinDelivered": z.number().nullable().optional(), "insulinOnBoard": z.number().nullable().optional(), "bloodGlucoseInput": z.number().nullable().optional(), "bloodGlucoseInputSource": z.string().nullable().optional(), "calculationType": z.any().nullable().optional(), "additional_properties": z.record(z.any()).nullable().optional() }).strict());
export type Treatment = z.infer<typeof TreatmentSchema>;

export const CalculationTypeSchema = z.enum(["Suggested","Manual","Automatic"]);
export type CalculationType = z.infer<typeof CalculationTypeSchema>;

export const OverallAveragesSchema = z.object({ "avgTotalDaily": z.number().optional(), "avgBolus": z.number().optional(), "avgBasal": z.number().optional(), "bolusPercentage": z.number().optional(), "basalPercentage": z.number().optional(), "avgCarbs": z.number().optional(), "avgProtein": z.number().optional(), "avgFat": z.number().optional(), "avgTimeInRange": z.number().optional(), "avgTightTimeInRange": z.number().optional() }).strict();
export type OverallAverages = z.infer<typeof OverallAveragesSchema>;

export const DayDataSchema = z.object({ "date": z.string().optional(), "treatments": z.array(z.any()).optional(), "treatmentSummary": z.any().optional(), "timeInRanges": z.any().optional() }).strict();
export type DayData = z.infer<typeof DayDataSchema>;

export const GlucoseAnalyticsSchema = z.object({ "basicStats": z.any().optional(), "timeInRange": z.any().optional(), "glycemicVariability": z.any().optional(), "dataQuality": z.any().optional(), "time": z.any().optional() }).strict();
export type GlucoseAnalytics = z.infer<typeof GlucoseAnalyticsSchema>;

export const DataQualitySchema = z.object({ "totalReadings": z.number().int().optional(), "missingReadings": z.number().int().optional(), "dataCompleteness": z.number().optional(), "cgmActivePercent": z.number().optional(), "gapAnalysis": z.any().optional(), "noiseLevel": z.number().optional(), "calibrationEvents": z.number().int().optional(), "sensorWarmups": z.number().int().optional() }).strict();
export type DataQuality = z.infer<typeof DataQualitySchema>;

export const GapAnalysisSchema = z.object({ "gaps": z.array(z.any()).optional(), "longestGap": z.number().optional(), "averageGap": z.number().optional() }).strict();
export type GapAnalysis = z.infer<typeof GapAnalysisSchema>;

export const DataGapSchema = z.object({ "start": z.number().int().optional(), "end": z.number().int().optional(), "duration": z.number().optional() }).strict();
export type DataGap = z.infer<typeof DataGapSchema>;

export const AnalysisTimeSchema = z.object({ "start": z.number().int().optional(), "end": z.number().int().optional(), "timeOfAnalysis": z.number().int().optional() }).strict();
export type AnalysisTime = z.infer<typeof AnalysisTimeSchema>;

export const GlucoseAnalyticsRequestSchema = z.object({ 
/**Collection of glucose entries*/
"entries": z.array(z.any()).describe("Collection of glucose entries").optional(), 
/**Optional collection of treatments*/
"treatments": z.array(z.any()).nullable().describe("Optional collection of treatments").optional(), 
/**Optional extended analysis configuration*/
"config": z.any().nullable().describe("Optional extended analysis configuration").optional() }).strict().describe("Request model for comprehensive glucose analytics");
export type GlucoseAnalyticsRequest = z.infer<typeof GlucoseAnalyticsRequestSchema>;

export const ExtendedAnalysisConfigSchema = z.object({ "thresholds": z.any().optional(), "sensorType": z.string().optional(), "includeLoopingMetrics": z.boolean().optional(), "units": z.string().optional() }).strict();
export type ExtendedAnalysisConfig = z.infer<typeof ExtendedAnalysisConfigSchema>;

export const ExtendedGlucoseAnalyticsSchema = z.intersection(z.any(), z.object({ "gmi": z.any().optional(), "gri": z.any().optional(), "timeOfDayPatterns": z.any().optional(), "dayOfWeekPatterns": z.any().optional(), "hypoglycemiaAnalysis": z.any().optional(), "hyperglycemiaAnalysis": z.any().optional(), "clinicalAssessment": z.any().optional(), "dataSufficiency": z.any().optional(), "treatmentSummary": z.any().nullable().optional() }).strict());
export type ExtendedGlucoseAnalytics = z.infer<typeof ExtendedGlucoseAnalyticsSchema>;

export const GlucoseManagementIndicatorSchema = z.object({ "value": z.number().optional(), "meanGlucose": z.number().optional(), "interpretation": z.string().optional() }).strict();
export type GlucoseManagementIndicator = z.infer<typeof GlucoseManagementIndicatorSchema>;

export const GlycemicRiskIndexSchema = z.object({ "score": z.number().optional(), "hypoglycemiaComponent": z.number().optional(), "hyperglycemiaComponent": z.number().optional(), "zone": z.any().optional(), "interpretation": z.string().optional() }).strict();
export type GlycemicRiskIndex = z.infer<typeof GlycemicRiskIndexSchema>;

export const GRIZoneSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4)]);
export type GRIZone = z.infer<typeof GRIZoneSchema>;

export const TimeOfDayAnalysisSchema = z.object({ "overnight": z.any().optional(), "morning": z.any().optional(), "afternoon": z.any().optional(), "evening": z.any().optional(), "dawnPhenomenonDetected": z.boolean().optional(), "dawnPhenomenonMagnitude": z.number().optional(), "highestVariabilityPeriod": z.string().optional(), "lowestTIRPeriod": z.string().optional(), "mostHypoglycemiaPeriod": z.string().optional() }).strict();
export type TimeOfDayAnalysis = z.infer<typeof TimeOfDayAnalysisSchema>;

export const DayOfWeekAnalysisSchema = z.object({ "dayMetrics": z.record(z.any()).optional(), "weekdayAverage": z.any().optional(), "weekendAverage": z.any().optional(), "highestVariabilityDay": z.any().nullable().optional(), "lowestTIRDay": z.any().nullable().optional(), "weekdayWeekendDifference": z.boolean().optional(), "patternDescription": z.string().optional() }).strict();
export type DayOfWeekAnalysis = z.infer<typeof DayOfWeekAnalysisSchema>;

export const DayOfWeekSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6)]);
export type DayOfWeek = z.infer<typeof DayOfWeekSchema>;

export const DayMetricsSchema = z.intersection(z.any(), z.object({ "dayOfWeek": z.any().optional() }).strict());
export type DayMetrics = z.infer<typeof DayMetricsSchema>;

export const HypoglycemiaAnalysisSchema = z.object({ "totalEpisodes": z.number().int().optional(), "severeEpisodes": z.number().int().optional(), "episodesPerDay": z.number().optional(), "averageDurationMinutes": z.number().optional(), "averageNadir": z.number().optional(), "lowestGlucose": z.number().optional(), "averageRecoveryTimeMinutes": z.number().optional(), "hourlyDistribution": z.record(z.number().int()).optional(), "dayOfWeekDistribution": z.record(z.number().int()).optional(), "peakHour": z.number().int().nullable().optional(), "peakDay": z.any().nullable().optional(), "hasRecurringPattern": z.boolean().optional(), "patternDescription": z.string().optional(), "episodes": z.array(z.any()).optional(), "nocturnalEpisodes": z.number().int().optional(), "nocturnalPercentage": z.number().optional(), "riskAssessment": z.string().optional() }).strict();
export type HypoglycemiaAnalysis = z.infer<typeof HypoglycemiaAnalysisSchema>;

export const HypoglycemiaEpisodeSchema = z.object({ "startTime": z.number().int().optional(), "endTime": z.number().int().optional(), "durationMinutes": z.number().optional(), "nadirValue": z.number().optional(), "nadirTime": z.number().int().optional(), "isSevere": z.boolean().optional(), "hourOfDay": z.number().int().optional(), "dayOfWeek": z.any().optional(), "recoveryTimeMinutes": z.number().optional(), "preEpisodeGlucose": z.number().nullable().optional() }).strict();
export type HypoglycemiaEpisode = z.infer<typeof HypoglycemiaEpisodeSchema>;

export const HyperglycemiaAnalysisSchema = z.object({ "totalEpisodes": z.number().int().optional(), "severeEpisodes": z.number().int().optional(), "prolongedEpisodes": z.number().int().optional(), "episodesPerDay": z.number().optional(), "averageDurationMinutes": z.number().optional(), "averagePeak": z.number().optional(), "highestGlucose": z.number().optional(), "averageTimeToTargetMinutes": z.number().optional(), "hourlyDistribution": z.record(z.number().int()).optional(), "dayOfWeekDistribution": z.record(z.number().int()).optional(), "peakHour": z.number().int().nullable().optional(), "peakDay": z.any().nullable().optional(), "hasPostMealPattern": z.boolean().optional(), "patternDescription": z.string().optional(), "episodes": z.array(z.any()).optional(), "nocturnalEpisodes": z.number().int().optional(), "nocturnalPercentage": z.number().optional() }).strict();
export type HyperglycemiaAnalysis = z.infer<typeof HyperglycemiaAnalysisSchema>;

export const HyperglycemiaEpisodeSchema = z.object({ "startTime": z.number().int().optional(), "endTime": z.number().int().optional(), "durationMinutes": z.number().optional(), "peakValue": z.number().optional(), "peakTime": z.number().int().optional(), "isSevere": z.boolean().optional(), "isProlonged": z.boolean().optional(), "hourOfDay": z.number().int().optional(), "dayOfWeek": z.any().optional(), "timeToTargetMinutes": z.number().optional(), "averageGlucose": z.number().optional() }).strict();
export type HyperglycemiaEpisode = z.infer<typeof HyperglycemiaEpisodeSchema>;

export const ClinicalTargetAssessmentSchema = z.object({ "population": z.any().optional(), "targets": z.any().optional(), "tirAssessment": z.any().optional(), "tbrAssessment": z.any().optional(), "veryLowAssessment": z.any().optional(), "tarAssessment": z.any().optional(), "veryHighAssessment": z.any().optional(), "cvAssessment": z.any().optional(), "targetsMet": z.number().int().optional(), "totalTargets": z.number().int().optional(), "overallAssessment": z.string().optional(), "actionableInsights": z.array(z.string()).optional(), "priorityAreas": z.array(z.string()).optional(), "strengths": z.array(z.string()).optional() }).strict();
export type ClinicalTargetAssessment = z.infer<typeof ClinicalTargetAssessmentSchema>;

export const DiabetesPopulationSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5)]);
export type DiabetesPopulation = z.infer<typeof DiabetesPopulationSchema>;

export const ClinicalTargetsSchema = z.object({ "targetTIR": z.number().optional(), "maxTBR": z.number().optional(), "maxTBRVeryLow": z.number().optional(), "maxTAR": z.number().optional(), "maxTARVeryHigh": z.number().optional(), "targetCV": z.number().optional(), "targetLow": z.number().optional(), "targetHigh": z.number().optional() }).strict();
export type ClinicalTargets = z.infer<typeof ClinicalTargetsSchema>;

export const TargetAssessmentSchema = z.object({ "metricName": z.string().optional(), "currentValue": z.number().optional(), "targetValue": z.number().optional(), "isMaximumTarget": z.boolean().optional(), "status": z.any().optional(), "differenceFromTarget": z.number().optional(), "progressPercentage": z.number().optional() }).strict();
export type TargetAssessment = z.infer<typeof TargetAssessmentSchema>;

export const TargetStatusSchema = z.union([z.literal(0), z.literal(1), z.literal(2)]);
export type TargetStatus = z.infer<typeof TargetStatusSchema>;

export const DataSufficiencyAssessmentSchema = z.object({ "isSufficient": z.boolean().optional(), "totalDays": z.number().int().optional(), "daysWithData": z.number().int().optional(), "expectedReadings": z.number().int().optional(), "actualReadings": z.number().int().optional(), "completenessPercentage": z.number().optional(), "minimumRequiredCompleteness": z.number().optional(), "averageReadingsPerDay": z.number().optional(), "longestGapHours": z.number().optional(), "warningMessage": z.string().optional(), "recommendation": z.string().optional() }).strict();
export type DataSufficiencyAssessment = z.infer<typeof DataSufficiencyAssessmentSchema>;

export const ExtendedGlucoseAnalyticsRequestSchema = z.object({ 
/**Collection of glucose entries*/
"entries": z.array(z.any()).describe("Collection of glucose entries").optional(), 
/**Optional collection of treatments*/
"treatments": z.array(z.any()).nullable().describe("Optional collection of treatments").optional(), 
/**Diabetes population type for clinical target assessment*/
"population": z.any().describe("Diabetes population type for clinical target assessment").optional(), 
/**Optional extended analysis configuration*/
"config": z.any().nullable().describe("Optional extended analysis configuration").optional() }).strict().describe("Request model for extended glucose analytics with GMI, GRI, and clinical assessment");
export type ExtendedGlucoseAnalyticsRequest = z.infer<typeof ExtendedGlucoseAnalyticsRequestSchema>;

export const ClinicalAssessmentRequestSchema = z.object({ 
/**Glucose analytics to assess*/
"analytics": z.any().describe("Glucose analytics to assess").optional(), 
/**Diabetes population type for clinical target assessment*/
"population": z.any().describe("Diabetes population type for clinical target assessment").optional() }).strict().describe("Request model for clinical assessment");
export type ClinicalAssessmentRequest = z.infer<typeof ClinicalAssessmentRequestSchema>;

export const DataSufficiencyRequestSchema = z.object({ 
/**Collection of glucose entries*/
"entries": z.array(z.any()).describe("Collection of glucose entries").optional(), 
/**Number of days to assess (default: 14)*/
"days": z.number().int().describe("Number of days to assess (default: 14)").optional(), 
/**Expected readings per day based on sensor type (default: 288 for 5-minute intervals)*/
"expectedReadingsPerDay": z.number().int().describe("Expected readings per day based on sensor type (default: 288 for 5-minute intervals)").optional() }).strict().describe("Request model for data sufficiency assessment");
export type DataSufficiencyRequest = z.infer<typeof DataSufficiencyRequestSchema>;

export const MultiPeriodStatisticsSchema = z.object({ "lastDay": z.any().optional(), "last3Days": z.any().optional(), "lastWeek": z.any().optional(), "lastMonth": z.any().optional(), "last90Days": z.any().optional(), "lastUpdated": z.string().datetime({ offset: true }).optional() }).strict();
export type MultiPeriodStatistics = z.infer<typeof MultiPeriodStatisticsSchema>;

export const PeriodStatisticsSchema = z.object({ "periodDays": z.number().int().optional(), "startDate": z.string().datetime({ offset: true }).optional(), "endDate": z.string().datetime({ offset: true }).optional(), "analytics": z.any().nullable().optional(), "treatmentSummary": z.any().nullable().optional(), "hasSufficientData": z.boolean().optional(), "entryCount": z.number().int().optional(), "treatmentCount": z.number().int().optional() }).strict();
export type PeriodStatistics = z.infer<typeof PeriodStatisticsSchema>;

export const SiteChangeImpactAnalysisSchema = z.object({ "siteChangeCount": z.number().int().optional(), "dataPoints": z.array(z.any()).optional(), "summary": z.any().optional(), "hoursBeforeChange": z.number().int().optional(), "hoursAfterChange": z.number().int().optional(), "bucketSizeMinutes": z.number().int().optional(), "hasSufficientData": z.boolean().optional() }).strict();
export type SiteChangeImpactAnalysis = z.infer<typeof SiteChangeImpactAnalysisSchema>;

export const SiteChangeImpactDataPointSchema = z.object({ "minutesFromChange": z.number().int().optional(), "averageGlucose": z.number().optional(), "medianGlucose": z.number().optional(), "stdDev": z.number().optional(), "count": z.number().int().optional(), "percentile10": z.number().optional(), "percentile25": z.number().optional(), "percentile75": z.number().optional(), "percentile90": z.number().optional() }).strict();
export type SiteChangeImpactDataPoint = z.infer<typeof SiteChangeImpactDataPointSchema>;

export const SiteChangeImpactSummarySchema = z.object({ "avgGlucoseBeforeChange": z.number().optional(), "avgGlucoseAfterChange": z.number().optional(), "percentImprovement": z.number().optional(), "timeInRangeBeforeChange": z.number().optional(), "timeInRangeAfterChange": z.number().optional(), "cvBeforeChange": z.number().optional(), "cvAfterChange": z.number().optional() }).strict();
export type SiteChangeImpactSummary = z.infer<typeof SiteChangeImpactSummarySchema>;

export const SiteChangeImpactRequestSchema = z.object({ 
/**Collection of glucose entries*/
"entries": z.array(z.any()).describe("Collection of glucose entries").optional(), 
/**Collection of treatments (must include site changes)*/
"treatments": z.array(z.any()).describe("Collection of treatments (must include site changes)").optional(), 
/**Hours before site change to analyze (default: 12)*/
"hoursBeforeChange": z.number().int().describe("Hours before site change to analyze (default: 12)").optional(), 
/**Hours after site change to analyze (default: 24)*/
"hoursAfterChange": z.number().int().describe("Hours after site change to analyze (default: 24)").optional(), 
/**Time bucket size for averaging in minutes (default: 30)*/
"bucketSizeMinutes": z.number().int().describe("Time bucket size for averaging in minutes (default: 30)").optional() }).strict().describe("Request model for site change impact analysis");
export type SiteChangeImpactRequest = z.infer<typeof SiteChangeImpactRequestSchema>;

export const VersionsResponseSchema = z.object({ "versions": z.array(z.string()).optional() }).strict();
export type VersionsResponse = z.infer<typeof VersionsResponseSchema>;

export const OpenIdConfigurationSchema = z.object({ "issuer": z.string().optional(), "authorizationEndpoint": z.string().optional(), "tokenEndpoint": z.string().optional(), "userinfoEndpoint": z.string().nullable().optional(), "jwksUri": z.string().optional(), "registrationEndpoint": z.string().nullable().optional(), "endSessionEndpoint": z.string().nullable().optional(), "scopesSupported": z.array(z.string()).optional(), "responseTypesSupported": z.array(z.string()).optional(), "responseModesSupported": z.array(z.string()).optional(), "grantTypesSupported": z.array(z.string()).optional(), "subjectTypesSupported": z.array(z.string()).optional(), "idTokenSigningAlgValuesSupported": z.array(z.string()).optional(), "tokenEndpointAuthMethodsSupported": z.array(z.string()).optional(), "claimsSupported": z.array(z.string()).optional(), "codeChallengeMethodsSupported": z.array(z.string()).optional(), "serviceDocumentation": z.string().nullable().optional() }).strict().describe("OpenID Connect Discovery Document\nSee: https://openid.net/specs/openid-connect-discovery-1_0.html");
export type OpenIdConfiguration = z.infer<typeof OpenIdConfigurationSchema>;

export const JsonWebKeySetSchema = z.object({ "keys": z.array(z.any()).optional() }).strict().describe("JSON Web Key Set");
export type JsonWebKeySet = z.infer<typeof JsonWebKeySetSchema>;

export const JsonWebKeySchema = z.object({ "kty": z.string().optional(), "use": z.string().nullable().optional(), "alg": z.string().nullable().optional(), "kid": z.string().nullable().optional(), "n": z.string().nullable().optional(), "e": z.string().nullable().optional() }).strict().describe("JSON Web Key");
export type JsonWebKey = z.infer<typeof JsonWebKeySchema>;

export const OAuthAuthorizationServerMetadataSchema = z.object({ "issuer": z.string().optional(), "authorizationEndpoint": z.string().optional(), "tokenEndpoint": z.string().optional(), "revocationEndpoint": z.string().nullable().optional(), "introspectionEndpoint": z.string().nullable().optional(), "jwksUri": z.string().optional(), "responseTypesSupported": z.array(z.string()).optional(), "grantTypesSupported": z.array(z.string()).optional(), "tokenEndpointAuthMethodsSupported": z.array(z.string()).optional(), "scopesSupported": z.array(z.string()).optional(), "codeChallengeMethodsSupported": z.array(z.string()).optional(), "serviceDocumentation": z.string().nullable().optional() }).strict().describe("OAuth 2.0 Authorization Server Metadata\nSee: https://datatracker.ietf.org/doc/html/rfc8414");
export type OAuthAuthorizationServerMetadata = z.infer<typeof OAuthAuthorizationServerMetadataSchema>;

export const CurrentBatteryStatusSchema = z.object({ "level": z.number().int().nullable().optional(), "display": z.string().optional(), "status": z.string().optional(), "min": z.any().nullable().optional(), "devices": z.record(z.any()).optional() }).strict();
export type CurrentBatteryStatus = z.infer<typeof CurrentBatteryStatusSchema>;

export const BatteryReadingSchema = z.object({ "id": z.string().nullable().optional(), "device": z.string().optional(), "battery": z.number().int().nullable().optional(), "voltage": z.number().nullable().optional(), "isCharging": z.boolean().optional(), "temperature": z.number().nullable().optional(), "mills": z.number().int().optional(), "timestamp": z.string().nullable().optional(), "display": z.string().optional(), "level": z.number().int().optional(), "notification": z.string().nullable().optional() }).strict();
export type BatteryReading = z.infer<typeof BatteryReadingSchema>;

export const DeviceBatteryStatusSchema = z.object({ "uri": z.string().optional(), "name": z.string().optional(), "statuses": z.array(z.any()).optional(), "min": z.any().nullable().optional() }).strict();
export type DeviceBatteryStatus = z.infer<typeof DeviceBatteryStatusSchema>;

export const BatteryStatisticsSchema = z.object({ "device": z.string().optional(), "displayName": z.string().optional(), "periodStartMills": z.number().int().optional(), "periodEndMills": z.number().int().optional(), "readingCount": z.number().int().optional(), "currentLevel": z.number().int().nullable().optional(), "isCharging": z.boolean().optional(), "lastReadingMills": z.number().int().nullable().optional(), "averageLevel": z.number().nullable().optional(), "minLevel": z.number().int().nullable().optional(), "maxLevel": z.number().int().nullable().optional(), "chargeCycleCount": z.number().int().optional(), "averageChargeDurationMinutes": z.number().nullable().optional(), "averageDischargeDurationMinutes": z.number().nullable().optional(), "averageTimeBetweenChargesHours": z.number().nullable().optional(), "longestDischargeDurationMinutes": z.number().nullable().optional(), "shortestDischargeDurationMinutes": z.number().nullable().optional(), "timeAbove80Percent": z.number().optional(), "timeBetween30And80Percent": z.number().optional(), "timeBelow30Percent": z.number().optional(), "timeBelow20Percent": z.number().optional(), "warningEventCount": z.number().int().optional(), "urgentEventCount": z.number().int().optional(), "display": z.string().optional(), "level": z.number().int().optional(), "status": z.string().optional() }).strict();
export type BatteryStatistics = z.infer<typeof BatteryStatisticsSchema>;

export const ChargeCycleSchema = z.object({ "id": z.string().nullable().optional(), "device": z.string().optional(), "chargeStartMills": z.number().int().nullable().optional(), "chargeStartLevel": z.number().int().nullable().optional(), "chargeEndMills": z.number().int().nullable().optional(), "chargeEndLevel": z.number().int().nullable().optional(), "dischargeStartMills": z.number().int().nullable().optional(), "dischargeStartLevel": z.number().int().nullable().optional(), "dischargeEndMills": z.number().int().nullable().optional(), "dischargeEndLevel": z.number().int().nullable().optional(), "chargeDurationMinutes": z.number().nullable().optional(), "dischargeDurationMinutes": z.number().nullable().optional(), "isComplete": z.boolean().optional() }).strict();
export type ChargeCycle = z.infer<typeof ChargeCycleSchema>;

export const DashboardChartDataSchema = z.object({ 
/**IOB (Insulin on Board) time series*/
"iobSeries": z.array(z.any()).describe("IOB (Insulin on Board) time series").optional(), 
/**COB (Carbs on Board) time series*/
"cobSeries": z.array(z.any()).describe("COB (Carbs on Board) time series").optional(), 
/**Basal rate time series with temp basal indicators*/
"basalSeries": z.array(z.any()).describe("Basal rate time series with temp basal indicators").optional(), 
/**Default basal rate from profile (U/hr)*/
"defaultBasalRate": z.number().describe("Default basal rate from profile (U/hr)").optional(), 
/**Maximum basal rate in the series (for Y-axis scaling)*/
"maxBasalRate": z.number().describe("Maximum basal rate in the series (for Y-axis scaling)").optional(), 
/**Maximum IOB in the series (for Y-axis scaling)*/
"maxIob": z.number().describe("Maximum IOB in the series (for Y-axis scaling)").optional(), 
/**Maximum COB in the series (for Y-axis scaling)*/
"maxCob": z.number().describe("Maximum COB in the series (for Y-axis scaling)").optional(), 
/**Pump mode state spans for chart background coloring*/
"pumpModeSpans": z.array(z.any()).describe("Pump mode state spans for chart background coloring").optional(), 
/**Temp basal state spans with rate and duration metadata*/
"tempBasalSpans": z.array(z.any()).describe("Temp basal state spans with rate and duration metadata").optional(), 
/**Profile state spans showing active profile changes*/
"profileSpans": z.array(z.any()).describe("Profile state spans showing active profile changes").optional() }).strict().describe("Dashboard chart data response with all calculated series");
export type DashboardChartData = z.infer<typeof DashboardChartDataSchema>;

export const TimeSeriesPointSchema = z.object({ 
/**Timestamp in Unix milliseconds*/
"timestamp": z.number().int().describe("Timestamp in Unix milliseconds").optional(), 
/**Value at this timestamp*/
"value": z.number().describe("Value at this timestamp").optional() }).strict().describe("Time series data point with timestamp and value");
export type TimeSeriesPoint = z.infer<typeof TimeSeriesPointSchema>;

export const BasalPointSchema = z.object({ 
/**Timestamp in Unix milliseconds*/
"timestamp": z.number().int().describe("Timestamp in Unix milliseconds").optional(), 
/**Effective basal rate in U/hr (includes temp basals and combo bolus)*/
"rate": z.number().describe("Effective basal rate in U/hr (includes temp basals and combo bolus)").optional(), 
/**Scheduled basal rate from profile in U/hr (without temp basal modifications)*/
"scheduledRate": z.number().describe("Scheduled basal rate from profile in U/hr (without temp basal modifications)").optional(), 
/**Whether this is a temporary basal rate*/
"isTemp": z.boolean().describe("Whether this is a temporary basal rate").optional() }).strict().describe("Basal rate data point");
export type BasalPoint = z.infer<typeof BasalPointSchema>;

export const StateSpanSchema = z.object({ "id": z.string().nullable().optional(), "category": z.any().optional(), "state": z.string().nullable().optional(), "startMills": z.number().int().optional(), "endMills": z.number().int().nullable().optional(), "source": z.string().nullable().optional(), "metadata": z.record(z.any()).nullable().optional(), "originalId": z.string().nullable().optional(), "createdAt": z.string().datetime({ offset: true }).nullable().optional(), "updatedAt": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type StateSpan = z.infer<typeof StateSpanSchema>;

export const StateSpanCategorySchema = z.enum(["PumpMode","PumpConnectivity","Override","Profile","TempBasal"]);
export type StateSpanCategory = z.infer<typeof StateSpanCategorySchema>;

export const ProxyConfigurationDtoSchema = z.object({ "nightscoutUrl": z.string().optional(), "defaultStrategy": z.string().optional(), "enableDetailedLogging": z.boolean().optional() }).strict().describe("Proxy configuration DTO");
export type ProxyConfigurationDto = z.infer<typeof ProxyConfigurationDtoSchema>;

export const CompatibilityMetricsSchema = z.object({ "totalRequests": z.number().int().optional(), "perfectMatches": z.number().int().optional(), "minorDifferences": z.number().int().optional(), "majorDifferences": z.number().int().optional(), "criticalDifferences": z.number().int().optional(), "compatibilityScore": z.number().optional(), "averageNightscoutResponseTime": z.number().optional(), "averageNocturneResponseTime": z.number().optional() }).strict();
export type CompatibilityMetrics = z.infer<typeof CompatibilityMetricsSchema>;

export const EndpointMetricsSchema = z.object({ "endpoint": z.string().optional(), "totalRequests": z.number().int().optional(), "perfectMatches": z.number().int().optional(), "minorDifferences": z.number().int().optional(), "majorDifferences": z.number().int().optional(), "criticalDifferences": z.number().int().optional(), "compatibilityScore": z.number().optional(), "averageNightscoutResponseTime": z.number().optional(), "averageNocturneResponseTime": z.number().optional() }).strict();
export type EndpointMetrics = z.infer<typeof EndpointMetricsSchema>;

export const AnalysesListResponseSchema = z.object({ "analyses": z.array(z.any()).optional(), "total": z.number().int().optional() }).strict().describe("Analyses list response");
export type AnalysesListResponse = z.infer<typeof AnalysesListResponseSchema>;

export const AnalysisListItemDtoSchema = z.object({ "id": z.string().optional(), "correlationId": z.string().optional(), "analysisTimestamp": z.string().datetime({ offset: true }).optional(), "requestMethod": z.string().optional(), "requestPath": z.string().optional(), "overallMatch": z.any().optional(), "statusCodeMatch": z.boolean().optional(), "bodyMatch": z.boolean().optional(), "nightscoutStatusCode": z.number().int().nullable().optional(), "nocturneStatusCode": z.number().int().nullable().optional(), "nightscoutResponseTimeMs": z.number().int().nullable().optional(), "nocturneResponseTimeMs": z.number().int().nullable().optional(), "totalProcessingTimeMs": z.number().int().optional(), "summary": z.string().optional(), "criticalDiscrepancyCount": z.number().int().optional(), "majorDiscrepancyCount": z.number().int().optional(), "minorDiscrepancyCount": z.number().int().optional(), "nightscoutMissing": z.boolean().optional(), "nocturneMissing": z.boolean().optional() }).strict().describe("Analysis list item DTO");
export type AnalysisListItemDto = z.infer<typeof AnalysisListItemDtoSchema>;

export const ResponseMatchTypeSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7)]);
export type ResponseMatchType = z.infer<typeof ResponseMatchTypeSchema>;

export const AnalysisDetailDtoSchema = z.object({ "id": z.string().optional(), "correlationId": z.string().optional(), "analysisTimestamp": z.string().datetime({ offset: true }).optional(), "requestMethod": z.string().optional(), "requestPath": z.string().optional(), "overallMatch": z.any().optional(), "statusCodeMatch": z.boolean().optional(), "bodyMatch": z.boolean().optional(), "nightscoutStatusCode": z.number().int().nullable().optional(), "nocturneStatusCode": z.number().int().nullable().optional(), "nightscoutResponseTimeMs": z.number().int().nullable().optional(), "nocturneResponseTimeMs": z.number().int().nullable().optional(), "totalProcessingTimeMs": z.number().int().optional(), "summary": z.string().optional(), "selectedResponseTarget": z.string().nullable().optional(), "selectionReason": z.string().nullable().optional(), "criticalDiscrepancyCount": z.number().int().optional(), "majorDiscrepancyCount": z.number().int().optional(), "minorDiscrepancyCount": z.number().int().optional(), "nightscoutMissing": z.boolean().optional(), "nocturneMissing": z.boolean().optional(), "errorMessage": z.string().nullable().optional(), "discrepancies": z.array(z.any()).optional() }).strict().describe("Analysis detail DTO");
export type AnalysisDetailDto = z.infer<typeof AnalysisDetailDtoSchema>;

export const DiscrepancyDetailDtoSchema = z.object({ "id": z.string().optional(), "discrepancyType": z.any().optional(), "severity": z.any().optional(), "field": z.string().optional(), "nightscoutValue": z.string().optional(), "nocturneValue": z.string().optional(), "description": z.string().optional(), "recordedAt": z.string().datetime({ offset: true }).optional() }).strict();
export type DiscrepancyDetailDto = z.infer<typeof DiscrepancyDetailDtoSchema>;

export const DiscrepancyTypeSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(8), z.literal(9)]);
export type DiscrepancyType = z.infer<typeof DiscrepancyTypeSchema>;

export const DiscrepancySeveritySchema = z.union([z.literal(0), z.literal(1), z.literal(2)]);
export type DiscrepancySeverity = z.infer<typeof DiscrepancySeveritySchema>;

export const ManualTestResultSchema = z.object({ 
/**The API path that was tested*/
"queryPath": z.string().describe("The API path that was tested").optional(), 
/**HTTP method used*/
"method": z.string().describe("HTTP method used").optional(), 
/**When the test was performed*/
"timestamp": z.string().datetime({ offset: true }).describe("When the test was performed").optional(), 
/**Raw JSON response from Nightscout*/
"nightscoutResponse": z.string().nullable().describe("Raw JSON response from Nightscout").optional(), 
/**Raw JSON response from Nocturne*/
"nocturneResponse": z.string().nullable().describe("Raw JSON response from Nocturne").optional(), 
/**HTTP status code from Nightscout*/
"nightscoutStatusCode": z.number().int().nullable().describe("HTTP status code from Nightscout").optional(), 
/**HTTP status code from Nocturne*/
"nocturneStatusCode": z.number().int().nullable().describe("HTTP status code from Nocturne").optional(), 
/**Response time from Nightscout in milliseconds*/
"nightscoutResponseTimeMs": z.number().int().describe("Response time from Nightscout in milliseconds").optional(), 
/**Response time from Nocturne in milliseconds*/
"nocturneResponseTimeMs": z.number().int().describe("Response time from Nocturne in milliseconds").optional(), 
/**Error message if Nightscout request failed*/
"nightscoutError": z.string().nullable().describe("Error message if Nightscout request failed").optional(), 
/**Error message if Nocturne request failed*/
"nocturneError": z.string().nullable().describe("Error message if Nocturne request failed").optional() }).strict().describe("Result of manual API comparison test");
export type ManualTestResult = z.infer<typeof ManualTestResultSchema>;

export const ManualTestRequestSchema = z.object({ 
/**Base URL of the Nightscout server to compare against*/
"nightscoutUrl": z.string().describe("Base URL of the Nightscout server to compare against").optional(), 
/**API secret (SHA1 hash or plain text)*/
"apiSecret": z.string().nullable().describe("API secret (SHA1 hash or plain text)").optional(), 
/**API path to test (e.g., /api/v1/entries?count=10)*/
"queryPath": z.string().describe("API path to test (e.g., /api/v1/entries?count=10)").optional(), 
/**HTTP method (GET, POST, etc.) - defaults to GET*/
"method": z.string().nullable().describe("HTTP method (GET, POST, etc.) - defaults to GET").optional(), 
/**Optional request body for POST/PUT requests*/
"requestBody": z.string().nullable().describe("Optional request body for POST/PUT requests").optional() }).strict().describe("Request for manual API comparison test");
export type ManualTestRequest = z.infer<typeof ManualTestRequestSchema>;

export const ConnectorFoodEntrySchema = z.object({ "id": z.string().optional(), "connectorSource": z.string().optional(), "externalEntryId": z.string().optional(), "externalFoodId": z.string().optional(), "foodId": z.string().nullable().optional(), "food": z.any().nullable().optional(), "consumedAt": z.string().datetime({ offset: true }).optional(), "loggedAt": z.string().datetime({ offset: true }).nullable().optional(), "mealName": z.string().optional(), "carbs": z.number().optional(), "protein": z.number().optional(), "fat": z.number().optional(), "energy": z.number().optional(), "servings": z.number().optional(), "servingDescription": z.string().nullable().optional(), "status": z.any().optional(), "matchedTreatmentId": z.string().nullable().optional(), "resolvedAt": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type ConnectorFoodEntry = z.infer<typeof ConnectorFoodEntrySchema>;

export const FoodSchema = z.object({ "_id": z.string().nullable().optional(), "type": z.string().optional(), "category": z.string().optional(), "subcategory": z.string().optional(), "name": z.string().optional(), "portion": z.number().optional(), "carbs": z.number().optional(), "fat": z.number().optional(), "protein": z.number().optional(), "energy": z.number().optional(), "gi": z.number().int().optional(), "unit": z.string().optional(), "foods": z.array(z.any()).nullable().optional(), "hideafteruse": z.boolean().optional(), "hidden": z.boolean().optional(), "position": z.number().int().optional() }).strict();
export type Food = z.infer<typeof FoodSchema>;

export const QuickPickFoodSchema = z.object({ "name": z.string().optional(), "portion": z.number().optional(), "carbs": z.number().optional(), "unit": z.string().optional(), "portions": z.number().optional() }).strict();
export type QuickPickFood = z.infer<typeof QuickPickFoodSchema>;

export const ConnectorFoodEntryStatusSchema = z.enum(["Pending","Matched","Standalone","Deleted"]);
export type ConnectorFoodEntryStatus = z.infer<typeof ConnectorFoodEntryStatusSchema>;

export const ConnectorFoodEntryImportSchema = z.object({ "connectorSource": z.string().optional(), "externalEntryId": z.string().optional(), "externalFoodId": z.string().optional(), "consumedAt": z.string().datetime({ offset: true }).optional(), "loggedAt": z.string().datetime({ offset: true }).nullable().optional(), "mealName": z.string().optional(), "carbs": z.number().optional(), "protein": z.number().optional(), "fat": z.number().optional(), "energy": z.number().optional(), "servings": z.number().optional(), "servingDescription": z.string().nullable().optional(), "food": z.any().nullable().optional() }).strict();
export type ConnectorFoodEntryImport = z.infer<typeof ConnectorFoodEntryImportSchema>;

export const ConnectorFoodImportSchema = z.object({ "externalId": z.string().optional(), "name": z.string().optional(), "brandName": z.string().nullable().optional(), "carbs": z.number().optional(), "protein": z.number().optional(), "fat": z.number().optional(), "energy": z.number().optional(), "portion": z.number().optional(), "unit": z.string().nullable().optional() }).strict();
export type ConnectorFoodImport = z.infer<typeof ConnectorFoodImportSchema>;

export const DeviceAlertSchema = z.object({ "id": z.string().optional(), "deviceId": z.string().optional(), "userId": z.string().optional(), "alertType": z.any().optional(), "severity": z.any().optional(), "title": z.string().optional(), "message": z.string().optional(), "triggerTime": z.string().datetime({ offset: true }).optional(), "acknowledged": z.boolean().optional(), "acknowledgedAt": z.string().datetime({ offset: true }).nullable().optional(), "data": z.record(z.any()).nullable().optional() }).strict();
export type DeviceAlert = z.infer<typeof DeviceAlertSchema>;

export const DeviceAlertTypeSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(8), z.literal(9)]);
export type DeviceAlertType = z.infer<typeof DeviceAlertTypeSchema>;

export const DeviceIssueSeveritySchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)]);
export type DeviceIssueSeverity = z.infer<typeof DeviceIssueSeveritySchema>;

export const DeviceAlertSummarySchema = z.object({ 
/**Total number of registered devices*/
"totalDevices": z.number().int().describe("Total number of registered devices").optional(), 
/**Number of active alerts*/
"activeAlerts": z.number().int().describe("Number of active alerts").optional(), 
/**Number of critical alerts*/
"criticalAlerts": z.number().int().describe("Number of critical alerts").optional(), 
/**Number of warning alerts*/
"warningAlerts": z.number().int().describe("Number of warning alerts").optional(), 
/**Alerts grouped by type*/
"alertsByType": z.record(z.number().int()).describe("Alerts grouped by type").optional() }).strict().describe("Device alert summary model");
export type DeviceAlertSummary = z.infer<typeof DeviceAlertSummarySchema>;

export const DeviceAlertSettingsSchema = z.object({ 
/**Enable email notifications*/
"emailEnabled": z.boolean().describe("Enable email notifications").optional(), 
/**Enable push notifications*/
"pushEnabled": z.boolean().describe("Enable push notifications").optional(), 
/**Enable SMS notifications*/
"smsEnabled": z.boolean().describe("Enable SMS notifications").optional(), 
/**Enable quiet hours*/
"quietHoursEnabled": z.boolean().describe("Enable quiet hours").optional(), 
/**Quiet hours start time*/
"quietHoursStart": z.string().duration().describe("Quiet hours start time").optional(), 
/**Quiet hours end time*/
"quietHoursEnd": z.string().duration().describe("Quiet hours end time").optional(), 
/**Critical alerts override quiet hours*/
"criticalAlertsOverrideQuietHours": z.boolean().describe("Critical alerts override quiet hours").optional(), 
/**Battery low threshold percentage*/
"batteryLowThreshold": z.number().int().describe("Battery low threshold percentage").optional(), 
/**Sensor expiration warning hours*/
"sensorExpirationWarningHours": z.number().int().describe("Sensor expiration warning hours").optional(), 
/**Data gap warning minutes*/
"dataGapWarningMinutes": z.number().int().describe("Data gap warning minutes").optional(), 
/**Calibration reminder hours*/
"calibrationReminderHours": z.number().int().describe("Calibration reminder hours").optional() }).strict().describe("Device alert settings model");
export type DeviceAlertSettings = z.infer<typeof DeviceAlertSettingsSchema>;

export const DeviceHealthSchema = z.object({ "id": z.string().optional(), "userId": z.string().optional(), "deviceId": z.string().optional(), "deviceType": z.any().optional(), "deviceName": z.string().optional(), "manufacturer": z.string().nullable().optional(), "model": z.string().nullable().optional(), "serialNumber": z.string().nullable().optional(), "batteryLevel": z.number().nullable().optional(), "sensorExpiration": z.string().datetime({ offset: true }).nullable().optional(), "lastCalibration": z.string().datetime({ offset: true }).nullable().optional(), "lastDataReceived": z.string().datetime({ offset: true }).nullable().optional(), "lastMaintenanceAlert": z.string().datetime({ offset: true }).nullable().optional(), "batteryWarningThreshold": z.number().optional(), "sensorExpirationWarningHours": z.number().int().optional(), "dataGapWarningMinutes": z.number().int().optional(), "calibrationReminderHours": z.number().int().optional(), "status": z.any().optional(), "lastErrorMessage": z.string().nullable().optional(), "lastStatusUpdate": z.string().datetime({ offset: true }).nullable().optional(), "createdAt": z.string().datetime({ offset: true }).optional(), "updatedAt": z.string().datetime({ offset: true }).optional() }).strict();
export type DeviceHealth = z.infer<typeof DeviceHealthSchema>;

export const DeviceTypeSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)]);
export type DeviceType = z.infer<typeof DeviceTypeSchema>;

export const DeviceStatusTypeSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4)]);
export type DeviceStatusType = z.infer<typeof DeviceStatusTypeSchema>;

export const DeviceRegistrationRequestSchema = z.object({ "deviceId": z.string().optional(), "deviceType": z.any().optional(), "deviceName": z.string().optional(), "manufacturer": z.string().nullable().optional(), "model": z.string().nullable().optional(), "serialNumber": z.string().nullable().optional(), "batteryLevel": z.number().nullable().optional(), "sensorExpiration": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type DeviceRegistrationRequest = z.infer<typeof DeviceRegistrationRequestSchema>;

export const DeviceSettingsUpdateSchema = z.object({ "batteryWarningThreshold": z.number().nullable().optional(), "sensorExpirationWarningHours": z.number().int().nullable().optional(), "dataGapWarningMinutes": z.number().int().nullable().optional(), "calibrationReminderHours": z.number().int().nullable().optional() }).strict();
export type DeviceSettingsUpdate = z.infer<typeof DeviceSettingsUpdateSchema>;

export const DeviceHealthUpdateSchema = z.object({ "batteryLevel": z.number().nullable().optional(), "sensorExpiration": z.string().datetime({ offset: true }).nullable().optional(), "lastCalibration": z.string().datetime({ offset: true }).nullable().optional(), "status": z.any().nullable().optional(), "lastErrorMessage": z.string().nullable().optional(), "deviceSpecificData": z.record(z.any()).nullable().optional() }).strict();
export type DeviceHealthUpdate = z.infer<typeof DeviceHealthUpdateSchema>;

export const DiscrepancyAnalysisDtoSchema = z.object({ "id": z.string().optional(), "correlationId": z.string().optional(), "analysisTimestamp": z.string().datetime({ offset: true }).optional(), "requestMethod": z.string().optional(), "requestPath": z.string().optional(), "overallMatch": z.number().int().optional(), "statusCodeMatch": z.boolean().optional(), "bodyMatch": z.boolean().optional(), "nightscoutStatusCode": z.number().int().nullable().optional(), "nocturneStatusCode": z.number().int().nullable().optional(), "nightscoutResponseTimeMs": z.number().int().nullable().optional(), "nocturneResponseTimeMs": z.number().int().nullable().optional(), "totalProcessingTimeMs": z.number().int().optional(), "summary": z.string().optional(), "selectedResponseTarget": z.string().nullable().optional(), "selectionReason": z.string().nullable().optional(), "criticalDiscrepancyCount": z.number().int().optional(), "majorDiscrepancyCount": z.number().int().optional(), "minorDiscrepancyCount": z.number().int().optional(), "nightscoutMissing": z.boolean().optional(), "nocturneMissing": z.boolean().optional(), "errorMessage": z.string().nullable().optional(), "discrepancies": z.array(z.any()).optional() }).strict();
export type DiscrepancyAnalysisDto = z.infer<typeof DiscrepancyAnalysisDtoSchema>;

export const CompatibilityStatusSchema = z.object({ "overallScore": z.number().optional(), "totalRequests": z.number().int().optional(), "healthStatus": z.string().optional(), "lastUpdated": z.string().datetime({ offset: true }).optional(), "criticalIssues": z.number().int().optional(), "majorIssues": z.number().int().optional(), "minorIssues": z.number().int().optional() }).strict();
export type CompatibilityStatus = z.infer<typeof CompatibilityStatusSchema>;

export const ForwardedDiscrepancyDtoSchema = z.object({ "sourceId": z.string().optional(), "receivedAt": z.string().datetime({ offset: true }).optional(), "analysis": z.any().optional() }).strict();
export type ForwardedDiscrepancyDto = z.infer<typeof ForwardedDiscrepancyDtoSchema>;

export const TestMigrationConnectionResultSchema = z.object({ "isSuccess": z.boolean().optional(), "errorMessage": z.string().nullable().optional(), "siteName": z.string().nullable().optional(), "version": z.string().nullable().optional(), "entryCount": z.number().int().nullable().optional(), "treatmentCount": z.number().int().nullable().optional(), "availableCollections": z.array(z.string()).optional() }).strict().describe("Result of testing a migration connection");
export type TestMigrationConnectionResult = z.infer<typeof TestMigrationConnectionResultSchema>;

export const TestMigrationConnectionRequestSchema = z.object({ "mode": z.any().optional(), "nightscoutUrl": z.string().nullable().optional(), "nightscoutApiSecret": z.string().nullable().optional(), "mongoConnectionString": z.string().nullable().optional(), "mongoDatabaseName": z.string().nullable().optional() }).strict().describe("Request to test a Nightscout connection");
export type TestMigrationConnectionRequest = z.infer<typeof TestMigrationConnectionRequestSchema>;

export const MigrationModeSchema = z.union([z.literal(0), z.literal(1)]).describe("Enumerates the modes for data migration");
export type MigrationMode = z.infer<typeof MigrationModeSchema>;

export const MigrationJobInfoSchema = z.object({ "id": z.string().optional(), "mode": z.any().optional(), "createdAt": z.string().datetime({ offset: true }).optional(), "sourceDescription": z.string().nullable().optional(), "state": z.any().optional(), "startedAt": z.string().datetime({ offset: true }).nullable().optional(), "completedAt": z.string().datetime({ offset: true }).nullable().optional(), "errorMessage": z.string().nullable().optional() }).strict().describe("Information about a migration job");
export type MigrationJobInfo = z.infer<typeof MigrationJobInfoSchema>;

export const MigrationJobStateSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5)]).describe("Current state of a migration job");
export type MigrationJobState = z.infer<typeof MigrationJobStateSchema>;

export const StartMigrationRequestSchema = z.object({ 
/**Migration mode (API or MongoDB)*/
"mode": z.any().describe("Migration mode (API or MongoDB)").optional(), 
/**Nightscout URL (for API mode)*/
"nightscoutUrl": z.string().nullable().describe("Nightscout URL (for API mode)").optional(), 
/**Nightscout API secret (for API mode)*/
"nightscoutApiSecret": z.string().nullable().describe("Nightscout API secret (for API mode)").optional(), 
/**MongoDB connection string (for MongoDB mode)*/
"mongoConnectionString": z.string().nullable().describe("MongoDB connection string (for MongoDB mode)").optional(), 
/**MongoDB database name (for MongoDB mode)*/
"mongoDatabaseName": z.string().nullable().describe("MongoDB database name (for MongoDB mode)").optional(), 
/**Collections to migrate. Empty means all.*/
"collections": z.array(z.string()).describe("Collections to migrate. Empty means all.").optional(), 
/**Start date for migration (optional)*/
"startDate": z.string().datetime({ offset: true }).nullable().describe("Start date for migration (optional)").optional(), 
/**End date for migration (optional)*/
"endDate": z.string().datetime({ offset: true }).nullable().describe("End date for migration (optional)").optional() }).strict().describe("Request to start a new migration job");
export type StartMigrationRequest = z.infer<typeof StartMigrationRequestSchema>;

export const MigrationJobStatusSchema = z.object({ "jobId": z.string().optional(), "state": z.any().optional(), "progressPercentage": z.number().optional(), "currentOperation": z.string().nullable().optional(), "errorMessage": z.string().nullable().optional(), "startedAt": z.string().datetime({ offset: true }).optional(), "completedAt": z.string().datetime({ offset: true }).nullable().optional(), "estimatedTimeRemaining": z.string().duration().nullable().optional(), "collectionProgress": z.record(z.any()).optional() }).strict().describe("Status of a migration job including progress");
export type MigrationJobStatus = z.infer<typeof MigrationJobStatusSchema>;

export const CollectionProgressSchema = z.object({ "collectionName": z.string().optional(), "totalDocuments": z.number().int().optional(), "documentsMigrated": z.number().int().optional(), "documentsFailed": z.number().int().optional(), "isComplete": z.boolean().optional() }).strict().describe("Progress for a specific collection");
export type CollectionProgress = z.infer<typeof CollectionProgressSchema>;

export const PendingMigrationConfigSchema = z.object({ 
/**Whether there is a pending migration configuration in env vars*/
"hasPendingConfig": z.boolean().describe("Whether there is a pending migration configuration in env vars").optional(), 
/**Migration mode from MIGRATION_MODE env var*/
"mode": z.any().nullable().describe("Migration mode from MIGRATION_MODE env var").optional(), 
/**Nightscout URL from MIGRATION_NS_URL env var*/
"nightscoutUrl": z.string().nullable().describe("Nightscout URL from MIGRATION_NS_URL env var").optional(), 
/**Whether MIGRATION_NS_API_SECRET is set (never returns the actual secret)*/
"hasApiSecret": z.boolean().describe("Whether MIGRATION_NS_API_SECRET is set (never returns the actual secret)").optional(), 
/**Whether MIGRATION_MONGO_CONNECTION_STRING is set (never returns the actual string)*/
"hasMongoConnectionString": z.boolean().describe("Whether MIGRATION_MONGO_CONNECTION_STRING is set (never returns the actual string)").optional(), 
/**MongoDB database name from MIGRATION_MONGO_DATABASE_NAME env var*/
"mongoDatabaseName": z.string().nullable().describe("MongoDB database name from MIGRATION_MONGO_DATABASE_NAME env var").optional() }).strict().describe("Pending migration configuration from environment variables");
export type PendingMigrationConfig = z.infer<typeof PendingMigrationConfigSchema>;

export const MigrationSourceDtoSchema = z.object({ 
/**Unique identifier for this source*/
"id": z.string().describe("Unique identifier for this source").optional(), 
/**Migration mode (Api or MongoDb)*/
"mode": z.any().describe("Migration mode (Api or MongoDb)").optional(), 
/**Nightscout URL (for API mode)*/
"nightscoutUrl": z.string().nullable().describe("Nightscout URL (for API mode)").optional(), 
/**MongoDB database name (for MongoDB mode)*/
"mongoDatabaseName": z.string().nullable().describe("MongoDB database name (for MongoDB mode)").optional(), 
/**When the last successful migration completed*/
"lastMigrationAt": z.string().datetime({ offset: true }).nullable().describe("When the last successful migration completed").optional(), 
/**Newest data timestamp migrated (for "since last" default)*/
"lastMigratedDataTimestamp": z.string().datetime({ offset: true }).nullable().describe("Newest data timestamp migrated (for \"since last\" default)").optional(), 
/**When this source was first added*/
"createdAt": z.string().datetime({ offset: true }).describe("When this source was first added").optional() }).strict().describe("Migration source DTO for API responses");
export type MigrationSourceDto = z.infer<typeof MigrationSourceDtoSchema>;

export const MyFitnessPalMatchingSettingsSchema = z.object({ "matchTimeWindowMinutes": z.number().int().optional(), "matchCarbTolerancePercent": z.number().int().optional(), "matchCarbToleranceGrams": z.number().int().optional(), "unmatchedTimeoutHours": z.number().int().optional(), "unmatchedBehavior": z.any().optional(), "enableMatchNotifications": z.boolean().optional(), "enableUnmatchedNotifications": z.boolean().optional() }).strict();
export type MyFitnessPalMatchingSettings = z.infer<typeof MyFitnessPalMatchingSettingsSchema>;

export const UnmatchedBehaviorSchema = z.enum(["Prompt","AutoStandalone","AutoDelete"]);
export type UnmatchedBehavior = z.infer<typeof UnmatchedBehaviorSchema>;

export const GlucosePredictionResponseSchema = z.object({ 
/**Timestamp when predictions were calculated*/
"timestamp": z.string().datetime({ offset: true }).describe("Timestamp when predictions were calculated").optional(), 
/**Current blood glucose (mg/dL)*/
"currentBg": z.number().describe("Current blood glucose (mg/dL)").optional(), 
/**Rate of glucose change (mg/dL per 5 min)*/
"delta": z.number().describe("Rate of glucose change (mg/dL per 5 min)").optional(), 
/**Eventual blood glucose if trend continues (mg/dL)*/
"eventualBg": z.number().describe("Eventual blood glucose if trend continues (mg/dL)").optional(), 
/**Current insulin on board (U)*/
"iob": z.number().describe("Current insulin on board (U)").optional(), 
/**Current carbs on board (g)*/
"cob": z.number().describe("Current carbs on board (g)").optional(), 
/**Sensitivity ratio used (1.0 = normal)*/
"sensitivityRatio": z.number().nullable().describe("Sensitivity ratio used (1.0 = normal)").optional(), 
/**Prediction interval in minutes*/
"intervalMinutes": z.number().int().describe("Prediction interval in minutes").optional(), 
/**Prediction curves with different scenarios*/
"predictions": z.any().describe("Prediction curves with different scenarios").optional() }).strict().describe("Response containing glucose predictions.");
export type GlucosePredictionResponse = z.infer<typeof GlucosePredictionResponseSchema>;

export const PredictionCurvesSchema = z.object({ 
/**Main prediction curve (mg/dL values at 5-min intervals)*/
"default": z.array(z.number()).nullable().describe("Main prediction curve (mg/dL values at 5-min intervals)").optional(), 
/**IOB-only prediction (ignoring COB)*/
"iobOnly": z.array(z.number()).nullable().describe("IOB-only prediction (ignoring COB)").optional(), 
/**UAM (Unannounced Meal) prediction*/
"uam": z.array(z.number()).nullable().describe("UAM (Unannounced Meal) prediction").optional(), 
/**COB-based prediction*/
"cob": z.array(z.number()).nullable().describe("COB-based prediction").optional(), 
/**Zero-temp prediction (what happens if basal stops)*/
"zeroTemp": z.array(z.number()).nullable().describe("Zero-temp prediction (what happens if basal stops)").optional() }).strict().describe("Different prediction curves for visualization.");
export type PredictionCurves = z.infer<typeof PredictionCurvesSchema>;

export const PredictionErrorResponseSchema = z.object({ 
/**Error message*/
"error": z.string().describe("Error message").optional() }).strict().describe("Error response for prediction failures.");
export type PredictionErrorResponse = z.infer<typeof PredictionErrorResponseSchema>;

export const PredictionStatusResponseSchema = z.object({ 
/**Whether the oref library is available*/
"available": z.boolean().describe("Whether the oref library is available").optional(), 
/**Version of the oref library*/
"version": z.string().nullable().describe("Version of the oref library").optional(), 
/**Health check result (JSON)*/
"healthCheck": z.string().nullable().describe("Health check result (JSON)").optional() }).strict().describe("Status of the prediction service.");
export type PredictionStatusResponse = z.infer<typeof PredictionStatusResponseSchema>;

export const ProcessingStatusResponseSchema = z.intersection(z.any(), z.record(z.never()));
export type ProcessingStatusResponse = z.infer<typeof ProcessingStatusResponseSchema>;

export const ProcessingStatusSchema = z.object({ "correlationId": z.string().optional(), "status": z.string().optional(), "progress": z.number().int().optional(), "processedCount": z.number().int().optional(), "totalCount": z.number().int().optional(), "startedAt": z.string().datetime({ offset: true }).optional(), "completedAt": z.string().datetime({ offset: true }).nullable().optional(), "errors": z.array(z.string()).optional(), "results": z.any().nullable().optional() }).strict();
export type ProcessingStatus = z.infer<typeof ProcessingStatusSchema>;

export const RetrospectiveDataResponseSchema = z.object({ "time": z.number().int().optional(), "timeFormatted": z.string().nullable().optional(), "glucose": z.any().nullable().optional(), "iob": z.any().nullable().optional(), "cob": z.any().nullable().optional(), "basal": z.any().nullable().optional(), "recentTreatments": z.array(z.any()).nullable().optional() }).strict().describe("Response for single point retrospective data");
export type RetrospectiveDataResponse = z.infer<typeof RetrospectiveDataResponseSchema>;

export const GlucoseDataSchema = z.object({ "value": z.number().int().optional(), "direction": z.string().nullable().optional(), "delta": z.number().int().nullable().optional() }).strict().describe("Glucose data at a specific point in time");
export type GlucoseData = z.infer<typeof GlucoseDataSchema>;

export const IobDataSchema = z.object({ "total": z.number().optional(), "bolus": z.number().optional(), "basal": z.number().optional(), "activity": z.number().nullable().optional(), "source": z.string().nullable().optional() }).strict().describe("IOB data at a specific point in time");
export type IobData = z.infer<typeof IobDataSchema>;

export const CobDataSchema = z.object({ "total": z.number().optional(), "isDecaying": z.number().optional(), "carbsHr": z.number().nullable().optional(), "rawCarbImpact": z.number().nullable().optional(), "source": z.string().nullable().optional() }).strict().describe("COB data at a specific point in time");
export type CobData = z.infer<typeof CobDataSchema>;

export const BasalDataSchema = z.object({ "rate": z.number().optional(), "isTemp": z.boolean().optional() }).strict().describe("Basal rate data at a specific point in time");
export type BasalData = z.infer<typeof BasalDataSchema>;

export const TreatmentSummaryDataSchema = z.object({ "id": z.string().nullable().optional(), "mills": z.number().int().optional(), "eventType": z.string().nullable().optional(), "insulin": z.number().nullable().optional(), "carbs": z.number().nullable().optional(), "rate": z.number().nullable().optional(), "duration": z.number().nullable().optional(), "notes": z.string().nullable().optional() }).strict().describe("Treatment summary for recent treatments");
export type TreatmentSummaryData = z.infer<typeof TreatmentSummaryDataSchema>;

export const RetrospectiveTimelineResponseSchema = z.object({ "date": z.string().nullable().optional(), "startTime": z.number().int().optional(), "endTime": z.number().int().optional(), "intervalMinutes": z.number().int().optional(), "totalPoints": z.number().int().optional(), "data": z.array(z.any()).nullable().optional() }).strict().describe("Response for retrospective timeline");
export type RetrospectiveTimelineResponse = z.infer<typeof RetrospectiveTimelineResponseSchema>;

export const RetrospectiveDataPointSchema = z.object({ "time": z.number().int().optional(), "hour": z.number().int().optional(), "minute": z.number().int().optional(), "timeLabel": z.string().nullable().optional(), "glucose": z.number().int().nullable().optional(), "glucoseDirection": z.string().nullable().optional(), "iob": z.number().optional(), "bolusIob": z.number().optional(), "basalIob": z.number().optional(), "cob": z.number().optional(), "basalRate": z.number().optional(), "isTemp": z.boolean().optional() }).strict().describe("Data point for retrospective timeline");
export type RetrospectiveDataPoint = z.infer<typeof RetrospectiveDataPointSchema>;

export const BasalTimelineResponseSchema = z.object({ "date": z.string().nullable().optional(), "startTime": z.number().int().optional(), "endTime": z.number().int().optional(), "intervalMinutes": z.number().int().optional(), "data": z.array(z.any()).nullable().optional() }).strict().describe("Response for basal timeline");
export type BasalTimelineResponse = z.infer<typeof BasalTimelineResponseSchema>;

export const BasalDataPointSchema = z.object({ "time": z.number().int().optional(), "hour": z.number().int().optional(), "minute": z.number().int().optional(), "timeLabel": z.string().nullable().optional(), "rate": z.number().optional(), "isTemp": z.boolean().optional() }).strict().describe("Data point for basal timeline");
export type BasalDataPoint = z.infer<typeof BasalDataPointSchema>;

export const ServicesOverviewSchema = z.object({ "activeDataSources": z.array(z.any()).optional(), "availableConnectors": z.array(z.any()).optional(), "uploaderApps": z.array(z.any()).optional(), "apiEndpoint": z.any().optional() }).strict();
export type ServicesOverview = z.infer<typeof ServicesOverviewSchema>;

export const DataSourceInfoSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "deviceId": z.string().optional(), "category": z.string().optional(), "sourceType": z.string().optional(), "description": z.string().optional(), "lastSeen": z.string().datetime({ offset: true }).nullable().optional(), "firstSeen": z.string().datetime({ offset: true }).nullable().optional(), "entriesLast24h": z.number().int().optional(), "totalEntries": z.number().int().optional(), "status": z.string().optional(), "minutesSinceLastData": z.number().int().nullable().optional(), "icon": z.string().optional(), "isHealthy": z.boolean().optional() }).strict();
export type DataSourceInfo = z.infer<typeof DataSourceInfoSchema>;

export const AvailableConnectorSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "category": z.string().optional(), "description": z.string().optional(), "icon": z.string().optional(), "available": z.boolean().optional(), "requiresServerConfig": z.boolean().optional(), "isConfigured": z.boolean().optional(), "configFields": z.array(z.any()).nullable().optional(), "documentationUrl": z.string().nullable().optional() }).strict();
export type AvailableConnector = z.infer<typeof AvailableConnectorSchema>;

export const ConnectorConfigFieldSchema = z.object({ "id": z.string().optional(), "label": z.string().optional(), "type": z.string().optional(), "required": z.boolean().optional(), "placeholder": z.string().nullable().optional(), "helpText": z.string().nullable().optional(), "options": z.array(z.any()).nullable().optional() }).strict();
export type ConnectorConfigField = z.infer<typeof ConnectorConfigFieldSchema>;

export const SelectOptionSchema = z.object({ "value": z.string().optional(), "label": z.string().optional() }).strict();
export type SelectOption = z.infer<typeof SelectOptionSchema>;

export const UploaderAppSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "platform": z.string().optional(), "description": z.string().optional(), "category": z.string().optional(), "icon": z.string().optional(), "setupInstructions": z.array(z.any()).nullable().optional(), "url": z.string().nullable().optional() }).strict();
export type UploaderApp = z.infer<typeof UploaderAppSchema>;

export const SetupStepSchema = z.object({ "step": z.number().int().optional(), "title": z.string().optional(), "description": z.string().optional(), "imageUrl": z.string().nullable().optional() }).strict();
export type SetupStep = z.infer<typeof SetupStepSchema>;

export const ApiEndpointInfoSchema = z.object({ "baseUrl": z.string().optional(), "requiresApiSecret": z.boolean().optional(), "isAuthenticated": z.boolean().optional(), "entriesEndpoint": z.string().optional(), "treatmentsEndpoint": z.string().optional(), "deviceStatusEndpoint": z.string().optional() }).strict();
export type ApiEndpointInfo = z.infer<typeof ApiEndpointInfoSchema>;

export const UploaderSetupResponseSchema = z.object({ 
/**The uploader app details*/
"app": z.any().describe("The uploader app details").optional(), 
/**Base URL for this Nocturne instance*/
"baseUrl": z.string().describe("Base URL for this Nocturne instance").optional(), 
/**Placeholder for where the API secret goes*/
"apiSecretPlaceholder": z.string().describe("Placeholder for where the API secret goes").optional(), 
/**Full API URL (base + /api/v1)*/
"fullApiUrl": z.string().describe("Full API URL (base + /api/v1)").optional(), 
/**Entries endpoint URL*/
"entriesUrl": z.string().describe("Entries endpoint URL").optional(), 
/**Treatments endpoint URL*/
"treatmentsUrl": z.string().describe("Treatments endpoint URL").optional(), 
/**Device status endpoint URL*/
"deviceStatusUrl": z.string().describe("Device status endpoint URL").optional(), 
/**xDrip+ style URL with embedded secret placeholder*/
"xdripStyleUrl": z.string().describe("xDrip+ style URL with embedded secret placeholder").optional() }).strict().describe("Response model for uploader setup instructions");
export type UploaderSetupResponse = z.infer<typeof UploaderSetupResponseSchema>;

export const DataSourceDeleteResultSchema = z.object({ "success": z.boolean().optional(), "entriesDeleted": z.number().int().optional(), "treatmentsDeleted": z.number().int().optional(), "deviceStatusDeleted": z.number().int().optional(), "dataSource": z.string().optional(), "error": z.string().nullable().optional() }).strict();
export type DataSourceDeleteResult = z.infer<typeof DataSourceDeleteResultSchema>;

export const SyncResultSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional(), "startTime": z.string().datetime({ offset: true }).optional(), "endTime": z.string().datetime({ offset: true }).optional(), "itemsSynced": z.record(z.number().int()).optional(), "lastEntryTimes": z.record(z.string().datetime({ offset: true }).nullable()).optional(), "errors": z.array(z.string()).optional() }).strict();
export type SyncResult = z.infer<typeof SyncResultSchema>;

export const SyncDataTypeSchema = z.enum(["Glucose","Treatments","Profiles","DeviceStatus","Activity","Food"]);
export type SyncDataType = z.infer<typeof SyncDataTypeSchema>;

export const SyncRequestSchema = z.object({ "from": z.string().datetime({ offset: true }).nullable().optional(), "to": z.string().datetime({ offset: true }).nullable().optional(), "dataTypes": z.array(z.any()).optional() }).strict();
export type SyncRequest = z.infer<typeof SyncRequestSchema>;

export const ConnectorSyncStatusSchema = z.object({ 
/**The connector ID (e.g., "dexcom", "libre")*/
"connectorId": z.string().describe("The connector ID (e.g., \"dexcom\", \"libre\")").optional(), 
/**The data source name used in the database (e.g., "dexcom-connector")*/
"dataSource": z.string().describe("The data source name used in the database (e.g., \"dexcom-connector\")").optional(), 
/**The timestamp of the latest entry, or null if no entries exist*/
"latestEntryTimestamp": z.string().datetime({ offset: true }).nullable().describe("The timestamp of the latest entry, or null if no entries exist").optional(), 
/**The timestamp of the oldest entry, or null if no entries exist*/
"oldestEntryTimestamp": z.string().datetime({ offset: true }).nullable().describe("The timestamp of the oldest entry, or null if no entries exist").optional(), 
/**The timestamp of the latest treatment, or null if no treatments exist*/
"latestTreatmentTimestamp": z.string().datetime({ offset: true }).nullable().describe("The timestamp of the latest treatment, or null if no treatments exist").optional(), 
/**The timestamp of the oldest treatment, or null if no treatments exist*/
"oldestTreatmentTimestamp": z.string().datetime({ offset: true }).nullable().describe("The timestamp of the oldest treatment, or null if no treatments exist").optional(), 
/**Whether any entries exist for this connector*/
"hasEntries": z.boolean().describe("Whether any entries exist for this connector").optional(), 
/**Whether any treatments exist for this connector*/
"hasTreatments": z.boolean().describe("Whether any treatments exist for this connector").optional(), 
/**Current connector state (Idle, Syncing, BackingOff, Error)*/
"state": z.string().describe("Current connector state (Idle, Syncing, BackingOff, Error)").optional(), 
/**Optional message describing the current state*/
"stateMessage": z.string().nullable().describe("Optional message describing the current state").optional(), 
/**Whether the connector is healthy*/
"isHealthy": z.boolean().describe("Whether the connector is healthy").optional(), 
/**When this status was queried*/
"queriedAt": z.string().datetime({ offset: true }).describe("When this status was queried").optional() }).strict().describe("Response model for connector sync status");
export type ConnectorSyncStatus = z.infer<typeof ConnectorSyncStatusSchema>;

export const CreateStateSpanRequestSchema = z.object({ "category": z.any().optional(), "state": z.string().nullable().optional(), "startMills": z.number().int().optional(), "endMills": z.number().int().nullable().optional(), "source": z.string().nullable().optional(), "metadata": z.record(z.any()).nullable().optional(), "originalId": z.string().nullable().optional() }).strict();
export type CreateStateSpanRequest = z.infer<typeof CreateStateSpanRequestSchema>;

export const UpdateStateSpanRequestSchema = z.object({ "category": z.any().nullable().optional(), "state": z.string().nullable().optional(), "startMills": z.number().int().nullable().optional(), "endMills": z.number().int().nullable().optional(), "source": z.string().nullable().optional(), "metadata": z.record(z.any()).nullable().optional() }).strict();
export type UpdateStateSpanRequest = z.infer<typeof UpdateStateSpanRequestSchema>;

export const StatusResponseSchema = z.object({ "status": z.string().optional(), "name": z.string().nullable().optional(), "version": z.string().nullable().optional(), "apiVersion": z.string().nullable().optional(), "serverTime": z.string().datetime({ offset: true }).optional(), "serverTimeEpoch": z.number().int().optional(), "enabled": z.array(z.string()).nullable().optional(), "apiEnabled": z.boolean().optional(), "roles": z.array(z.string()).nullable().optional(), "settings": z.record(z.any()).nullable().optional(), "extendedSettings": z.record(z.any()).nullable().optional(), "careportalEnabled": z.boolean().nullable().optional(), "head": z.string().nullable().optional() }).strict();
export type StatusResponse = z.infer<typeof StatusResponseSchema>;

export const SystemEventSchema = z.object({ "id": z.string().nullable().optional(), "eventType": z.any().optional(), "category": z.any().optional(), "code": z.string().nullable().optional(), "description": z.string().nullable().optional(), "mills": z.number().int().optional(), "source": z.string().nullable().optional(), "metadata": z.record(z.any()).nullable().optional(), "originalId": z.string().nullable().optional(), "createdAt": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type SystemEvent = z.infer<typeof SystemEventSchema>;

export const SystemEventTypeSchema = z.enum(["Alarm","Hazard","Warning","Info"]);
export type SystemEventType = z.infer<typeof SystemEventTypeSchema>;

export const SystemEventCategorySchema = z.enum(["Pump","Cgm","Connectivity"]);
export type SystemEventCategory = z.infer<typeof SystemEventCategorySchema>;

export const CreateSystemEventRequestSchema = z.object({ "eventType": z.any().optional(), "category": z.any().optional(), "code": z.string().nullable().optional(), "description": z.string().nullable().optional(), "mills": z.number().int().optional(), "source": z.string().nullable().optional(), "metadata": z.record(z.any()).nullable().optional(), "originalId": z.string().nullable().optional() }).strict();
export type CreateSystemEventRequest = z.infer<typeof CreateSystemEventRequestSchema>;

export const TrackerAlertDtoSchema = z.object({ "instanceId": z.string().optional(), "definitionId": z.string().optional(), "thresholdId": z.string().optional(), "trackerName": z.string().optional(), "urgency": z.any().optional(), "message": z.string().optional(), "pushEnabled": z.boolean().optional(), "audioEnabled": z.boolean().optional(), "audioSound": z.string().nullable().optional(), "vibrateEnabled": z.boolean().optional() }).strict().describe("DTO for tracker alerts returned to the frontend");
export type TrackerAlertDto = z.infer<typeof TrackerAlertDtoSchema>;

export const NotificationUrgencySchema = z.enum(["Info","Warn","Hazard","Urgent"]);
export type NotificationUrgency = z.infer<typeof NotificationUrgencySchema>;

export const TrackerDefinitionDtoSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "description": z.string().nullable().optional(), "category": z.any().optional(), "icon": z.string().optional(), "triggerEventTypes": z.array(z.string()).optional(), "triggerNotesContains": z.string().nullable().optional(), "lifespanHours": z.number().int().nullable().optional(), "notificationThresholds": z.array(z.any()).optional(), "isFavorite": z.boolean().optional(), 
/**Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent*/
"dashboardVisibility": z.any().describe("Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent").optional(), 
/**Visibility level for this tracker (Public, Private, RoleRestricted)*/
"visibility": z.any().describe("Visibility level for this tracker (Public, Private, RoleRestricted)").optional(), 
/**Event type to create when tracker is started (for Nightscout compatibility)*/
"startEventType": z.string().nullable().describe("Event type to create when tracker is started (for Nightscout compatibility)").optional(), 
/**Event type to create when tracker is completed (for Nightscout compatibility)*/
"completionEventType": z.string().nullable().describe("Event type to create when tracker is completed (for Nightscout compatibility)").optional(), "createdAt": z.string().datetime({ offset: true }).optional(), "updatedAt": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type TrackerDefinitionDto = z.infer<typeof TrackerDefinitionDtoSchema>;

export const TrackerCategorySchema = z.enum(["Consumable","Reservoir","Appointment","Reminder","Custom","Sensor","Cannula","Battery"]);
export type TrackerCategory = z.infer<typeof TrackerCategorySchema>;

export const NotificationThresholdDtoSchema = z.object({ "id": z.string().nullable().optional(), "urgency": z.any().optional(), "hours": z.number().int().optional(), "description": z.string().nullable().optional(), "displayOrder": z.number().int().optional(), "pushEnabled": z.boolean().optional(), "audioEnabled": z.boolean().optional(), "audioSound": z.string().nullable().optional(), "vibrateEnabled": z.boolean().optional(), "repeatIntervalMins": z.number().int().optional(), "maxRepeats": z.number().int().optional(), "respectQuietHours": z.boolean().optional() }).strict();
export type NotificationThresholdDto = z.infer<typeof NotificationThresholdDtoSchema>;

export const DashboardVisibilitySchema = z.enum(["Off","Always","Info","Warn","Hazard","Urgent"]);
export type DashboardVisibility = z.infer<typeof DashboardVisibilitySchema>;

export const TrackerVisibilitySchema = z.enum(["Public","Private","RoleRestricted"]);
export type TrackerVisibility = z.infer<typeof TrackerVisibilitySchema>;

export const CreateTrackerDefinitionRequestSchema = z.object({ "name": z.string().min(1), "description": z.string().nullable().optional(), "category": z.any().optional(), "icon": z.string().nullable().optional(), "triggerEventTypes": z.array(z.string()).nullable().optional(), "triggerNotesContains": z.string().nullable().optional(), "lifespanHours": z.number().int().nullable().optional(), "notificationThresholds": z.array(z.any()).nullable().optional(), "isFavorite": z.boolean().optional(), 
/**Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent*/
"dashboardVisibility": z.any().describe("Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent").optional(), 
/**Visibility level for this tracker (Public, Private, RoleRestricted)*/
"visibility": z.any().describe("Visibility level for this tracker (Public, Private, RoleRestricted)").optional(), 
/**Event type to create when tracker is started (for Nightscout compatibility)*/
"startEventType": z.string().nullable().describe("Event type to create when tracker is started (for Nightscout compatibility)").optional(), 
/**Event type to create when tracker is completed (for Nightscout compatibility)*/
"completionEventType": z.string().nullable().describe("Event type to create when tracker is completed (for Nightscout compatibility)").optional() }).strict();
export type CreateTrackerDefinitionRequest = z.infer<typeof CreateTrackerDefinitionRequestSchema>;

export const CreateNotificationThresholdRequestSchema = z.object({ "urgency": z.any().optional(), "hours": z.number().int().optional(), "description": z.string().nullable().optional(), "displayOrder": z.number().int().optional(), "pushEnabled": z.boolean().optional(), "audioEnabled": z.boolean().optional(), "audioSound": z.string().nullable().optional(), "vibrateEnabled": z.boolean().optional(), "repeatIntervalMins": z.number().int().optional(), "maxRepeats": z.number().int().optional(), "respectQuietHours": z.boolean().optional() }).strict();
export type CreateNotificationThresholdRequest = z.infer<typeof CreateNotificationThresholdRequestSchema>;

export const UpdateTrackerDefinitionRequestSchema = z.object({ "name": z.string().nullable().optional(), "description": z.string().nullable().optional(), "category": z.any().nullable().optional(), "icon": z.string().nullable().optional(), "triggerEventTypes": z.array(z.string()).nullable().optional(), "triggerNotesContains": z.string().nullable().optional(), "lifespanHours": z.number().int().nullable().optional(), "notificationThresholds": z.array(z.any()).nullable().optional(), "isFavorite": z.boolean().nullable().optional(), 
/**Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent*/
"dashboardVisibility": z.any().nullable().describe("Dashboard visibility: Off, Always, Info, Warn, Hazard, Urgent").optional(), 
/**Visibility level for this tracker (Public, Private, RoleRestricted)*/
"visibility": z.any().nullable().describe("Visibility level for this tracker (Public, Private, RoleRestricted)").optional(), 
/**Event type to create when tracker is started (for Nightscout compatibility)*/
"startEventType": z.string().nullable().describe("Event type to create when tracker is started (for Nightscout compatibility)").optional(), 
/**Event type to create when tracker is completed (for Nightscout compatibility)*/
"completionEventType": z.string().nullable().describe("Event type to create when tracker is completed (for Nightscout compatibility)").optional() }).strict();
export type UpdateTrackerDefinitionRequest = z.infer<typeof UpdateTrackerDefinitionRequestSchema>;

export const TrackerInstanceDtoSchema = z.object({ "id": z.string().optional(), "definitionId": z.string().optional(), "definitionName": z.string().optional(), "category": z.any().optional(), "icon": z.string().optional(), "startedAt": z.string().datetime({ offset: true }).optional(), "completedAt": z.string().datetime({ offset: true }).nullable().optional(), "expectedEndAt": z.string().datetime({ offset: true }).nullable().optional(), "startNotes": z.string().nullable().optional(), "completionNotes": z.string().nullable().optional(), "completionReason": z.any().nullable().optional(), "ageHours": z.number().optional(), "isActive": z.boolean().optional(), "lastAckedAt": z.string().datetime({ offset: true }).nullable().optional(), "ackSnoozeMins": z.number().int().nullable().optional() }).strict();
export type TrackerInstanceDto = z.infer<typeof TrackerInstanceDtoSchema>;

export const CompletionReasonSchema = z.enum(["Completed","Expired","Other","Failed","FellOff","ReplacedEarly","Empty","Refilled","Attended","Rescheduled","Cancelled","Missed"]);
export type CompletionReason = z.infer<typeof CompletionReasonSchema>;

export const StartTrackerInstanceRequestSchema = z.object({ "definitionId": z.string().min(1), "startNotes": z.string().nullable().optional(), "startTreatmentId": z.string().nullable().optional(), 
/**Optional custom start time for backdating. Defaults to now if not provided.*/
"startedAt": z.string().datetime({ offset: true }).nullable().describe("Optional custom start time for backdating. Defaults to now if not provided.").optional() }).strict();
export type StartTrackerInstanceRequest = z.infer<typeof StartTrackerInstanceRequestSchema>;

export const CompleteTrackerInstanceRequestSchema = z.object({ "reason": z.any(), "completionNotes": z.string().nullable().optional(), "completeTreatmentId": z.string().nullable().optional(), 
/**Optional custom completion time for backdating. Defaults to now if not provided.*/
"completedAt": z.string().datetime({ offset: true }).nullable().describe("Optional custom completion time for backdating. Defaults to now if not provided.").optional() }).strict();
export type CompleteTrackerInstanceRequest = z.infer<typeof CompleteTrackerInstanceRequestSchema>;

export const AckTrackerRequestSchema = z.object({ "snoozeMins": z.number().int().optional(), "global": z.boolean().optional() }).strict();
export type AckTrackerRequest = z.infer<typeof AckTrackerRequestSchema>;

export const TrackerPresetDtoSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "definitionId": z.string().optional(), "definitionName": z.string().optional(), "defaultStartNotes": z.string().nullable().optional(), "createdAt": z.string().datetime({ offset: true }).optional() }).strict();
export type TrackerPresetDto = z.infer<typeof TrackerPresetDtoSchema>;

export const CreateTrackerPresetRequestSchema = z.object({ "name": z.string().min(1), "definitionId": z.string().min(1), "defaultStartNotes": z.string().nullable().optional() }).strict();
export type CreateTrackerPresetRequest = z.infer<typeof CreateTrackerPresetRequestSchema>;

export const ApplyPresetRequestSchema = z.object({ "overrideNotes": z.string().nullable().optional() }).strict();
export type ApplyPresetRequest = z.infer<typeof ApplyPresetRequestSchema>;

export const TreatmentFoodBreakdownSchema = z.object({ "treatmentId": z.string().optional(), "foods": z.array(z.any()).optional(), "isAttributed": z.boolean().optional(), "attributedCarbs": z.number().optional(), "unspecifiedCarbs": z.number().optional() }).strict();
export type TreatmentFoodBreakdown = z.infer<typeof TreatmentFoodBreakdownSchema>;

export const TreatmentFoodSchema = z.object({ "id": z.string().optional(), "treatmentId": z.string().optional(), "foodId": z.string().nullable().optional(), "portions": z.number().optional(), "carbs": z.number().optional(), "timeOffsetMinutes": z.number().int().optional(), "note": z.string().nullable().optional(), "foodName": z.string().nullable().optional(), "carbsPerPortion": z.number().nullable().optional() }).strict();
export type TreatmentFood = z.infer<typeof TreatmentFoodSchema>;

export const TreatmentFoodRequestSchema = z.object({ "foodId": z.string().nullable().optional(), "portions": z.number().nullable().optional(), "carbs": z.number().nullable().optional(), "timeOffsetMinutes": z.number().int().nullable().optional(), "note": z.string().nullable().optional(), "inputMode": z.any().nullable().optional() }).strict();
export type TreatmentFoodRequest = z.infer<typeof TreatmentFoodRequestSchema>;

export const TreatmentFoodInputModeSchema = z.union([z.literal(0), z.literal(1)]);
export type TreatmentFoodInputMode = z.infer<typeof TreatmentFoodInputModeSchema>;

export const MealTreatmentSchema = z.object({ "treatment": z.any().optional(), "foods": z.array(z.any()).optional(), "isAttributed": z.boolean().optional(), "attributedCarbs": z.number().optional(), "unspecifiedCarbs": z.number().optional() }).strict();
export type MealTreatment = z.infer<typeof MealTreatmentSchema>;

export const UISettingsConfigurationSchema = z.object({ "devices": z.any().optional(), "algorithm": z.any().optional(), "features": z.any().optional(), "notifications": z.any().optional(), "services": z.any().optional() }).strict();
export type UISettingsConfiguration = z.infer<typeof UISettingsConfigurationSchema>;

export const DeviceSettingsSchema = z.object({ "connectedDevices": z.array(z.any()).optional(), "autoConnect": z.boolean().optional(), "showRawData": z.boolean().optional(), "uploadEnabled": z.boolean().optional(), "cgmConfiguration": z.any().optional() }).strict();
export type DeviceSettings = z.infer<typeof DeviceSettingsSchema>;

export const ConnectedDeviceSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "type": z.string().optional(), "status": z.string().optional(), "battery": z.number().int().nullable().optional(), "lastSync": z.string().datetime({ offset: true }).nullable().optional(), "serialNumber": z.string().nullable().optional() }).strict();
export type ConnectedDevice = z.infer<typeof ConnectedDeviceSchema>;

export const CgmConfigurationSchema = z.object({ "dataSourcePriority": z.string().optional(), "sensorWarmupHours": z.number().int().optional() }).strict();
export type CgmConfiguration = z.infer<typeof CgmConfigurationSchema>;

export const AlgorithmSettingsSchema = z.object({ "prediction": z.any().optional(), "autosens": z.any().optional(), "carbAbsorption": z.any().optional(), "loop": z.any().optional(), "safetyLimits": z.any().optional() }).strict();
export type AlgorithmSettings = z.infer<typeof AlgorithmSettingsSchema>;

export const PredictionSettingsSchema = z.object({ "enabled": z.boolean().optional(), "minutes": z.number().int().optional(), "model": z.string().optional() }).strict();
export type PredictionSettings = z.infer<typeof PredictionSettingsSchema>;

export const AutosensSettingsSchema = z.object({ "enabled": z.boolean().optional(), "min": z.number().optional(), "max": z.number().optional() }).strict();
export type AutosensSettings = z.infer<typeof AutosensSettingsSchema>;

export const CarbAbsorptionSettingsSchema = z.object({ "defaultMinutes": z.number().int().optional(), "minRateGramsPerHour": z.number().int().optional() }).strict();
export type CarbAbsorptionSettings = z.infer<typeof CarbAbsorptionSettingsSchema>;

export const LoopSettingsSchema = z.object({ "enabled": z.boolean().optional(), "mode": z.string().optional(), "maxBasalRate": z.number().optional(), "maxBolus": z.number().optional(), "smbEnabled": z.boolean().optional(), "uamEnabled": z.boolean().optional() }).strict();
export type LoopSettings = z.infer<typeof LoopSettingsSchema>;

export const SafetyLimitsSchema = z.object({ "maxIOB": z.number().optional(), "maxDailyBasalMultiplier": z.number().optional() }).strict();
export type SafetyLimits = z.infer<typeof SafetyLimitsSchema>;

export const FeatureSettingsSchema = z.object({ "display": z.any().optional(), "widgets": z.array(z.any()).optional(), "plugins": z.record(z.any()).optional(), "battery": z.any().optional(), "trackerPills": z.any().optional() }).strict();
export type FeatureSettings = z.infer<typeof FeatureSettingsSchema>;

export const DisplaySettingsSchema = z.object({ "nightMode": z.boolean().optional(), "theme": z.string().optional(), "timeFormat": z.string().optional(), "units": z.string().optional(), "showRawBG": z.boolean().optional(), "focusHours": z.number().int().optional() }).strict();
export type DisplaySettings = z.infer<typeof DisplaySettingsSchema>;

export const WidgetConfigSchema = z.object({ "id": z.any().optional(), "enabled": z.boolean().optional(), "placement": z.any().optional(), "size": z.any().nullable().optional(), "settings": z.record(z.any()).nullable().optional() }).strict();
export type WidgetConfig = z.infer<typeof WidgetConfigSchema>;

export const PluginSettingsSchema = z.object({ "enabled": z.boolean().optional(), "description": z.string().optional() }).strict();
export type PluginSettings = z.infer<typeof PluginSettingsSchema>;

export const BatteryDisplaySettingsSchema = z.object({ "warnThreshold": z.number().int().optional(), "urgentThreshold": z.number().int().optional(), "enableAlerts": z.boolean().optional(), "recentMinutes": z.number().int().optional(), "showVoltage": z.boolean().optional(), "showStatistics": z.boolean().optional() }).strict();
export type BatteryDisplaySettings = z.infer<typeof BatteryDisplaySettingsSchema>;

export const TrackerPillsSettingsSchema = z.object({ "enabled": z.boolean().optional(), "visibility": z.string().optional() }).strict();
export type TrackerPillsSettings = z.infer<typeof TrackerPillsSettingsSchema>;

export const NotificationSettingsSchema = z.object({ "alarmConfiguration": z.any().optional() }).strict();
export type NotificationSettings = z.infer<typeof NotificationSettingsSchema>;

export const UserAlarmConfigurationSchema = z.object({ "version": z.number().int().optional(), "enabled": z.boolean().optional(), "soundEnabled": z.boolean().optional(), "vibrationEnabled": z.boolean().optional(), "globalVolume": z.number().int().optional(), "profiles": z.array(z.any()).optional(), "quietHours": z.any().optional(), "customSounds": z.array(z.any()).optional(), "emergencyContacts": z.array(z.any()).optional(), "channels": z.any().optional() }).strict();
export type UserAlarmConfiguration = z.infer<typeof UserAlarmConfigurationSchema>;

export const AlarmProfileConfigurationSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "description": z.string().nullable().optional(), "enabled": z.boolean().optional(), "alarmType": z.any().optional(), "threshold": z.number().int().optional(), "thresholdHigh": z.number().nullable().optional(), "forecastLeadTimeMinutes": z.number().int().nullable().optional(), "persistenceMinutes": z.number().int().optional(), "audio": z.any().optional(), "vibration": z.any().optional(), "visual": z.any().optional(), "snooze": z.any().optional(), "reraise": z.any().optional(), "smartSnooze": z.any().optional(), "schedule": z.any().optional(), "priority": z.any().optional(), "overrideQuietHours": z.boolean().optional(), "displayOrder": z.number().int().optional(), "createdAt": z.string().datetime({ offset: true }).optional(), "updatedAt": z.string().datetime({ offset: true }).optional() }).strict();
export type AlarmProfileConfiguration = z.infer<typeof AlarmProfileConfigurationSchema>;

export const AlarmTriggerTypeSchema = z.enum(["High","Low","UrgentHigh","UrgentLow","RisingFast","FallingFast","StaleData","ForecastLow","Custom"]);
export type AlarmTriggerType = z.infer<typeof AlarmTriggerTypeSchema>;

export const AlarmAudioSettingsSchema = z.object({ "enabled": z.boolean().optional(), "soundId": z.string().optional(), "customSoundUrl": z.string().nullable().optional(), "ascendingVolume": z.boolean().optional(), "startVolume": z.number().int().optional(), "maxVolume": z.number().int().optional(), "ascendDurationSeconds": z.number().int().optional(), "repeatCount": z.number().int().optional() }).strict();
export type AlarmAudioSettings = z.infer<typeof AlarmAudioSettingsSchema>;

export const AlarmVibrationSettingsSchema = z.object({ "enabled": z.boolean().optional(), "pattern": z.string().optional(), "customPattern": z.array(z.number().int()).nullable().optional() }).strict();
export type AlarmVibrationSettings = z.infer<typeof AlarmVibrationSettingsSchema>;

export const AlarmVisualSettingsSchema = z.object({ "screenFlash": z.boolean().optional(), "flashColor": z.string().optional(), "flashIntervalMs": z.number().int().optional(), "persistentBanner": z.boolean().optional(), "wakeScreen": z.boolean().optional() }).strict();
export type AlarmVisualSettings = z.infer<typeof AlarmVisualSettingsSchema>;

export const AlarmSnoozeSettingsSchema = z.object({ "defaultMinutes": z.number().int().optional(), "options": z.array(z.number().int()).optional(), "maxMinutes": z.number().int().optional(), "maxSnoozeCount": z.number().int().nullable().optional() }).strict();
export type AlarmSnoozeSettings = z.infer<typeof AlarmSnoozeSettingsSchema>;

export const AlarmReraiseSettingsSchema = z.object({ "enabled": z.boolean().optional(), "intervalMinutes": z.number().int().optional(), "escalate": z.boolean().optional(), "escalationVolumeStep": z.number().int().optional() }).strict();
export type AlarmReraiseSettings = z.infer<typeof AlarmReraiseSettingsSchema>;

export const SmartSnoozeSettingsSchema = z.object({ "enabled": z.boolean().optional(), "extendWhenTrendingCorrect": z.boolean().optional(), "minDeltaThreshold": z.number().int().optional(), "extensionMinutes": z.number().int().optional(), "maxTotalMinutes": z.number().int().optional() }).strict();
export type SmartSnoozeSettings = z.infer<typeof SmartSnoozeSettingsSchema>;

export const AlarmScheduleSettingsSchema = z.object({ "enabled": z.boolean().optional(), "activeRanges": z.array(z.any()).optional(), "activeDays": z.array(z.number().int()).nullable().optional(), "timezone": z.string().nullable().optional() }).strict();
export type AlarmScheduleSettings = z.infer<typeof AlarmScheduleSettingsSchema>;

export const TimeRangeSchema = z.object({ "startTime": z.string().optional(), "endTime": z.string().optional() }).strict();
export type TimeRange = z.infer<typeof TimeRangeSchema>;

export const AlarmPrioritySchema = z.enum(["Low","Normal","High","Critical"]);
export type AlarmPriority = z.infer<typeof AlarmPrioritySchema>;

export const QuietHoursConfigurationSchema = z.object({ "enabled": z.boolean().optional(), "startTime": z.string().optional(), "endTime": z.string().optional(), "allowCritical": z.boolean().optional(), "reduceVolume": z.boolean().optional(), "quietVolume": z.number().int().optional() }).strict();
export type QuietHoursConfiguration = z.infer<typeof QuietHoursConfigurationSchema>;

export const CustomSoundReferenceSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "url": z.string().optional(), "durationSeconds": z.number().int().nullable().optional(), "uploadedAt": z.string().datetime({ offset: true }).optional() }).strict();
export type CustomSoundReference = z.infer<typeof CustomSoundReferenceSchema>;

export const EmergencyContactConfigSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "phone": z.string().nullable().optional(), "email": z.string().nullable().optional(), "criticalOnly": z.boolean().optional(), "delayMinutes": z.number().int().optional(), "enabled": z.boolean().optional() }).strict();
export type EmergencyContactConfig = z.infer<typeof EmergencyContactConfigSchema>;

export const NotificationChannelsConfigSchema = z.object({ "push": z.any().optional(), "email": z.any().optional(), "sms": z.any().optional(), "pushover": z.any().nullable().optional() }).strict();
export type NotificationChannelsConfig = z.infer<typeof NotificationChannelsConfigSchema>;

export const ChannelConfigSchema = z.object({ "enabled": z.boolean().optional(), "minPriority": z.any().optional() }).strict();
export type ChannelConfig = z.infer<typeof ChannelConfigSchema>;

export const PushoverChannelConfigSchema = z.intersection(z.any(), z.object({ "userKey": z.string().nullable().optional(), "apiToken": z.string().nullable().optional() }).strict());
export type PushoverChannelConfig = z.infer<typeof PushoverChannelConfigSchema>;

export const ServicesSettingsSchema = z.object({ "connectedServices": z.array(z.any()).optional(), "availableServices": z.array(z.any()).optional(), "syncSettings": z.any().optional() }).strict();
export type ServicesSettings = z.infer<typeof ServicesSettingsSchema>;

export const ConnectedServiceSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "type": z.string().optional(), "description": z.string().optional(), "status": z.string().optional(), "lastSync": z.string().datetime({ offset: true }).nullable().optional(), "icon": z.string().optional(), "configured": z.boolean().optional(), "enabled": z.boolean().optional() }).strict();
export type ConnectedService = z.infer<typeof ConnectedServiceSchema>;

export const AvailableServiceSchema = z.object({ "id": z.string().optional(), "name": z.string().optional(), "type": z.string().optional(), "description": z.string().optional(), "icon": z.string().optional() }).strict();
export type AvailableService = z.infer<typeof AvailableServiceSchema>;

export const SyncSettingsSchema = z.object({ "autoSync": z.boolean().optional(), "syncOnAppOpen": z.boolean().optional(), "backgroundRefresh": z.boolean().optional() }).strict();
export type SyncSettings = z.infer<typeof SyncSettingsSchema>;

export const V3CollectionResponseOfObjectSchema = z.object({ "status": z.string().optional(), "data": z.array(z.any()).optional(), "total": z.number().int().nullable().optional(), "skip": z.number().int().nullable().optional(), "limit": z.number().int().nullable().optional(), "meta": z.any().optional() }).strict();
export type V3CollectionResponseOfObject = z.infer<typeof V3CollectionResponseOfObjectSchema>;

export const V3ResponseMetadataSchema = z.object({ "timestamp": z.string().datetime({ offset: true }).optional(), "version": z.string().optional(), "executionTime": z.number().int().nullable().optional(), "requestId": z.string().nullable().optional(), "eTag": z.string().nullable().optional(), "lastModified": z.string().datetime({ offset: true }).nullable().optional(), "totalCount": z.number().int().optional(), "limit": z.number().int().optional(), "offset": z.number().int().optional() }).strict();
export type V3ResponseMetadata = z.infer<typeof V3ResponseMetadataSchema>;

export const V3ErrorResponseSchema = z.object({ "status": z.string().optional(), "message": z.string().optional(), "code": z.string().nullable().optional(), "timestamp": z.string().datetime({ offset: true }).nullable().optional(), "path": z.string().nullable().optional(), "details": z.record(z.any()).nullable().optional() }).strict();
export type V3ErrorResponse = z.infer<typeof V3ErrorResponseSchema>;

export const DeviceStatusSchema = z.intersection(z.any(), z.object({ "_id": z.string().nullable().optional(), "mills": z.number().int().optional(), "created_at": z.string().nullable().optional(), "utcOffset": z.number().int().nullable().optional(), "device": z.string().optional(), "isCharging": z.boolean().nullable().optional(), "uploader": z.any().nullable().optional(), "pump": z.any().nullable().optional(), "openaps": z.any().nullable().optional(), "loop": z.any().nullable().optional(), "xdripjs": z.any().nullable().optional(), "radioAdapter": z.any().nullable().optional(), "connect": z.any().nullable().optional(), "override": z.any().nullable().optional(), "cgm": z.any().nullable().optional(), "meter": z.any().nullable().optional(), "insulinPen": z.any().nullable().optional(), "mmtune": z.any().nullable().optional() }).strict());
export type DeviceStatus = z.infer<typeof DeviceStatusSchema>;

export const UploaderStatusSchema = z.object({ "battery": z.number().int().nullable().optional(), "batteryVoltage": z.number().nullable().optional(), "temperature": z.number().nullable().optional(), "name": z.string().nullable().optional(), "type": z.string().nullable().optional() }).strict();
export type UploaderStatus = z.infer<typeof UploaderStatusSchema>;

export const PumpStatusSchema = z.object({ "battery": z.any().nullable().optional(), "reservoir": z.number().nullable().optional(), "clock": z.string().nullable().optional(), "status": z.any().nullable().optional(), "iob": z.any().nullable().optional(), "reservoir_display_override": z.string().nullable().optional(), "reservoir_level_override": z.any().nullable().optional(), "manufacturer": z.string().nullable().optional(), "model": z.string().nullable().optional(), "extended": z.record(z.any()).nullable().optional() }).strict();
export type PumpStatus = z.infer<typeof PumpStatusSchema>;

export const PumpBatterySchema = z.object({ "percent": z.number().int().nullable().optional(), "voltage": z.number().nullable().optional() }).strict();
export type PumpBattery = z.infer<typeof PumpBatterySchema>;

export const PumpStatusDetailsSchema = z.object({ "status": z.string().nullable().optional(), "bolusing": z.boolean().nullable().optional(), "suspended": z.boolean().nullable().optional() }).strict();
export type PumpStatusDetails = z.infer<typeof PumpStatusDetailsSchema>;

export const PumpIobSchema = z.object({ "timestamp": z.string().nullable().optional(), "bolusiob": z.number().nullable().optional(), "basaliob": z.number().nullable().optional(), "iob": z.number().nullable().optional() }).strict();
export type PumpIob = z.infer<typeof PumpIobSchema>;

export const PumpAlertLevelSchema = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)]);
export type PumpAlertLevel = z.infer<typeof PumpAlertLevelSchema>;

export const OpenApsStatusSchema = z.object({ "suggested": z.any().nullable().optional(), "enacted": z.any().nullable().optional(), "iob": z.any().nullable().optional(), "cob": z.number().nullable().optional() }).strict();
export type OpenApsStatus = z.infer<typeof OpenApsStatusSchema>;

export const LoopStatusSchema = z.object({ "iob": z.any().nullable().optional(), "cob": z.any().nullable().optional(), "predicted": z.any().nullable().optional(), "recommendedBolus": z.number().nullable().optional(), "name": z.string().nullable().optional(), "version": z.string().nullable().optional(), "timestamp": z.string().nullable().optional(), "recommended": z.any().nullable().optional(), "enacted": z.any().nullable().optional(), "recommendedTempBasal": z.any().nullable().optional(), "failureReason": z.string().nullable().optional(), "rileylinks": z.array(z.any()).nullable().optional(), "automaticDoseRecommendation": z.any().nullable().optional(), "currentCorrectionRange": z.any().nullable().optional(), "forecastError": z.any().nullable().optional() }).strict();
export type LoopStatus = z.infer<typeof LoopStatusSchema>;

export const LoopIobSchema = z.object({ "timestamp": z.string().nullable().optional(), "iob": z.number().nullable().optional(), "basaliob": z.number().nullable().optional(), "netbasalinsulin": z.number().nullable().optional() }).strict();
export type LoopIob = z.infer<typeof LoopIobSchema>;

export const LoopCobSchema = z.object({ "timestamp": z.string().nullable().optional(), "cob": z.number().nullable().optional() }).strict();
export type LoopCob = z.infer<typeof LoopCobSchema>;

export const LoopPredictedSchema = z.object({ "values": z.array(z.number()).nullable().optional(), "startDate": z.string().nullable().optional() }).strict();
export type LoopPredicted = z.infer<typeof LoopPredictedSchema>;

export const LoopEnactedSchema = z.object({ "bolusVolume": z.number().nullable().optional(), "rate": z.number().nullable().optional(), "duration": z.number().int().nullable().optional(), "timestamp": z.string().nullable().optional(), "reason": z.string().nullable().optional(), "received": z.boolean().nullable().optional() }).strict();
export type LoopEnacted = z.infer<typeof LoopEnactedSchema>;

export const LoopRecommendedTempBasalSchema = z.object({ "rate": z.number().nullable().optional(), "duration": z.number().int().nullable().optional(), "timestamp": z.string().nullable().optional() }).strict();
export type LoopRecommendedTempBasal = z.infer<typeof LoopRecommendedTempBasalSchema>;

export const RileyLinkStatusSchema = z.object({ "name": z.string().nullable().optional(), "signal": z.number().nullable().optional(), "timestamp": z.string().nullable().optional(), "radioFirmware": z.string().nullable().optional(), "bleFirmware": z.string().nullable().optional(), "connected": z.boolean().nullable().optional() }).strict();
export type RileyLinkStatus = z.infer<typeof RileyLinkStatusSchema>;

export const LoopAutomaticDoseRecommendationSchema = z.object({ "bolus": z.number().nullable().optional(), "tempBasal": z.any().nullable().optional(), "timestamp": z.string().nullable().optional(), "notice": z.string().nullable().optional() }).strict();
export type LoopAutomaticDoseRecommendation = z.infer<typeof LoopAutomaticDoseRecommendationSchema>;

export const CorrectionRangeSchema = z.object({ "maxValue": z.number().nullable().optional(), "minValue": z.number().nullable().optional() }).strict();
export type CorrectionRange = z.infer<typeof CorrectionRangeSchema>;

export const XDripJsStatusSchema = z.object({ "state": z.number().int().nullable().optional(), "stateString": z.string().nullable().optional(), "voltagea": z.number().nullable().optional(), "voltageb": z.number().nullable().optional() }).strict();
export type XDripJsStatus = z.infer<typeof XDripJsStatusSchema>;

export const RadioAdapterStatusSchema = z.object({ "pumpRSSI": z.number().int().nullable().optional(), "RSSI": z.number().int().nullable().optional() }).strict();
export type RadioAdapterStatus = z.infer<typeof RadioAdapterStatusSchema>;

export const OverrideStatusSchema = z.object({ "name": z.string().nullable().optional(), "timestamp": z.string().nullable().optional(), "duration": z.number().nullable().optional(), "active": z.boolean().nullable().optional(), "multiplier": z.number().nullable().optional(), "currentCorrectionRange": z.any().nullable().optional() }).strict();
export type OverrideStatus = z.infer<typeof OverrideStatusSchema>;

export const CgmStatusSchema = z.object({ "sensorAge": z.string().nullable().optional(), "transmitterAge": z.string().nullable().optional(), "signalStrength": z.number().nullable().optional(), "calibrationStatus": z.string().nullable().optional(), "lastReading": z.string().datetime({ offset: true }).nullable().optional(), "sensorState": z.string().nullable().optional(), "sessionTimeRemaining": z.number().int().nullable().optional(), "transmitterBattery": z.number().int().nullable().optional() }).strict();
export type CgmStatus = z.infer<typeof CgmStatusSchema>;

export const MeterStatusSchema = z.object({ "batteryLevel": z.number().int().nullable().optional(), "testStripsRemaining": z.number().int().nullable().optional(), "lastReading": z.string().datetime({ offset: true }).nullable().optional(), "clockStatus": z.string().nullable().optional(), "meterModel": z.string().nullable().optional(), "memoryUsage": z.number().nullable().optional() }).strict();
export type MeterStatus = z.infer<typeof MeterStatusSchema>;

export const InsulinPenStatusSchema = z.object({ "batteryLevel": z.number().int().nullable().optional(), "cartridgeRemaining": z.number().nullable().optional(), "lastInjection": z.string().datetime({ offset: true }).nullable().optional(), "penModel": z.string().nullable().optional(), "insulinType": z.string().nullable().optional(), "needleAttached": z.boolean().nullable().optional(), "cartridgeExpiration": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type InsulinPenStatus = z.infer<typeof InsulinPenStatusSchema>;

export const OpenApsMmTuneSchema = z.object({ "scanDetails": z.array(z.array(z.any())).nullable().optional(), "setFreq": z.number().nullable().optional(), "timestamp": z.string().nullable().optional(), "usedDefault": z.boolean().nullable().optional(), "moment": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type OpenApsMmTune = z.infer<typeof OpenApsMmTuneSchema>;

export const LastModifiedResponseSchema = z.object({ "entries": z.string().datetime({ offset: true }).nullable().optional(), "treatments": z.string().datetime({ offset: true }).nullable().optional(), "profile": z.string().datetime({ offset: true }).nullable().optional(), "deviceStatus": z.string().datetime({ offset: true }).nullable().optional(), "food": z.string().datetime({ offset: true }).nullable().optional(), "settings": z.string().datetime({ offset: true }).nullable().optional(), "activity": z.string().datetime({ offset: true }).nullable().optional(), "serverTime": z.string().datetime({ offset: true }).optional(), "additional": z.record(z.string().datetime({ offset: true })).optional() }).strict();
export type LastModifiedResponse = z.infer<typeof LastModifiedResponseSchema>;

export const ProfileSchema = z.object({ "_id": z.string().nullable().optional(), "defaultProfile": z.string().optional(), "startDate": z.string().optional(), "mills": z.number().int().optional(), "created_at": z.string().nullable().optional(), "units": z.string().optional(), "store": z.record(z.any()).optional(), "enteredBy": z.string().nullable().optional(), "loopSettings": z.any().nullable().optional(), "isExternallyManaged": z.boolean().optional() }).strict();
export type Profile = z.infer<typeof ProfileSchema>;

export const ProfileDataSchema = z.object({ "dia": z.number().optional(), "carbs_hr": z.number().int().optional(), "delay": z.number().int().optional(), "timezone": z.string().nullable().optional(), "units": z.string().nullable().optional(), "perGIvalues": z.boolean().nullable().optional(), "carbs_hr_high": z.number().int().nullable().optional(), "carbs_hr_medium": z.number().int().nullable().optional(), "carbs_hr_low": z.number().int().nullable().optional(), "delay_high": z.number().int().nullable().optional(), "delay_medium": z.number().int().nullable().optional(), "delay_low": z.number().int().nullable().optional(), "basal": z.array(z.any()).optional(), "carbratio": z.array(z.any()).optional(), "sens": z.array(z.any()).optional(), "target_low": z.array(z.any()).optional(), "target_high": z.array(z.any()).optional() }).strict();
export type ProfileData = z.infer<typeof ProfileDataSchema>;

export const TimeValueSchema = z.object({ "time": z.string().optional(), "value": z.number().optional(), "timeAsSeconds": z.number().int().nullable().optional() }).strict();
export type TimeValue = z.infer<typeof TimeValueSchema>;

export const LoopProfileSettingsSchema = z.object({ "deviceToken": z.string().nullable().optional(), "bundleIdentifier": z.string().nullable().optional(), "overridePresets": z.array(z.any()).nullable().optional(), "dosingEnabled": z.boolean().nullable().optional(), "minimumBGGuard": z.number().nullable().optional(), "preMealTargetRange": z.any().nullable().optional(), "workoutTargetRange": z.any().nullable().optional(), "maximumBolus": z.number().nullable().optional(), "maximumBasalRatePerHour": z.number().nullable().optional(), "dosingStrategy": z.string().nullable().optional(), "scheduleOverride": z.any().nullable().optional() }).strict();
export type LoopProfileSettings = z.infer<typeof LoopProfileSettingsSchema>;

export const LoopOverridePresetSchema = z.object({ "name": z.string().nullable().optional(), "symbol": z.string().nullable().optional(), "duration": z.number().nullable().optional(), "targetRange": z.any().nullable().optional(), "insulinNeedsScaleFactor": z.number().nullable().optional() }).strict();
export type LoopOverridePreset = z.infer<typeof LoopOverridePresetSchema>;

export const LoopTargetRangeSchema = z.object({ "minValue": z.number().nullable().optional(), "maxValue": z.number().nullable().optional() }).strict();
export type LoopTargetRange = z.infer<typeof LoopTargetRangeSchema>;

export const SettingsSchema = z.intersection(z.any(), z.object({ "_id": z.string().nullable().optional(), "key": z.string().min(1), "value": z.any().nullable().optional(), "created_at": z.string().nullable().optional(), "mills": z.number().int().optional(), "utcOffset": z.number().int().nullable().optional(), "srvCreated": z.string().datetime({ offset: true }).nullable().optional(), "srvModified": z.string().datetime({ offset: true }).nullable().optional(), "app": z.string().nullable().optional(), "device": z.string().nullable().optional(), "enteredBy": z.string().nullable().optional(), "version": z.number().int().nullable().optional(), "isActive": z.boolean().optional(), "notes": z.string().nullable().optional() }).strict());
export type Settings = z.infer<typeof SettingsSchema>;

export const V3StatusResponseSchema = z.object({ "status": z.string().optional(), "name": z.string().optional(), "version": z.string().optional(), "serverTime": z.string().datetime({ offset: true }).optional(), "apiEnabled": z.boolean().optional(), "careportalEnabled": z.boolean().optional(), "head": z.string().optional(), "settings": z.record(z.any()).optional(), "extended": z.any().optional() }).strict();
export type V3StatusResponse = z.infer<typeof V3StatusResponseSchema>;

export const ExtendedStatusInfoSchema = z.object({ "authorization": z.any().optional(), "permissions": z.record(z.boolean()).optional(), "uptimeMs": z.number().int().optional(), "collections": z.array(z.string()).optional(), "apiVersions": z.record(z.boolean()).optional() }).strict();
export type ExtendedStatusInfo = z.infer<typeof ExtendedStatusInfoSchema>;

export const AuthorizationInfoSchema = z.object({ "isAuthorized": z.boolean().optional(), "scope": z.array(z.string()).optional(), "subject": z.string().nullable().optional(), "roles": z.array(z.string()).optional() }).strict();
export type AuthorizationInfo = z.infer<typeof AuthorizationInfoSchema>;

export const VersionResponseSchema = z.object({ "version": z.string().optional(), "name": z.string().optional(), "serverTime": z.string().datetime({ offset: true }).optional(), "head": z.string().optional(), "build": z.string().optional(), "apiCompatibility": z.string().optional() }).strict();
export type VersionResponse = z.infer<typeof VersionResponseSchema>;

export const DDataResponseSchema = z.object({ "devicestatus": z.array(z.any()).optional(), "sgvs": z.array(z.any()).optional(), "cals": z.array(z.any()).optional(), "profiles": z.array(z.any()).optional(), "mbgs": z.array(z.any()).optional(), "food": z.array(z.any()).optional(), "treatments": z.array(z.any()).optional(), "dbstats": z.any().optional() }).strict();
export type DDataResponse = z.infer<typeof DDataResponseSchema>;

export const DbStatsSchema = z.object({ "dataSize": z.number().int().optional(), "collections": z.number().int().optional(), "indexes": z.number().int().optional() }).strict();
export type DbStats = z.infer<typeof DbStatsSchema>;

export const DDataSchema = z.object({ "sgvs": z.array(z.any()).optional(), "treatments": z.array(z.any()).optional(), "mbgs": z.array(z.any()).optional(), "cals": z.array(z.any()).optional(), "cal": z.any().nullable().optional(), "profiles": z.array(z.any()).optional(), "devicestatus": z.array(z.any()).optional(), "food": z.array(z.any()).optional(), "activity": z.array(z.any()).optional(), "dbstats": z.any().optional(), "lastUpdated": z.number().int().optional(), "inRetroMode": z.boolean().nullable().optional(), "sitechangeTreatments": z.array(z.any()).optional(), "insulinchangeTreatments": z.array(z.any()).optional(), "batteryTreatments": z.array(z.any()).optional(), "sensorTreatments": z.array(z.any()).optional(), "combobolusTreatments": z.array(z.any()).optional(), "profileTreatments": z.array(z.any()).optional(), "tempbasalTreatments": z.array(z.any()).optional(), "tempTargetTreatments": z.array(z.any()).optional() }).strict();
export type DData = z.infer<typeof DDataSchema>;

export const ActivitySchema = z.intersection(z.any(), z.object({ "_id": z.string().nullable().optional(), "created_at": z.string().nullable().optional(), "timestamp": z.number().int().nullable().optional(), "mills": z.number().int().optional(), "utcOffset": z.number().int().nullable().optional(), "type": z.string().nullable().optional(), "description": z.string().nullable().optional(), "duration": z.number().nullable().optional(), "intensity": z.string().nullable().optional(), "notes": z.string().nullable().optional(), "enteredBy": z.string().nullable().optional(), "dateString": z.string().nullable().optional(), "distance": z.number().nullable().optional(), "distanceUnits": z.string().nullable().optional(), "energy": z.number().nullable().optional(), "energyUnits": z.string().nullable().optional(), "name": z.string().nullable().optional() }).catchall(z.any()));
export type Activity = z.infer<typeof ActivitySchema>;

export const LoopNotificationResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional(), "timestamp": z.number().int().optional(), "data": z.any().nullable().optional() }).strict();
export type LoopNotificationResponse = z.infer<typeof LoopNotificationResponseSchema>;

export const LoopSendRequestSchema = z.object({ 
/**Loop notification data (matches legacy data structure)*/
"data": z.any().describe("Loop notification data (matches legacy data structure)").optional(), 
/**Loop settings from user profile containing device token and bundle ID*/
"loopSettings": z.any().describe("Loop settings from user profile containing device token and bundle ID").optional() }).strict().describe("Loop notification request model for the direct Loop endpoint\nCombines the data and loopSettings for a complete notification request");
export type LoopSendRequest = z.infer<typeof LoopSendRequestSchema>;

export const LoopNotificationDataSchema = z.object({ "eventType": z.string().optional(), "notes": z.string().nullable().optional(), "enteredBy": z.string().nullable().optional(), "reason": z.string().nullable().optional(), "reasonDisplay": z.string().nullable().optional(), "duration": z.string().nullable().optional(), "remoteCarbs": z.string().nullable().optional(), "remoteAbsorption": z.string().nullable().optional(), "remoteBolus": z.string().nullable().optional(), "otp": z.string().nullable().optional(), "created_at": z.string().nullable().optional() }).strict();
export type LoopNotificationData = z.infer<typeof LoopNotificationDataSchema>;

export const LoopSettings2Schema = z.object({ "deviceToken": z.string().nullable().optional(), "bundleIdentifier": z.string().nullable().optional() }).strict();
export type LoopSettings2 = z.infer<typeof LoopSettings2Schema>;

export const NotificationV2ResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional(), "data": z.any().nullable().optional(), "timestamp": z.number().int().optional() }).strict();
export type NotificationV2Response = z.infer<typeof NotificationV2ResponseSchema>;

export const LoopNotificationRequestSchema = z.object({ "type": z.string().optional(), "message": z.string().optional(), "title": z.string().nullable().optional(), "urgency": z.string().nullable().optional(), "sound": z.string().nullable().optional(), "group": z.string().nullable().optional(), "timestamp": z.number().int().nullable().optional(), "data": z.record(z.any()).nullable().optional(), "isAnnouncement": z.boolean().nullable().optional() }).strict();
export type LoopNotificationRequest = z.infer<typeof LoopNotificationRequestSchema>;

export const NotificationBaseSchema = z.object({ "level": z.number().int().optional(), "title": z.string().optional(), "message": z.string().optional(), "group": z.string().optional(), "timestamp": z.number().int().optional(), "plugin": z.string().nullable().optional(), "isAnnouncement": z.boolean().optional(), "debug": z.any().nullable().optional(), "count": z.number().int().optional(), "lastRecorded": z.number().int().optional(), "persistent": z.boolean().optional(), "clear": z.boolean().optional() }).strict();
export type NotificationBase = z.infer<typeof NotificationBaseSchema>;

export const SummaryResponseSchema = z.object({ "sgvs": z.array(z.any()).optional(), "treatments": z.any().optional(), "profile": z.any().nullable().optional(), "state": z.any().optional() }).strict();
export type SummaryResponse = z.infer<typeof SummaryResponseSchema>;

export const SummarySgvSchema = z.object({ "sgv": z.number().int().optional(), "mills": z.number().int().optional(), "noise": z.number().int().nullable().optional() }).strict();
export type SummarySgv = z.infer<typeof SummarySgvSchema>;

export const SummaryTreatmentsSchema = z.object({ "tempBasals": z.array(z.any()).optional(), "treatments": z.array(z.any()).optional(), "targets": z.array(z.any()).optional() }).strict();
export type SummaryTreatments = z.infer<typeof SummaryTreatmentsSchema>;

export const SummaryTempBasalSchema = z.object({ "start": z.number().int().optional(), "duration": z.number().int().optional(), "absolute": z.number().optional(), "profile": z.number().int().nullable().optional() }).strict();
export type SummaryTempBasal = z.infer<typeof SummaryTempBasalSchema>;

export const SummaryTreatmentSchema = z.object({ "mills": z.number().int().optional(), "carbs": z.number().nullable().optional(), "insulin": z.number().nullable().optional() }).strict();
export type SummaryTreatment = z.infer<typeof SummaryTreatmentSchema>;

export const SummaryTargetSchema = z.object({ "targetTop": z.number().int().optional(), "targetBottom": z.number().int().optional(), "duration": z.number().int().optional(), "mills": z.number().int().optional() }).strict();
export type SummaryTarget = z.infer<typeof SummaryTargetSchema>;

export const SummaryStateSchema = z.object({ "iob": z.number().optional(), "cob": z.number().int().optional(), "bwp": z.number().optional(), "cage": z.number().int().nullable().optional(), "sage": z.number().int().nullable().optional(), "iage": z.number().int().nullable().optional(), "bage": z.number().int().nullable().optional(), "battery": z.number().int().nullable().optional(), "calib_age": z.number().int().nullable().optional(), "sensor_expires_in": z.number().int().nullable().optional() }).strict();
export type SummaryState = z.infer<typeof SummaryStateSchema>;

export const AlexaResponseSchema = z.object({ "version": z.string().optional(), "sessionAttributes": z.record(z.any()).optional(), "response": z.any().optional() }).strict();
export type AlexaResponse = z.infer<typeof AlexaResponseSchema>;

export const AlexaResponseBodySchema = z.object({ "outputSpeech": z.any().nullable().optional(), "shouldEndSession": z.boolean().optional(), "card": z.any().nullable().optional(), "reprompt": z.any().nullable().optional() }).strict();
export type AlexaResponseBody = z.infer<typeof AlexaResponseBodySchema>;

export const AlexaOutputSpeechSchema = z.object({ "type": z.string().optional(), "text": z.string().optional(), "ssml": z.string().nullable().optional() }).strict();
export type AlexaOutputSpeech = z.infer<typeof AlexaOutputSpeechSchema>;

export const AlexaCardSchema = z.object({ "type": z.string().optional(), "title": z.string().optional(), "content": z.string().optional(), "text": z.string().nullable().optional(), "smallImageUrl": z.string().nullable().optional(), "largeImageUrl": z.string().nullable().optional() }).strict();
export type AlexaCard = z.infer<typeof AlexaCardSchema>;

export const AlexaRepromptSchema = z.object({ "outputSpeech": z.any().nullable().optional() }).strict();
export type AlexaReprompt = z.infer<typeof AlexaRepromptSchema>;

export const AlexaRequestSchema = z.object({ "version": z.string().optional(), "session": z.any().optional(), "request": z.any().optional() }).strict();
export type AlexaRequest = z.infer<typeof AlexaRequestSchema>;

export const AlexaSessionSchema = z.object({ "sessionId": z.string().optional(), "new": z.boolean().optional(), "attributes": z.record(z.any()).optional(), "user": z.any().optional() }).strict();
export type AlexaSession = z.infer<typeof AlexaSessionSchema>;

export const AlexaUserSchema = z.object({ "userId": z.string().optional() }).strict();
export type AlexaUser = z.infer<typeof AlexaUserSchema>;

export const AlexaRequestDetailsSchema = z.object({ "type": z.string().optional(), "requestId": z.string().optional(), "timestamp": z.string().datetime({ offset: true }).optional(), "intent": z.any().nullable().optional(), "locale": z.string().optional() }).strict();
export type AlexaRequestDetails = z.infer<typeof AlexaRequestDetailsSchema>;

export const AlexaIntentSchema = z.object({ "name": z.string().optional(), "slots": z.record(z.any()).optional() }).strict();
export type AlexaIntent = z.infer<typeof AlexaIntentSchema>;

export const AlexaSlotSchema = z.object({ "name": z.string().optional(), "value": z.string().optional() }).strict();
export type AlexaSlot = z.infer<typeof AlexaSlotSchema>;

export const CountResponseSchema = z.object({ 
/**Number of records matching the query criteria*/
"count": z.number().int().describe("Number of records matching the query criteria").optional() }).strict().describe("Response object for count endpoints");
export type CountResponse = z.infer<typeof CountResponseSchema>;

export const AsyncProcessingResponseSchema = z.object({ "correlationId": z.string().optional(), "status": z.string().optional(), "statusUrl": z.string().optional(), "estimatedProcessingTime": z.string().duration().optional(), "estimatedCompletion": z.string().datetime({ offset: true }).nullable().optional() }).strict();
export type AsyncProcessingResponse = z.infer<typeof AsyncProcessingResponseSchema>;

export const IobResultSchema = z.object({ "iob": z.number().optional(), "activity": z.number().nullable().optional(), "lastBolus": z.any().nullable().optional(), "source": z.string().nullable().optional(), "device": z.string().nullable().optional(), "mills": z.number().int().nullable().optional(), "basalIob": z.number().nullable().optional(), "treatmentIob": z.number().nullable().optional(), "display": z.string().nullable().optional(), "displayLine": z.string().nullable().optional() }).strict();
export type IobResult = z.infer<typeof IobResultSchema>;

export const HourlyIobResponseSchema = z.object({ "startTime": z.number().int().optional(), "endTime": z.number().int().optional(), "intervalMinutes": z.number().int().optional(), "hours": z.number().int().optional(), "data": z.array(z.any()).optional() }).strict().describe("Response model for hourly IOB breakdown");
export type HourlyIobResponse = z.infer<typeof HourlyIobResponseSchema>;

export const HourlyIobDataSchema = z.object({ "timeSlot": z.number().int().optional(), "hour": z.number().int().optional(), "minute": z.number().int().optional(), "timeLabel": z.string().optional(), "totalIOB": z.number().optional(), "bolusIOB": z.number().optional(), "basalIOB": z.number().optional() }).strict().describe("Individual hourly IOB data point");
export type HourlyIobData = z.infer<typeof HourlyIobDataSchema>;

export const DeviceAgeInfoSchema = z.object({ "found": z.boolean().optional(), "age": z.number().int().optional(), "days": z.number().int().optional(), "hours": z.number().int().optional(), "treatmentDate": z.number().int().nullable().optional(), "notes": z.string().nullable().optional(), "minFractions": z.number().int().optional(), "level": z.number().int().optional(), "display": z.string().optional(), "notification": z.any().nullable().optional() }).strict();
export type DeviceAgeInfo = z.infer<typeof DeviceAgeInfoSchema>;

export const DeviceAgeNotificationSchema = z.object({ "title": z.string().optional(), "message": z.string().optional(), "pushoverSound": z.string().optional(), "level": z.number().int().optional(), "group": z.string().optional() }).strict();
export type DeviceAgeNotification = z.infer<typeof DeviceAgeNotificationSchema>;

export const SensorAgeInfoSchema = z.object({ "Sensor Start": z.any().optional(), "Sensor Change": z.any().optional(), "min": z.string().optional() }).strict();
export type SensorAgeInfo = z.infer<typeof SensorAgeInfoSchema>;

export const NotificationAckResponseSchema = z.object({ "success": z.boolean().optional(), "message": z.string().optional(), "timestamp": z.number().int().optional() }).strict();
export type NotificationAckResponse = z.infer<typeof NotificationAckResponseSchema>;

export const NotificationAckRequestSchema = z.object({ "level": z.number().int().optional(), "group": z.string().optional(), "time": z.number().int().nullable().optional(), "sendClear": z.boolean().nullable().optional() }).strict();
export type NotificationAckRequest = z.infer<typeof NotificationAckRequestSchema>;

export const PushoverCallbackRequestSchema = z.object({ "receipt": z.string().nullable().optional(), "status": z.number().int().nullable().optional(), "acknowledged_at": z.number().int().nullable().optional(), "acknowledged_by": z.string().nullable().optional(), "user_key": z.string().nullable().optional(), "callback": z.string().nullable().optional() }).strict();
export type PushoverCallbackRequest = z.infer<typeof PushoverCallbackRequestSchema>;

export const AdminNotifiesResponseSchema = z.object({ "status": z.number().int().optional(), "message": z.any().optional() }).strict();
export type AdminNotifiesResponse = z.infer<typeof AdminNotifiesResponseSchema>;

export const AdminNotifiesMessageSchema = z.object({ "notifies": z.array(z.any()).optional(), "notifyCount": z.number().int().optional() }).strict();
export type AdminNotifiesMessage = z.infer<typeof AdminNotifiesMessageSchema>;

export const AdminNotificationSchema = z.object({ "title": z.string().optional(), "message": z.string().optional(), "count": z.number().int().optional(), "lastRecorded": z.number().int().optional(), "persistent": z.boolean().optional() }).strict();
export type AdminNotification = z.infer<typeof AdminNotificationSchema>;

export const PushoverNotificationRequestSchema = z.object({ "title": z.string().optional(), "message": z.string().optional(), "level": z.number().int().nullable().optional(), "group": z.string().nullable().optional(), "priority": z.number().int().nullable().optional(), "sound": z.string().nullable().optional(), "device": z.string().nullable().optional(), "url": z.string().nullable().optional(), "urlTitle": z.string().nullable().optional(), "retry": z.number().int().nullable().optional(), "expire": z.number().int().nullable().optional() }).strict();
export type PushoverNotificationRequest = z.infer<typeof PushoverNotificationRequestSchema>;

export const TimeQueryEchoSchema = z.object({ "req": z.any().optional(), "pattern": z.array(z.string()).optional(), "query": z.record(z.any()).optional() }).strict();
export type TimeQueryEcho = z.infer<typeof TimeQueryEchoSchema>;

export const TimeQueryRequestSchema = z.object({ "params": z.record(z.string().nullable()).optional(), "query": z.record(z.any()).optional() }).strict();
export type TimeQueryRequest = z.infer<typeof TimeQueryRequestSchema>;
