// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error, redirect } from '@sveltejs/kit';
import { z } from 'zod';
import { AcceptMatchRequestSchema, DismissMatchRequestSchema } from '$lib/api/generated/schemas';
import { type AcceptMatchRequest, type DismissMatchRequest } from '$api';

/** Get a food entry for review */
export const getFoodEntry = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.mealMatching.getFoodEntry(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in mealMatching.getFoodEntry:', err);
    throw error(500, 'Failed to get food entry');
  }
});

/** Get suggested meal matches for a date range */
export const getSuggestions = query(z.object({ from: z.coerce.date().optional(), to: z.coerce.date().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.mealMatching.getSuggestions(params?.from, params?.to);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in mealMatching.getSuggestions:', err);
    throw error(500, 'Failed to get suggestions');
  }
});

/** Accept a meal match */
export const acceptMatch = command(AcceptMatchRequestSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.mealMatching.acceptMatch(request as AcceptMatchRequest);
    await Promise.all([
      getSuggestions(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in mealMatching.acceptMatch:', err);
    throw error(500, 'Failed to accept match');
  }
});

/** Dismiss a meal match */
export const dismissMatch = command(DismissMatchRequestSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.mealMatching.dismissMatch(request as DismissMatchRequest);
    await Promise.all([
      getSuggestions(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in mealMatching.dismissMatch:', err);
    throw error(500, 'Failed to dismiss match');
  }
});
