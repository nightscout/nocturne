// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error, redirect } from '@sveltejs/kit';
import { z } from 'zod';
import { SensorGlucoseSchema, MeterGlucoseSchema, CalibrationSchema } from '$lib/api/generated/schemas';
import { type SensorGlucose, type MeterGlucose, type Calibration } from '$api';

/** Get sensor glucose readings with optional filtering */
export const getSensorGlucose = query(z.object({ from: z.number().optional(), to: z.number().optional(), limit: z.number().optional(), offset: z.number().optional(), sort: z.string().optional(), device: z.string().optional(), source: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.glucose.getSensorGlucose(params?.from, params?.to, params?.limit, params?.offset, params?.sort, params?.device, params?.source);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.getSensorGlucose:', err);
    throw error(500, 'Failed to get sensor glucose');
  }
});

/** Create a new sensor glucose reading */
export const createSensorGlucose = command(SensorGlucoseSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.glucose.createSensorGlucose(request as SensorGlucose);
    await Promise.all([
      getSensorGlucose(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.createSensorGlucose:', err);
    throw error(500, 'Failed to create sensor glucose');
  }
});

/** Get a sensor glucose reading by ID */
export const getSensorGlucoseById = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.glucose.getSensorGlucoseById(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.getSensorGlucoseById:', err);
    throw error(500, 'Failed to get sensor glucose by id');
  }
});

/** Update an existing sensor glucose reading */
export const updateSensorGlucose = command(z.object({ id: z.string(), request: SensorGlucoseSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.glucose.updateSensorGlucose(id, request as SensorGlucose);
    await Promise.all([
      getSensorGlucose(undefined).refresh(),
      getSensorGlucoseById(id).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.updateSensorGlucose:', err);
    throw error(500, 'Failed to update sensor glucose');
  }
});

/** Delete a sensor glucose reading */
export const deleteSensorGlucose = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.glucose.deleteSensorGlucose(id);
    await Promise.all([
      getSensorGlucose(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.deleteSensorGlucose:', err);
    throw error(500, 'Failed to delete sensor glucose');
  }
});

/** Get meter glucose readings with optional filtering */
export const getMeterGlucose = query(z.object({ from: z.number().optional(), to: z.number().optional(), limit: z.number().optional(), offset: z.number().optional(), sort: z.string().optional(), device: z.string().optional(), source: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.glucose.getMeterGlucose(params?.from, params?.to, params?.limit, params?.offset, params?.sort, params?.device, params?.source);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.getMeterGlucose:', err);
    throw error(500, 'Failed to get meter glucose');
  }
});

/** Create a new meter glucose reading */
export const createMeterGlucose = command(MeterGlucoseSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.glucose.createMeterGlucose(request as MeterGlucose);
    await Promise.all([
      getMeterGlucose(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.createMeterGlucose:', err);
    throw error(500, 'Failed to create meter glucose');
  }
});

/** Get a meter glucose reading by ID */
export const getMeterGlucoseById = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.glucose.getMeterGlucoseById(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.getMeterGlucoseById:', err);
    throw error(500, 'Failed to get meter glucose by id');
  }
});

/** Update an existing meter glucose reading */
export const updateMeterGlucose = command(z.object({ id: z.string(), request: MeterGlucoseSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.glucose.updateMeterGlucose(id, request as MeterGlucose);
    await Promise.all([
      getMeterGlucose(undefined).refresh(),
      getMeterGlucoseById(id).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.updateMeterGlucose:', err);
    throw error(500, 'Failed to update meter glucose');
  }
});

/** Delete a meter glucose reading */
export const deleteMeterGlucose = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.glucose.deleteMeterGlucose(id);
    await Promise.all([
      getMeterGlucose(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.deleteMeterGlucose:', err);
    throw error(500, 'Failed to delete meter glucose');
  }
});

/** Get calibrations with optional filtering */
export const getCalibrations = query(z.object({ from: z.number().optional(), to: z.number().optional(), limit: z.number().optional(), offset: z.number().optional(), sort: z.string().optional(), device: z.string().optional(), source: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.glucose.getCalibrations(params?.from, params?.to, params?.limit, params?.offset, params?.sort, params?.device, params?.source);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.getCalibrations:', err);
    throw error(500, 'Failed to get calibrations');
  }
});

/** Create a new calibration */
export const createCalibration = command(CalibrationSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.glucose.createCalibration(request as Calibration);
    await Promise.all([
      getCalibrations(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.createCalibration:', err);
    throw error(500, 'Failed to create calibration');
  }
});

/** Get a calibration by ID */
export const getCalibrationById = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.glucose.getCalibrationById(id);
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.getCalibrationById:', err);
    throw error(500, 'Failed to get calibration by id');
  }
});

/** Update an existing calibration */
export const updateCalibration = command(z.object({ id: z.string(), request: CalibrationSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.glucose.updateCalibration(id, request as Calibration);
    await Promise.all([
      getCalibrations(undefined).refresh(),
      getCalibrationById(id).refresh()
    ]);
    return result;
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.updateCalibration:', err);
    throw error(500, 'Failed to update calibration');
  }
});

/** Delete a calibration */
export const deleteCalibration = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.glucose.deleteCalibration(id);
    await Promise.all([
      getCalibrations(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    const status = (err as any)?.status;
    if (status === 401) { const { url } = getRequestEvent(); throw redirect(302, `/login?redirectTo=${encodeURIComponent(url.pathname + url.search)}`); }
    if (status === 403) throw error(403, 'Forbidden');
    console.error('Error in glucose.deleteCalibration:', err);
    throw error(500, 'Failed to delete calibration');
  }
});
