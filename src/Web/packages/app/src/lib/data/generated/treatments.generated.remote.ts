// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error } from '@sveltejs/kit';
import { z } from 'zod';
import { TreatmentSchema } from '$lib/api/generated/schemas';
import { type Treatment } from '$api';

/** Get treatments with optional filtering and pagination.
Unlike V1-V3 endpoints, this does NOT include StateSpan-derived basal data.
For basal delivery, query /api/v4/state-spans?category=BasalDelivery instead. */
export const getTreatments = query(z.object({ eventType: z.string().optional(), count: z.number().optional(), skip: z.number().optional(), find: z.string().optional() }).optional(), async (params) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.treatments.getTreatments(params?.eventType, params?.count, params?.skip, params?.find);
  } catch (err) {
    console.error('Error in treatments.getTreatments:', err);
    throw error(500, 'Failed to get treatments');
  }
});

/** Create a treatment with tracker integration.
If the treatment's event type matches a tracker's trigger event types,
the tracker instance will be automatically started/restarted. */
export const createTreatment = command(TreatmentSchema, async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.treatments.createTreatment(request as Treatment);
    await Promise.all([
      getTreatments(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    console.error('Error in treatments.createTreatment:', err);
    throw error(500, 'Failed to create treatment');
  }
});

/** Create multiple treatments with tracker integration. */
export const createTreatments = command(z.array(TreatmentSchema), async (request) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.treatments.createTreatments(request as Treatment[]);
    await Promise.all([
      getTreatments(undefined).refresh()
    ]);
    return result;
  } catch (err) {
    console.error('Error in treatments.createTreatments:', err);
    throw error(500, 'Failed to create treatments');
  }
});

/** Get a specific treatment by ID */
export const getTreatment = query(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.treatments.getTreatment(id);
  } catch (err) {
    console.error('Error in treatments.getTreatment:', err);
    throw error(500, 'Failed to get treatment');
  }
});

/** Update an existing treatment by ID */
export const updateTreatment = command(z.object({ id: z.string(), request: TreatmentSchema }), async ({ id, request }) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.treatments.updateTreatment(id, request as Treatment);
    await Promise.all([
      getTreatments(undefined).refresh(),
      getTreatment(id).refresh()
    ]);
    return result;
  } catch (err) {
    console.error('Error in treatments.updateTreatment:', err);
    throw error(500, 'Failed to update treatment');
  }
});

/** Delete a treatment by ID */
export const deleteTreatment = command(z.string(), async (id) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    await apiClient.treatments.deleteTreatment(id);
    await Promise.all([
      getTreatments(undefined).refresh()
    ]);
    return { success: true };
  } catch (err) {
    console.error('Error in treatments.deleteTreatment:', err);
    throw error(500, 'Failed to delete treatment');
  }
});
