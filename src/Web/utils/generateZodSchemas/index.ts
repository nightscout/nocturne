#!/usr/bin/env node --experimental-strip-types

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { z } from "zod";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OPENAPI_PATH = path.join(
  __dirname,
  "../../packages/app/src/lib/api/generated/openapi.json",
);
const OUTPUT_PATH = path.join(
  __dirname,
  "../../packages/app/src/lib/api/generated/schemas.ts",
);

interface OpenApiSchema {
  openapi: string;
  components?: {
    schemas?: Record<string, object>;
  };
}

function generateZodSchemas(): void {
  console.log("Generating Zod schemas from OpenAPI spec using z.fromJSONSchema()...");

  if (!fs.existsSync(OPENAPI_PATH)) {
    console.error(`OpenAPI spec not found at: ${OPENAPI_PATH}`);
    console.error("Run 'pnpm run generate-api-client' first to generate the OpenAPI spec.");
    process.exit(1);
  }

  const openApiContent = fs.readFileSync(OPENAPI_PATH, "utf8");
  const openApi: OpenApiSchema = JSON.parse(openApiContent);

  if (!openApi.components?.schemas) {
    console.error("No schemas found in OpenAPI spec");
    process.exit(1);
  }

  const schemas = openApi.components.schemas;
  const schemaNames = Object.keys(schemas);
  console.log(`Found ${schemaNames.length} schemas to convert`);

  const lines: string[] = [
    "// Auto-generated from OpenAPI spec - DO NOT EDIT",
    "// Generated by: pnpm run generate-zod-schemas",
    `// Source: openapi.json (${new Date().toISOString()})`,
    "",
    "import { z } from 'zod';",
    "",
  ];

  let successCount = 0;
  let fallbackCount = 0;

  for (const [name, schema] of Object.entries(schemas)) {
    try {
      // Resolve $refs by inlining referenced schemas, strip x- extensions
      const resolved = resolveSchema(schema, schemas);
      const jsonSchemaStr = JSON.stringify(resolved);

      // Validate at generation time
      z.fromJSONSchema(resolved as z.JSONSchema, { defaultTarget: "openapi-3.0" });

      lines.push(`export const ${name}Schema = z.fromJSONSchema(${jsonSchemaStr} as const, { defaultTarget: "openapi-3.0" });`);
      lines.push(`export type ${name} = z.output<typeof ${name}Schema>;`);
      lines.push("");
      successCount++;
    } catch (err) {
      console.warn(`Warning: Failed to convert schema '${name}':`, (err as Error).message ?? err);
      lines.push(`// Failed to generate schema for ${name}`);
      lines.push(`export const ${name}Schema = z.any();`);
      lines.push(`export type ${name} = z.output<typeof ${name}Schema>;`);
      lines.push("");
      fallbackCount++;
    }
  }

  const output = lines.join("\n");
  fs.writeFileSync(OUTPUT_PATH, output, "utf8");
  console.log(`Generated ${successCount} Zod schemas (${fallbackCount} fallbacks) at: ${OUTPUT_PATH}`);
}

/**
 * Resolve $ref by inlining referenced schemas, and strip x- vendor extensions.
 */
function resolveSchema(
  schema: unknown,
  allSchemas: Record<string, object>,
  visited = new Set<string>()
): unknown {
  if (schema === null || typeof schema !== "object") {
    return schema;
  }

  if (Array.isArray(schema)) {
    return schema.map((item) => resolveSchema(item, allSchemas, visited));
  }

  const obj = schema as Record<string, unknown>;

  // Handle $ref - inline the referenced schema
  if ("$ref" in obj && typeof obj.$ref === "string") {
    const match = (obj.$ref as string).match(/#\/components\/schemas\/(\w+)/);
    if (match) {
      const refName = match[1];
      if (visited.has(refName)) {
        return {};
      }
      const refSchema = allSchemas[refName];
      if (refSchema) {
        const newVisited = new Set(visited);
        newVisited.add(refName);
        return resolveSchema(refSchema, allSchemas, newVisited);
      }
    }
    return {};
  }

  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("x-")) continue;
    result[key] = resolveSchema(value, allSchemas, visited);
  }
  return result;
}

generateZodSchemas();

export default generateZodSchemas;
